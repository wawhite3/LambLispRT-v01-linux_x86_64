<!-- HTML header for doxygen 1.16.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LambLisp: Real-time Lisp for Microprocessors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome-cust.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="lamb-39.jpeg"/></td>
  <td id="projectalign">
   <div id="projectname">LambLisp<span id="projectnumber">&#160;01 Red Fox Alpha</span>
   </div>
   <div id="projectbrief">Lisp For Real-Time Control</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('index.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Real-time Lisp for Microprocessors </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README-extended"></a></p>
<div class="image">
<img src="lamb-DALL-01.png" alt="" width="25%"/>
<div class="caption">
Eponymous Lamb</div></div>
    <p><b>LambLisp</b> by<img src="FrobeniusNorm-logo-01.png" alt="" class="inline" title="FrobeniusNorm"/>     Copyright 2025 <a href="https://frobeniusnorm.com">Frobenius Norm LLC.</a></p>
<p><b>LambLisp</b> is a <b>real-time</b> implementation of the <b>Scheme</b> dialect of the <b>LISP</b> programming language. <em>Scheme</em> is governed by standards known as <em>Scheme R5RS</em> and <em>Scheme R7RS</em>. LambLisp is designed primarily to <em>Scheme R5RS</em>, with some features from <em>Scheme R7RS</em> and <b>Common Lisp</b> that aid in development of <b>real-time embedded control systems</b>.</p>
<p><em>LambLisp</em> provides a robust and scalable Hardware Abstraction Layer (HAL). The LambLisp HAL allows convenient interoperability with existing device drivers or other existing C/C++ libraries.</p>
<p><em>LambLisp</em> is now running on <b>Espressif ESP32</b> using the tools from <b>platformio</b>. <em>LambLisp</em> has a built-in Arduino-style hardware abstraction layer, a standard way to introduce new capability using existing C++ code, and many other features focused on embedded controls.</p>
<p>A <b>hardware demo</b> is available, built on the ESP32-based <b>Freenove 4WD Car Kit</b>, programmed as a simple autonomous vehicle. The vehicle demonstrates a variety of hardware control techniques, including time management for high throughput and low latency.</p>
<p>A <b>Linux</b> version of <em>LambLisp</em> is also available. Linux is not a real-time operating system, but it will allows use of LambLisp's other advanced features, such as tail-recursion, adaptive incremental garbage collection, first-class hierarchical dictionaries and first-class macros. simple integration with existing C/C++ libraries or hardware drivers such as I2C devices and CUDA.</p>
<p> For more information:</p><ul>
<li><p class="startli">Read the LambLisp manual online at <br  />
<a href="https://wawhite3.github.io/LambLispRT-v01-linux_x86_64/html/index.html">https://wawhite3.github.io/LambLispRT-v01-linux_x86_64/html/index.html</a></p>
</li>
<li><p class="startli">Find the LambLisp manual in PDF at <br  />
<a href="https://wawhite3.github.io/LambLispRT-v01-linux_x86_64/LambLisp.pdf">https://wawhite3.github.io/LambLispRT-v01-linux_x86_64/LambLisp.pdf</a></p>
</li>
<li><p class="startli">Download the full LambLisp repositories from <br  />
<a href="https://github.com/wawhite3/?tab=repositories&amp;q=LambLispRT">https://github.com/wawhite3/?tab=repositories&amp;q=LambLispRT</a></p>
</li>
<li><p class="startli">Visit the developer <a href="https://frobeniusnorm.com">Frobenius Norm</a> at <a href="https://frobeniusnorm.com">https://frobeniusnorm.com</a>.</p>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The code repository is renewed frequently, with history deleted. Always check back to see if a new repo is available, not just an update to the previous repo.  </dd></dl>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1"></a>
Why Lisp?</h1>
<p><b>LISP</b> is the original language of artificial intelligence, and is the second-oldest programming language still in use (after Fortran). It was designed for <em>symbolic reasoning</em> rather than computation. From the theoretical base beginning about 1960, <em>LISP</em> quickly grew into a practical language with several well-supported variants. <em>LISP</em> and LISP programs were always uppercase; the 8-bit byte had not yet been standardized and text was often packed into 6-bit chunks with no room for lower case.</p>
<p>Today, approaching the mid-21st century, <em>Lisp</em> is active in many variants: SKILL from Cadence Design, AutoDesk Lisp, ChezScheme from Cisco, and others. Like <em>LambLisp</em>, these are often tailored to solve problems in a specific domain, and descend from either <em>Scheme</em> or the earlier <em>Common Lisp</em>. <em>LambLisp</em> is optimized for intelligent real-time control of physical processes.</p>
<p>The <em>LambLisp</em> bibliography contains a mini-history of automated symbolic reasoning since the Renaissance. It contains work beginning with Isaac Newton and Bertrand Russell, through to Alonzo Church, John McCarthy, and Edsger Dijkstra, as well as many less famous and more recent authors. In the 21st century development of automated symbolic reasoning continues, with recent publications on already well-trod topics as real-time garbage collection and macro expansion. New approaches to artificial intelligence have created renewed interest in systems (like <em>Lisp</em>) that offer provable correctness and traceable results.</p>
<p>Any papers cited in the <em>LambLisp</em> documentation can be found in the bibliography at <br  />
<a href="https://github.com/wawhite3/LambLisp-Bibliography">https://github.com/wawhite3/LambLisp-Bibliography</a></p>
<p>Additionally, these books provide excellent exposure to many of the issues encountered when developing a <em>Lisp</em> programming system:</p><ul>
<li><p class="startli">Structure and Interpretation of Computer programs (Abelman and Sussman). Known as SICP, it was a standard Computer Science textbook for many years.</p>
</li>
<li><p class="startli">Lisp in Small Pieces (Quiennec). Another excellent textbook, which drew lessons from SICP and examines more topics and more detail.</p>
</li>
<li><p class="startli">The Art of Computer Programming (Knuth). Written in the pre-C era, TAOCP is an encyclopedia of algorithms that remain foundational to modern computer science.</p>
</li>
</ul>
<p><em>Lisp</em> invented, aggregated, or evolved all the important techniques used in programming languages today:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Some <em>Lisp</em> Innovations  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">stepwise code optimization  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">interactive computing  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">just-in-time compilation  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">on-the-fly code updates  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">macro expansion  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">polymorphism &amp; "duck" typing  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">object systems  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">lexical and dynamic scoping  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tail recursion  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">garbage collection  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">parameter passing modes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">exception handling  </td></tr>
</table>
<p><em>Lisp</em> offers tremendous scalability. At the <em>micro</em> end, <em>Lisp</em> makes an ideal <em>assembly language</em>, with a simple prefix notation that can transform directly into machine instructions. At the <em>macro</em> end, new functions can be defined and combined dynamically in a way not possible in C++ or Python. These new functions can be the results of substantial analysis performed elsewhere (call it <b>AI</b>), putting it at a scale billions of time larger than the assembly language application.</p>
<p><em>Lisp</em> is <b>interactive</b> and <em>Lisp</em> programs can be modified on-the-fly, while they are running. Programs can evolve. In other languages, predefined parameters may be tuned during operation, but the code does not change. In <em>Lisp</em>, the code may continually evolve, and provides <em>Lisp</em> with the power of induction and of continuous improvement.</p>
<p>The concept of interactive computing applies not only to interaction with people. <b>Machine-to-machine interaction</b> is an inherent behavior of the interactive nature of <em>Lisp</em>. In <em>LambLisp</em>-based control systems new algorithms can be developed off-system, and then downloaded without interrupting the controlled process. Today, those off-system resources can be <b>AI assets</b> in the cloud, and <em>LambLisp</em> can be the target of <b>AI-generated code</b>.</p>
<p>An important part of the attraction of <em>Lisp</em> is the simple syntax, based on just a few rules that are compact and fast on any processor, even in 1960. This led to a variety of <em>Lisp</em> dialects; two of the most important are <em>Common Lisp</em> and <em>Scheme</em>. <em>Common Lisp</em> is in the "large Lisp" category, although there are many partially-compatible subset implementations.</p>
<p><em>Scheme</em> is in the "medium-size Lisp" category, and was a purposeful attempt to distill the fundamental behaviors of <em>Common Lisp</em> into a simpler set.</p>
<p>In the lifetime of <em>Lisp</em>, many processors have come and gone. Today ARM-based processors have scaled to be competitive in many control applications. There is a wide variety of boards and modules available, and plenty of inexpensive parts running on the commonly available I2C bus. Today's 32-bit microprocessors present an ideal platform for <em>Lisp</em> real-time control.</p>
<p> </p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md2"></a>
Why <em>LambLisp</em>?</h1>
<p>There are some features that make <em>LambLisp</em> special in the <em>Lisp</em> menagerie.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
Real-time control</h2>
<p><em>LambLisp</em> has been optimized to solve <b>real-time control</b> problems, using a variety of techniques described elsewhere in this document. The primary breakthroughs in real-time <em>Lisp</em> were published in <b>Dijkstra 1976</b>, and elaborated in <b>Yuasa 1990</b>. These papers describe how to eliminate the long pause required for stop-the-world garbage collection.</p>
<p><em>LambLisp</em> allows continuous interaction with supervisory controllers. In turn, this allows the use of off-system rescources, such as <b>AI systems</b>, to monitor embedded performance, tune existing parameters, and install new algorithms on-the-fly without loss of control.</p>
<p><em>LambLisp</em> also adds many enhancements for real-time control, such as fast type-specific operations and Arduino-compatible API.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
Widely recognized <em>Scheme</em> language specification</h2>
<p><em>LambLisp</em> substantially conforms to the <b>Scheme R5RS specification</b>. <em>Scheme</em> is widely taught and there is plenty of information online. There are also many desktop versions of <em>Scheme</em> available for study.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
Reuse of existing C++/Arduino libraries</h2>
<p><em>LambLisp's</em> open API allows existing code to be easily incorporated into the <em>Lisp</em> environment. These libraries require only a thin dispatch layer and run at at the same full speed as any other <em>LambLisp</em> native function.</p>
<p>There are a few embedded micro-Lisps but they require new libraries for each supported device or feature. The same can be said of the micro-Pythons. The micro-Lisps also have evolved on the tiniest processors, and therefore provide a small <em>Lisp</em> core but no conformance to any particular specification.</p>
<p><em>LambLisp</em> can incorporate existing C/C++ libraries unchanged, and has a built-in interface to Arduino-style I/O, including I2C (Wire) and WiFi.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
Adaptive real-time garbage collection</h2>
<p><em>Lisp</em> behavior depends on a continuous supply of memory, which must be reclaimed when no longer in use, and then later reissued. The reclamation process is called <b>garbage collection</b> or just <b>GC</b>.</p>
<p>Until the 1990s, <em>Lisp</em> could not be applied to real-time control applications due to unpredictable lapses in control during <em>GC</em>. While <em>GC</em> was occurring, the controlled application was left unsupervised. This problem was solved by Taichi Yuasa, based on earlier work by Edsger Dijkstra. Yuasa provided a provably correct solution that divided <em>GC</em> into increments, and provided formulas for the key metrics in a correct implementation. Yuasa's solution was implemented in <em>Kyoto Common Lisp</em>.</p>
<p>Yuasa's solution appeared during the era of <em>Lisp Machines</em>, which were designed to execute compiled <em>Lisp</em> programs. <em>Lisp</em> machines were overtaken by Moore's law and the rapid scaling of x86 processors. The <em>Lisp Machine Industry</em> collapsed during the AI winter of the 1990s and the subsequent dot-com bust. The x86 (or its direct competitors) became the minimum required for running <em>Lisp</em>.</p>
<p>In <em>LambLisp</em> real-time guarantees are provided by Yuasa's <em>GC</em> formula, and LambLisp realizes additional performance gains with <em>GC</em> idle-time look-ahead. <em>LambLisp</em> continuously calculates the <em>GC</em> start threshold (Yuasa's M metric) and allocates additional memory when required (Yuasa's N metric). Additionaly, <em>LambLisp</em> implements idle-time look-ahead, whereby application idle time can be applied to garbage collection; later during peak loads GC passes can be omitted altogether.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7"></a>
Open API for new <em>Lisp</em> primitives</h2>
<p><em>LambLisp's</em> open API allows new language features to be implemented in C++ and easily incorporated into the <em>Lisp</em> runtime environment. There is no special "foreign function interface" as in other <em>Lisps</em>; simply write a function with the correct signature, and assign it a value in the <em>LambLisp</em> runtime environment. This is how all the <em>LambLisp</em> native functions are implemented; any new functions added are not "foreign" and do not suffer a performance penalty. This design is also useful for writing and distributing proprietary code.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8"></a>
Incremental over-the-air updates without reboot</h2>
<p>In C++-based systems, half of the persistent storage must be devoted to over-the-air updates. In this case, an entire new program image is downloaded before the existing image is marked obsolete. After, that, the storage for the old image is still required for future OTA updates, but otherwise is not used again. A reboot is required to start the new image.</p>
<p>With <em>LambLisp</em>, OTA updates can be incremental. By updating definitions in the execution environment, new <em>LambLisp</em> code runs as soon as it appears. The memory used by the obsolete code will be reclaimed. No reboot is required after an update.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9"></a>
First-class hierarchical dictionaries</h2>
<p>A part of the success of Python has been its pervasive use of hash tables. Hash tables are also used extensively in <em>LambLisp</em>, supporting the representation of environments, dictionaries, and objects. <em>LambLisp</em> dictionaries are <em>hierarchical</em>, providing a parent/child relationship between hash tables. The internal execution environment of <em>LambLisp</em> is a dictionary.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10"></a>
Incremental, just-in-time compilation</h2>
<p>Much of <em>LambLisp</em> behavior is implemented in the <em>runtime system</em>, a collection of compiled routines that perform the basic operations defined in the <em>Scheme</em> specification. The process of compiling begins with "expanding" those symbols whose values are functions. In this case, "expanding" means to replace the symbol with its value (a <em>procedure</em>) wherever appropriate. This can be done case-by-case; when a <em>LambLisp</em> program is fully transformed this way, execution becomes a series of linked C++ function calls. The downside to this is that debug information is lost.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md11"></a>
Lexical scoping</h2>
<p><em>Lexical scoping</em> is what most programmers are already familiar with. C/C++ and Python programmers will discuss <em>local variables</em> and <em>global variables</em>; these are typical in lexical scoping. Some <em>Lisps</em> (but not <em>Scheme</em> or <em>LambLisp</em>) have <em>dynamic environments</em> and <em>special variables</em>, which do not follow the familiar lexical convention. In <em>Scheme</em> and <em>LambLisp</em> there is only <em>lexical scoping</em>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md12"></a>
Tail recursion and tail-calls</h2>
<p><em>Tail calls</em> allow many problems to be solved recursively without a growing stack, allowing compact, inductive code in place of iteration. <em>Continuation-passing style</em> is a programming idiom on which the next step in a computation is always an extra argument to every procedure. That "next step" is called a <em>continuation</em>. When a procedure has determined its result, instead of returning, it tail-calls the continuation. This is an elegant way to solve many problems by induction.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13"></a>
Procedures are first-class data types</h2>
<p>Procedures are created as the result of evaluating a <b>lambda expression</b>. They get created, stored, and destroyed, just as any other value. They can be passed as arguments to other procedures. In LambLisp the <b>nlambda</b> and <b>macro</b> expressions are specialized <em>procedures</em>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md14"></a>
Runtime collaboration with C++ code</h2>
<p>New <em>LambLisp</em> native functions can be written in C++, and then objects created by C++ constructors can be passed to <em>LambLisp</em> for processing when required. These objects can also (optionally) get automatically garbage collected when <em>LambLisp</em> has finished with them. One of the design goals of <em>LambLisp</em> is convenient scalability between C++ and <em>Lisp</em> layers.</p>
<p> </p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md15"></a>
Key feature summary</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LambLisp Features  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Substantial conformance to Scheme R5RS specification.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Additional features from Scheme R7RS and Common Lisp specifications.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Optimized for 32-bit microprocessor control applications (ARM, ESP32).  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Available for Linux. (with limited hardware I/O)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">High-level implementation of language primitives for compact high performance.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Compiler with just-in-time and incremental features for optimized size/speed.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Arduino-compatible interfaces for digital &amp; analog I/O, I2C, SPI, WiFi, etc.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Easy addition of manufacturer-provided C/C++ hardware drivers.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Easy integration of application-specific C++ functions.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Leverage existing Arduino skill set, gcc-based tool chain, C runtime.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Adaptive incremental garbage collector for fast, uniform loop times.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Selectable run-time packages (math, ethernet etc) to control program size.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Virtual memory capability from remote or local storage.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Incremental code updates over-the-air without pausing control or rebooting.  </td></tr>
</table>
<p> </p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
<em>Lisp</em> in a nutshell</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Elements of <em>Lisp</em>  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Spaces are separators between expressions.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">If an expression starts with <span class="tt">(</span>, then it is a <b>list</b> and requires a matching <span class="tt">)</span>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Otherwise, the next group of characters, up to a space, is a <b>symbol</b>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">In both cases the expression is called a <b>symbolic expression</b>, or <b>S-expression</b>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">A <em>list</em> contains 0 or more S-expressions between its parenthesis, as in <span class="tt">()</span> <span class="tt">(foo)</span> <span class="tt">(1 (2 three) 4)</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">There is an <b>environment</b> that associates symbols with values.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">There is a small foundational set of <b>procedures</b> that accept arguments and return new S-expressions.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">An <b>evaluator</b> continuously reads <em>S-expressions</em>, evaluates them, and returns the result.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">If the evaluator encounters a list, the first item in the list must be a <em>procedure</em> and it will be <b>applied</b> to the arguments provided.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>To <b>apply</b> a procedure to a list of arguments, the <em>formal parameters</em> of the <em>procedure</em> are paired with the actual arguments provided in the application. Then those pairs are added as bindings to the environment of the <em>lambda expression</em>. Finally, the body of the <em>procedure</em> is evaluated in that augmented environment.</dd></dl>
<p>In the <em>Lisp</em> world, any item not a list (or more accurately a <em>pair</em>) is called an <b>atom</b>. Numbers, strings, and vectors all are <em>atoms</em>. Perhaps surprisingly, the foundational <em>Lisp</em> does not require these, as they can be implemented using purely symbolic programming. There is an important distinction here between the <em>mathematical foundations of Lisp</em>, the <em>programming language called Lisp</em>, and <em>implementations of Lisp</em>.</p>
<p>Many areas of mathematics have only thrived after a notation was introduced to facilitate reasoning about it. Think of <em>sine</em>, <em>cosine</em>, the <em>square root</em> symbol, integral and differential calculus, matrix algebra, etc.</p>
<p>Likewise, <em>Lisp</em> established a small set of symbols and their behavior when encountered in a program. In the days of pen and paper, greek letters would have been used, as they were in the <b>lambda calculus</b> from which <em>Lisp</em> inherits its intellectual grounding and the <b>lambda</b> operator. In the teletype era, only the typewriter symbols were available.</p>
<p><em>Lisp</em> was created to perform <em>symbolic reasoning</em>. <em>Lisp's</em> elements of reasoning about symbolic expressions:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><em>Lisp</em> symbolic expressions  </th><th class="markdownTableHeadNone">Description of operation  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>symbols</b>  </td><td class="markdownTableBodyNone">A sequence of non-spaces, such as <span class="tt">x</span>, <span class="tt">2day</span>, and <span class="tt">next&lt;&gt;thursday</span>. Non-space characters may appear anywhere in a <em>symbol</em>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">#f</span> and <span class="tt">#t</span>  </td><td class="markdownTableBodyNone"><span class="tt">#f</span> represents <b>false</b>, while <span class="tt">#t</span> represents <b>true</b>. Anything not <em>false</em> is considered <em>true</em>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">()</span> or <span class="tt">NIL</span> or <span class="tt">nil</span>  </td><td class="markdownTableBodyNone">A singleton that is an <em>atom</em> and a <em>list</em>, but not a <em>pair</em>. Used as a sentinel to terminate lists.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>lists</b>  </td><td class="markdownTableBodyNone">A set of parenthesis enclosing 0 or more <em>symbols</em> or <em>lists</em>, as in <span class="tt">(1-element-list)</span> and <span class="tt">(nested (nested () list) lists)</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>environment</b>  </td><td class="markdownTableBodyNone">An association between symbols and values. Often implemented as a list of pairs: <span class="tt">((x 12)  (2day 42))</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">if</span>  </td><td class="markdownTableBodyNone">Execute test and choose from alternate code paths.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">eq?</span>  </td><td class="markdownTableBodyNone">Accepts 2 arguments and returns <b>false</b> if they are not the same S-expression.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">define</span>  </td><td class="markdownTableBodyNone">Update or install new <span class="tt">(symbol value)</span> pair in the current environment.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">set!</span>  </td><td class="markdownTableBodyNone">Update existing <span class="tt">(symbol value)</span> pair in the current environment.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">lambda</span>  </td><td class="markdownTableBodyNone">Creates a <b>procedure</b>; i.e., a set of formal parameters, a body of <em>Lisp</em> code, and the environment in which is was defined.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">eval</span>  </td><td class="markdownTableBodyNone">S-expression <b>evaluation</b>; if a list, the <em>procedure</em> at the front of the list is <b>applied</b> to the remaining arguments.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">apply</span>  </td><td class="markdownTableBodyNone">Execute the body of a <em>lambda</em>, in its original environment enhanced with the arguments to <span class="tt">apply</span> paired to the procedure's formal parameters.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">quote</span>  </td><td class="markdownTableBodyNone">Prevent evaluation of something that would normally be evaluated.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">macro</span>  </td><td class="markdownTableBodyNone">A procedure that accepts its arguments unevaluated, i.e., as source code, and returns new source code to be executed in its place.  </td></tr>
</table>
<p>Some terms should be defined in the <em>Lisp</em> context; for example <em>operators</em>, <em>functions</em>, <em>procedures</em>, <em>macros</em> are related concepts, but not identical. <br  />
 </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Important axiomatic behaviors  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">The word <b>operator</b> is used for any S-expression found in the first position of a list at evaluation time.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">An <em>operator</em> must resolve to a <em>procedure</em> before it can be <em>applied</em>, i.e., the operator position may be occupied by a symbol or other expression.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">The word <b>function</b> is ambiguous and may refer to a <em>lambda</em> expression or a <em>procedure</em>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">A <b>lambda expression</b> defines a function's parameters and body, such as <span class="tt">(lambda (p1 p2 p2) (do-something p1 p2 p3))</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">The first argument of a <em>lambda expression</em> is the list of <em>formal parameters</em>, and the remaining arguments (the <em>body</em>) are S-expressions to be evaluated at runtime.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">A <b>procedure</b> is a <em>pair</em> consisting of a <em>lambda expression</em> and an <em>environment</em> in which the procedure was created.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">A <b>macro</b> is a procedure whose arguments are not evaluated before the code body is applied; afterwards the result of applying the code body is further evaluated.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>When a <em>lambda expression</em> is executed, it returns a <em>procedure</em>. A <em>procedure</em> records both the formal arguments and the body of the <em>lambda expression</em>, and also the <em>environment</em> in which the <em>lambda expression</em> was evaluated.</dd></dl>
<p>This by itself is an incredibly powerful set of mathematics, but note that it has no numbers or strings. That is because, from the point of view of symbolic expressions, numbers and strings are just symbols. It is easy to write a function to add 2 digits when the digits are just <span class="tt">0</span> and <span class="tt">1</span>. From the point of view of pure mathematics, numbers are a result, not an axiom. The same can be said of strings. One advantage of this approach is that programs become amenable to proofs of correctness by induction.</p>
<p>Adding numbers, strings, and vectors to <em>Lisp's</em> capabilities provides computing facilities for real-world problem types. Adding these types means adding representations for them, and adding operators that can manipulate them. <em>Lisp</em> follows the usual rules for representing numbers and strings, and so below we present a list of typical symbolic expressions: </p><div class="fragment"><div class="line">1</div>
<div class="line">&quot;Here is a string&quot;</div>
<div class="line">(1 2 3)</div>
<div class="line">(42 &quot;another string&quot; (nested list))</div>
<div class="line">(+ 1 2 (* 3 4))</div>
<div class="line">sym</div>
</div><!-- fragment --><p> The first 2 expressions are <em>atoms</em>, and when encountered by the evaluator they are not further evaluated, or put another way, they evaluate to themselves.</p>
<p>The third expression <span class="tt">(1 2 3)</span> is a valid S-expression (a list), but the evaluator will reject it because the first element of the list (<span class="tt">1</span>) is not a procedure. The same applies to the fourth expression. These are legitimate S-expressions, but the evaluator cannot <em>apply</em> the first element, which must be a <em>procedure</em>.</p>
<p>The fifth expression can be processed by the evaluator, resulting in the number <span class="tt">15</span>.</p>
<p>The sixth expression <span class="tt">sym</span> is a <em>symbol</em>. A symbol is also a type of <em>atom</em>. When encountered by the evaluator, the symbol is looked up in the current environment, and the result of the evaluation is the value associated with the symbol. It is an error if the symbol does not exist in the environment.</p>
<p>Lisp was developed by discovery, rather than predefinition, and each successful experiment led to another language "standard feature". Eventually this led to overstuffing, as witnessed by Guy Steele's 1000-page tome <em>Common Lisp</em>. With a specification that size, many partially compatible subsets emerged, losing some of the <em>Common</em> in <em>Common Lisp</em>.</p>
<p>In reaction to the size of Common Lisp, an effort was made to extract the most useful and essential behaviors of Lisp into a simpler package, which became <em>Scheme</em>. Just as effectively as Guy Steele had recorded <em>Common Lisp</em> for posterity, he was also a key figure in factoring out the fundamental behaviors exhibited by a Lisp machine. Those basic behaviors, in combination, could be used to produce all the other more complex behavior. The result is the set of functions found in <em>Scheme</em>.</p>
<p>The <em>Scheme</em> variant of <em>Lisp</em> has many features familiar to programmers in other languages, such as <em>lexical scoping</em> and <em>duck typing</em>, as well as advanced features such as tail recursion, first-class procedures, and continuation-passing style.</p>
<p> </p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md17"></a>
Getting Started</h1>
<p><em>LambLisp</em> is copyright 2025 by Frobenius Norm LLC, a Massacusetts corporation.</p>
<p><em>LambLisp</em> is a commercial product, and requires a license when used to generate revenue, to promote other products or services, or other commercial activity. Licensing allows for <em>LambLisp</em> customization, hardware application development assistance, post-deployment support, and a warranty.</p>
<p><em>LambLisp</em> may be used for non-commercial purposes, but comes with no support and no warranty of any kind.</p>
<p><em>LambLisp</em> is in ALPHA state, so these directions may be incomplete and contain errors.</p>
<p>Do not use <b>ALPHA</b> code on any control application where life or property may be endangered.</p>
<p>You should have some familiarity with embedded computing, cross compiling, and related issues. <em>LambLisp</em> is developed using some handy tools from <em>platformio</em>, which handles most of the compiler-related activity formerly done through makefiles. Using <em>platformio</em> is not required, but convenient.</p>
<p>Using Visual Studio is also not required, but it offers some convenience. There is a <em>platformio</em> plugin for Visual Studio that is useful for finding existing C/C++ device driver or other libraries. It also has a useful interface to the in-circuit debugger available on some ESP32 modules. You don't need to use Visual Studio as your primary editor, but these features make it occasionally very useful.</p>
<p><em>LambLisp</em> is developed on Linux. To test LambLisp on Wondows, use VirtualBox or similar virtualization software to run a Linux instance, and run LambLisp inside that instance.</p>
<p>In examples it is generally assumed that the working directory is ~/src/LambLispRT-vxx, where xx is the public version number.</p>
<ul>
<li><p class="startli">Purchase an Espressif ESP32 module. The ESP32-devkit-C is known to work, and has a second USB that can be used to access the onboard in-ciruit debugger. Connect both ESP32 USB ports to your development computer.</p>
<p class="startli">Additionally or alternatively, purchase and assemble the Freenove 4WD Car Kit based on ESP32. This will allow a thorough assessment of LambLisp's control capabilities, with direct digital &amp; analog in/out, motor control over I2C, strip LED control, and many other software-based control features including timers and task queues. There is no in-circuit debugger on this Freenove ESP32 board.</p>
<dl class="section note"><dt>Note</dt><dd>It is useful to set up both the ESP32 devkit and your own hardware project and be able to build each one on demand. When, as eventually happens, a difficult bug appears, the in-circuit debugger can sometimes save hours of labor. Arrange your hardware pin definitions and error handling so the the application continues to run on the ESP32 devkit even when the hardware is not present, and it will be easy to switch between dev kit and real hardware.</dd>
<dd>
There is also a Linux native version of <em>LambLisp</em>, without hardware dependencies. This is useful as an alternative environment for debugging, and desktop resources can be used. Allowing for regular builds on ESP32 dev kit, Linux desktop, and the targeted custom hardware, lends itself to a variety of debugging techniques and platforms that can be quickly applied to confirm and localize reported bugs.</dd></dl>
</li>
<li><p class="startli">Download the LambLisp repo from github to your working directory Lamb-vxx</p>
</li>
<li><p class="startli">To run the demo, run this command: </p><div class="fragment"><div class="line">cd LambLispRT-vxx</div>
<div class="line">#Use &#39;native&#39; below on Linux, otherwise please check *platformio.ini* for all known hardware configurations.</div>
<div class="line">#The Linux executable binary will be in build/native/program</div>
<div class="line">pio -e native run</div>
<div class="line">#</div>
<div class="line">pio -e esp32-s3-devkitc-1 run --target uploadfs upload</div>
<div class="line">#The ESP32 binary will be in build/esp32-s3-devkitc-1/firmware.bin</div>
<div class="line">#</div>
</div><!-- fragment --><p> When LambLisp is started, it loads a file called <span class="tt">setup.scm</span> from the local file system. At a minimum, this file needs to contain a <em>Scheme</em> definition for the function <em>loop</em>. It must be a <em>Scheme</em> source code file, and must be located in the <em>current directory</em> where <em>LambLisp</em> is running. This is the <b>data</b> directory on embedded systems; on desktop OS it will be the "current directory" in which the LambLisp process started.</p>
</li>
</ul>
<p>To transfer control to <em>LambLisp</em> from C++, The C++ main program should initialize a LambLisp VM, look up the symbol <em>loop</em>, and request that <em>LambLisp</em> run it as a function.</p>
<p> </p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
What's in the repository?</h1>
<p>LambLisp is delivered as a finished executable, but more importantly, as a set of library library components that allow interoperability with embedded applications written in C++.</p>
<p>The root of the repository contains these files and directories: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File or Dir  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">platformio.ini  </td><td class="markdownTableBodyNone">Sample configurations for ESP32 and Linux  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">w3_pio  </td><td class="markdownTableBodyNone">Sample low-level board config files for platformio  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">README.md  </td><td class="markdownTableBodyNone">A mini-README containing pointers to the detailed documentation  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">LambLisp.pdf  </td><td class="markdownTableBodyNone">Detailed documentation in PDF form  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">html  </td><td class="markdownTableBodyNone">Detailed documentation in HTML form  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">src  </td><td class="markdownTableBodyNone">Sample main.cpp and sample device code  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">data  </td><td class="markdownTableBodyNone">Contains Settings.scm, setup.scm and other utilities  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">lib  </td><td class="markdownTableBodyNone">Contains:  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">- libLambLisp-xx.a - LambLispRT archive for each chip architecture  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">- source code - selected examples for extensibility  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">LambLisp-xx.bin  </td><td class="markdownTableBodyNone">Pre-built application binary for each supported chip architecture  </td></tr>
</table>
<p> </p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md19"></a>
Glossary</h1>
<ul>
<li><p class="startli">abstract machine</p>
</li>
</ul>
<p>The terms <em>abstract machine</em> and <em>virtual machine</em> are often used interchangeably, but there is a subtle difference. An <em>abstract machine</em> is a mathematics exercise; it is a set of elements, relations among the elements, and transformations between them. A <em>virtual machine</em> is an implementation of an abstract machine. When a VM runs, it behaves as defined by the abstract machine, although it runs on top of some other lower-level machine. That lower-level machine may itself be a software or hardware implementation of another abstract machine.</p>
<ul>
<li><p class="startli">association list, or alist</p>
</li>
</ul>
<p>A list of pairs. The first part of each pair is treated as a key, and the second part is treated as a value. The operations <em>set</em> and <em>get</em> are provided, to install new pairs or to retrieve existing pairs. Operations to <em>set</em> might either replace an existing pair, or add it if not already existing, or simply add the new pair to the front of the list, shadowing any matching pairs later in the list. Alists require linear search and so are used extensively where the lists are expected to be short, as they are in hash tables.</p>
<ul>
<li><p class="startli">atom</p>
</li>
</ul>
<p>A data item. Most often a simple data item such as a number or a string. Compound atoms, such as vectors, have their own set of operators to set &amp; get the internal parts.</p>
<ul>
<li><p class="startli">AST, or Abstract Syntax Tree</p>
</li>
</ul>
<p>A data structure created as output of analyzing source code. The AST is an internal representation of the source code elements and their relationships. The AST can be used to re-create the original source code it was created from, not counting white space. Creating the AST is the "front half" of a compiler.</p>
<ul>
<li><p class="startli"><em>car</em> and <em>cdr</em></p>
</li>
</ul>
<p>Refers to the first and second data word in a <a class="el" href="classCell.html">Cell</a>, respectively. Called <em>car</em> and <em>cdr</em> for historical reasons. In <em>LambLisp</em>, a <a class="el" href="classCell.html">Cell</a> consists of 3 sequential memory <em>words</em> (1 tag + 2 data), where a single <em>word</em> is large enough to hold a pointer or an integer, and 2 consecutive <em>words</em> are large enough to hold a real number.</p>
<p>In the 3-word <a class="el" href="classCell.html">Cell</a>, the first word is the <em>tag</em> word, the second word is the <em>car</em>, and the third word is the <em>cdr</em>.</p>
<p>The <em>tag</em> word contains a <a class="el" href="classCell.html">Cell</a> type indicator, and flags representing the garbage collection state of each cell.</p>
<p>Integers are stored in the <em>car</em> word. Real numbers are stored in the <em>car</em> word, and may possibly extend into the <em>cdr</em> word, depending on the underlying microprocessor. Some complex atoms, such as vectors, store a count in the <em>car</em> and a pointer in the <em>cdr</em>. Symbols store a hash in the <em>car</em>, and a pointer to the symbol identifier in the <em>cdr</em>.</p>
<ul>
<li><p class="startli"><a class="el" href="classCell.html">Cell</a></p>
</li>
</ul>
<p>A triplet of information: tag, first word (aka <em>car</em>), second word (aka <em>cdr</em>). In LambLisp, the three elements of the triplet are consecutive in memory, and are all the same size, large enough to hold a pointer or integer. The tag indicates how the first and second words are to be interpreted. When the tag indicates a <a class="el" href="classCell.html">Cell</a> is a <em>pair</em>, the <em>car</em> and <em>cdr</em> both point to other Cells (or possibly the same <a class="el" href="classCell.html">Cell</a>).</p>
<p>A <em>list</em> is formed when the <em>car</em> of a pair <a class="el" href="classCell.html">Cell</a> points to an S-expression (which is an item in the list), and the <em>cdr</em> of that <a class="el" href="classCell.html">Cell</a> points to another <em>pair</em> <a class="el" href="classCell.html">Cell</a>. That <em>pair</em> <a class="el" href="classCell.html">Cell</a> may also have a list item in its <em>car</em>. By convention, lists terminate with a special S-expression called <em>the empty list</em>, denoted '(), or NIL, or nil. NIL is considered a list (<em>the empty list</em>), but is not a pair, so it has no <em>car</em> or <em>cdr</em>.</p>
<p>Cells that are not pairs are called <em>atoms</em>. Atoms do not have any directly accesible internal structure, but may have operations that work on them, such as vector subscripting. Many atoms are simple integers, strings, or floating-point nunbers. The value of these atoms is contained within the <a class="el" href="classCell.html">Cell</a> in the <em>car</em> and/or <em>cdr</em> memory locations.</p>
<p>In LambLisp, there are several additional <em>pair</em> types that facilitate high performance in conjunction with the underlying LambLisp virtual machine. In standard Lisp or Scheme code, these would be considered atoms, but in LambLisp they are a bit of a hybrid, because <em>car</em>, <em>cdr</em>, <em>append</em>, and a few other list operations will work as expected.</p>
<ul>
<li><p class="startli">compiler, interpreter</p>
</li>
</ul>
<p>Both are language translators; in addition, an interpreter is also the language executor. There is a spectrum between compilers and interpreters, but we can identify a key difference: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Translator type  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>compiler</em>  </td><td class="markdownTableBodyNone">a software process that reads source code and produces new code to be executed later, possibly by a different machine.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em>interpreter</em>  </td><td class="markdownTableBodyNone">a software process that reads source code, performs some amount of processing, and executes the result immediately on the same machine.  </td></tr>
</table>
<p>In a compiler, and in any nontrivial interpreter, the sofware process first produces an Abstract Syntax Tree (AST). Creating the AST is the first half of the compilation process; in the second half, code is generated for later execution. An interpreter will create the AST and then traverse it, performing the operations as they are encountered.</p>
<p>In <em>Lisp</em>, code compiling is commonly done through the use of a <em>macro</em> facility. Macro expansion allows code to be transformed as it is read in, factoring out invariants, and producing new code with the invariants removed or calculated once. For example, replacing a symbol with its value "freezes" the symbol; subsequent uses of the symbol will be replaced with the frozen value whenever they are encountered. When that replacement is done at read time, the value is looked up once each time it encountered when reading and the value replaces the symbol. The runtime symbol-value lookup operation is eliminated.</p>
<p>This method of compilation, called <em>incremental compilation</em> or <em>just-in-time compilation</em>, blurs the line between compiler and interpreter.</p>
<ul>
<li><p class="startli">dictionary</p>
</li>
</ul>
<p>A <em>dictionary</em> is a data structure containing <span class="tt">(key value)</span> pairs. Pairs in the dictionary can be retrieved by matching a target <span class="tt">key</span> with the keys of each pair. Dictionaries also allow creating, updating, or deleting <span class="tt">(key value)</span> pairs.</p>
<p>A simple dictionary might be a list of <span class="tt">(key value)</span> pairs, requiring linear search. This is appropriate for small dictionaries, or short-lived dictionaries, where the construction overhead or runtime overhead of a faster solution outweighs any potential speed improvement.</p>
<p>For larger or long-lived dictionaries, intelligent key creation and caching when combined with hash tables makes this a very fast data structure upon which to operate.</p>
<p>What's described above is a <em>flat dictionary</em>, having a single layer of <span class="tt">(key value)</span> pairs.</p>
<ul>
<li><p class="startli">environments &amp; hierarchical dictionaries</p>
</li>
</ul>
<p>Often called the "symbol table" in other programming languages, in LambLisp the environment is a <em>hierarchical dictionary</em>. The <em>flat dictionary</em> described above provides a single <em>dictionary frame</em> for a <em>hierarchical dictionary</em>. A <em>hierarchical dictionary</em> is simply a list of flat dictionaries. The frame at the <em>car</em> of the list is a <em>child frame</em>, while frames in the <em>cdr</em> are called <em>parent frames</em> or <em>ancestor frames</em>.</p>
<p>The <em>hierarchical dictionary</em> provides a high-performing foundation for the LambLisp execution environment. It also provides a simple and natural foundation for the LambLisp Object System. Inheritance (including multiple inheritance) and shadowing are inherent behaviors of the <em>hierarchical dictionary</em>.</p>
<ul>
<li><p class="startli">evaluation</p>
</li>
</ul>
<p><em>Lisp</em> operates by reading symbolic expressions, evaluating them, and returning the result of evaluation. Atoms need no further evaluation, and evauating them just returns the atom itself. To evaluate a <em>list</em>, the item at the front of the list, i.e., the <em>car</em> of the list, is assumed to be a function to be <em>applied</em> to the remaining items in the list.</p>
<ul>
<li><p class="startli">hash function</p>
</li>
</ul>
<p>A function that takes a series of bytes as input, and produces a fixed-length number called a <em>hash</em>. When given a series of inputs, the hash function should give a series of outputs passing relevant test for randomness. It is not necessary that the series be truly random, only that the results be widely dispersed. For any given input, the output <em>hash</em> must always be the same. It can then be used as an index, replacing a search with an index lookup.</p>
<ul>
<li><p class="startli">hash table</p>
</li>
</ul>
<p>A data structure used for efficiently storing <span class="tt">(key value)</span> pairs). Commonly implemented as a set of operations employing a vector and a <em>hash function</em>. To search for an item by its key: </p><pre class="fragment">    - Obtain the hash of the key H, which may have been computed once and stored.
    - Obtain the size of the hash table N.
    - Compute the hash table index, which is (H % N), or (H &amp; (N-1)) if N is power of 2.
    - Search the (very short) alist at that index of the hash table.
</pre><ul>
<li><p class="startli">lambda calculus</p>
</li>
</ul>
<p>A branch of mathematics developed during the 1930's, where the elements of interest are functions rather than data values.</p>
<ul>
<li><p class="startli">lambda, nlambda, macro</p>
</li>
</ul>
<p>A <b>lambda</b> expression receives 2 arguments: a list of <em>formal parameters</em> and a list of <em>S-expressions</em> referred to as a <em>code body</em>. When executed, <em>lambda</em> returns a procedure, which is an encapsulation of the <em>formal parameters</em>, the <em>code body</em>, and the <em>environment</em> at the time of procedure creation.</p>
<p>An <b>nlambda</b> expression is the same as a <em>lambda</em>, except that at execution time its arguments are not evaluated before getting bound to the formal parameters.</p>
<p>Like <em>lambda</em> and <em>nlambda</em>, a <b>macro</b> definition requires a list of formal parameters and a code body. The behavior of a <em>macro</em> depends on whether it is encountered at <em>read time</em> or <em>evaluation time</em>.</p>
<p>When encountered at <em>read time</em> in the <em>operator position</em>, the macro arguments are bound to the macro's formal parameters unevaluated, the macro body is executed, the result replaces the original macro expression in the input stream.</p>
<p>When encountered at <em>evaluation time</em>, the macro body is executed as above, and the result is then evaluated.</p>
<ul>
<li><p class="startli">LISP</p>
</li>
</ul>
<p>A symbolic programming language developed about 1960. LISP (always uppercase in those days) offered a platform for reasoning, while then-existing languages focused more on numeric applications. The objects of interest in <em>LISP</em> are called <em>symbolic expressions</em> or <em>S-expressions</em>.</p>
<ul>
<li><p class="startli">list</p>
</li>
</ul>
<p>A <b>list</b> is data structure consisting of a backbone of Cells linked by their <em>cdrs</em>. The last <a class="el" href="classCell.html">Cell</a> in the list points to a special NIL <a class="el" href="classCell.html">Cell</a> to mark the end of the list. The <em>cars</em> of each <a class="el" href="classCell.html">Cell</a> in the list backbone point to the item that is in the list at that position. Note that every item in the list requires 2 entities: the item itself, and a <em>pair</em> <a class="el" href="classCell.html">Cell</a> that connects the item to the list backbone.</p>
<p>In <em>Lisp</em> source code, lists are represented between parenthesis, as in <span class="tt">(this is a list)</span>.</p>
<ul>
<li><p class="startli">NIL</p>
</li>
</ul>
<p>All <em>Lisps</em> have some version of NIL, nil, '(), otherwise called "the empty list". This is used to mark the end of a list. In some <em>Lisps</em>, it may also be considered to be equivalent to "false", or equivalent to zero, but not in <em>Scheme</em> or <em>LambLisp</em>.</p>
<ul>
<li><p class="startli">oblist</p>
</li>
</ul>
<p><em>Lisp</em> is a symbolic computing language and <em>symbol</em> is a first-class type. For best performance, LambLisp collects all the symbols encountered into an <em>interned symbol table</em>, for traditional reasons called the <em>obarray</em> or <em>oblist</em>. Symbol hashes are calulated on the symbol's identifier and then stored with the symbol in <em>oblist</em>. By this means symbols can be compared with a pointer comparison operation; 2 symbols are the same if they point to the same entry in the oblist. In LambLisp, the oblist is neither an array nor a list; instead it is a hash table, but the <em>oblist</em> name is retained.</p>
<ul>
<li><p class="startli">pair</p>
</li>
</ul>
<p>A <a class="el" href="classCell.html">Cell</a> whose purpose is to connect 2 other cells. In a typical <em>Lisp</em> tree structure, <em>pair</em> Cells will make up half of the Cells used, while the leaves of the tree will be atoms.</p>
<ul>
<li><p class="startli">prefix, infix, postfix</p>
</li>
</ul>
<p>In typical algebra notation, to compose two functions <em>f</em> and <em>g</em> that each require a single parameter <em>x</em> we write: </p><div class="fragment"><div class="line">f(g(x))</div>
</div><!-- fragment --><p>The functions are composed using <em>prefix</em> notation. Algebra and C/C++ use a mix of parenthesis, prefix, infix, and postfix notation like this: </p><div class="fragment"><div class="line">--x + abs(x) + 2 + (x++ - y[z])</div>
</div><!-- fragment --><p>Lambda calculus uses prefix notation and makes frequent use of the greek symbol lambda (<img src="lambda.png" alt="" class="inline" title="The Greek Symbol Lambda"/>     ), which is not conducive to keyboard use. Instead <em>Lisp</em> spells out <em>lambda</em> when required.</p>
<p>Lisp (like lambda calculus) uses prefix notation, with parenthesis and symbols being the fundamental lexical elements. To compose functions <em>f</em> and <em>g</em>, we write: </p><div class="fragment"><div class="line">(f (g x))</div>
</div><!-- fragment --><p>and to compare 2 elements <em>x</em> and <em>y</em>, there is the eq? operator: </p><div class="fragment"><div class="line">(eq? x y)</div>
</div><!-- fragment --><p>To summarize prefix/infix/postfix, using C++ examples:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Notation  </th><th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Prefix  </td><td class="markdownTableBodyNone">++x  </td><td class="markdownTableBodyNone">f(x)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Infix  </td><td class="markdownTableBodyNone">a * b  </td><td class="markdownTableBodyNone">a + b &amp; c  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Postfix  </td><td class="markdownTableBodyNone">y++  </td><td class="markdownTableBodyNone">y-&gt;foo  </td></tr>
</table>
<ul>
<li><p class="startli">symbolic expression</p>
</li>
</ul>
<p>In its simplest implementations, a <em>Lisp</em> <b>symbol</b> is any sequence of characters not containing spaces or parenthesis. Some of these symbols sequences are defined by the language (<span class="tt">if</span>, <span class="tt">lambda</span>, and so on), along with a value for those symbols, but others are just symbols, to which a value may be attached. These are all symbolic expressions, or <b>S-expressions</b>, and combinations of S-expressions and balanced sets of parenthesis are also valid S-expressions.</p>
<p>The basic <em>Lisp</em> language can only test for equality of symbols, but real-world <em>Lisps</em> define useful data types like numbers and strings, along with operations on those.</p>
<p>The LambLisp implementation depends on a <span class="tt"><a class="el" href="classCell.html">Cell</a></span> structure to contain the details of an <b>atomic</b> S-expression (such an as integer), or the links between S-expressions (as in a list). When programming LambLisp at the C++ level, an <em>S-expression</em> is therefore a pointer to a <a class="el" href="classCell.html">Cell</a>.</p>
<p> </p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
LambLisp Architecture Internals</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
The <em>dictionary</em> type</h2>
<p>In computer science, a <em>dictionary</em> is a data structure and set of operations operations for managing <span class="tt">(key value)</span> pairs.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LambLisp function  </th><th class="markdownTableHeadNone">Dictionary operations  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dict-set!  </td><td class="markdownTableBodyNone">install or replace a <span class="tt">(key value)</span> pair  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dict-ref?  </td><td class="markdownTableBodyNone">return a <span class="tt">(key value)</span> pair based on its key  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dict-ref  </td><td class="markdownTableBodyNone">return a value based on its key  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dict-rm!  </td><td class="markdownTableBodyNone">delete a <span class="tt">(key value)</span> pair  </td></tr>
</table>
<p>The name <em>dictionary</em> applies to the features and functions performed, and not to any particular implementation. A sequential search or a database query are both useful implementations of a dictionary for different purposes, with different performance expectations.</p>
<p>LambLisp uses several advanced techniques to ensure high performance dictionaries in embedded control.</p>
<p>Large or long-lived dictionaries are implemented as <em>hash tables</em>. When a dictionary is large or long-lived, great performance gains can be obtained by distributing the <span class="tt">(key value)</span> pairs throughout an array. To perform a lookup, compute a <em>hash value</em> for the key, and use that as an array index. The <span class="tt">(key value)</span> pair, if present, will be in the list of items at that index. The hash function, used to create a hash value from a <span class="tt">key</span>, produces a fixed-length number from the contents of the key. The output of the hash function must be the same whenever the same key is presented as input. The hash values produced should be widely distributed among the hash table indexes.</p>
<p>Small dictionaries are implemented as association lists, or <b>alists</b>. When a dictionary is small or short-lived, the one-time cost of creating a hash table is unjustified.</p>
<p>In hashed dictionaries, at each element of the hashed array there is a (very short) <em>alist</em>, so <em>alist lookup</em> is a foundational operation and should be as fast as possible.</p>
<p><em>LambLisp</em> optimizes symbol lookup by computing hash values once when a symbol is created, and storing the hash value with the symbol. The most common symbol operation (test for equality of symbols) reduces to a fast pointer comparison when using a dictionary.</p>
<p>The dictionary type described above is a <em>flat dictionary</em>. That is, there is just one vector, and a <span class="tt">(key value)</span> pair is either present or not.</p>
<p> </p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
Hierarchical dictionaries</h2>
<p>LambLisp implements <em>hierarchical dictionaries</em>. A LambLisp <em>hierarchical dictionary</em> consists of a list of <em>frames</em>, where each frame is a <em>flat dictionary</em>. Hereafter, any reference to <em>dictionaries</em> should be understood to refer to LambLisp <em>hierarchical dictionaries</em>. In cases where a <em>flat dictionary</em> is required, it will be called out specifically.</p>
<p>The fundamental operation in a dictionary is <b>lookup</b>. A <em>lookup</em> must be done to support every other dictionary operation: create, modify, delete etc. The <em>lookup</em> operation consists of providing a key K, and querying the dictionary for a <span class="tt">(key value)</span> pair having a key matching the key K provided.</p>
<p>When performing a dictionary lookup, each frame is checked in turn for a matching key. If a key is not present in the top frame of the dictionary, it may be present in succeeding (parent) frames. The <em>dictionary</em> is a first-class type in LambLisp, available to the Lisp application.</p>
<p>The dictionary type is a fairly general purpose data structure. Keys and values may be any type. Each frame may be an alist or vector, with the choice made on frame size and expected lifetime. Symbol keys are computed once and stored with the symbol, speeding up dictionary operations where the keys are symbols (as in environments and commonly as in object member identifiers).</p>
<p>The primary method of creating dictionaries is with the function <span class="tt">alist-&gt;dict</span>, which traverses an association list and returns a dictionary. The <span class="tt">(key value)</span> pairs of the alist are distributed into a hash table, which becomes a frame in the dictionary. It is also possible to specify a parent dictionary when creating a dictionary, or NIL if there is no parent (as in a <em>flat dictionary</em>). Because dictionaries are lists (of frames), they can be appended or examined with <em>car</em> and <em>cdr</em>, just as with other lists.</p>
<p>In addition to being available in the <em>Lisp</em> application, <em>hierarchical dictionaries</em> are central to several other aspects of LambLisp.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
Execution environment is a <em>hierarchical dictionary</em></h2>
<p>The execution environment is a hierachical dictionary. In the <em>Scheme</em> specification, there are 2 environments mentioned, the <em>syntactic environment</em> and the <em>interaction environment</em>. The syntactic environment contains all those definitions that are found in the the <em>Scheme</em> specification. The other is called the <em>interaction environment</em>. This where application definitions are stored.</p>
<p>In LambLisp, the execution environment (which is a dictionary) is initialized with 2 frames. The base frame consists of the <em>syntactic environment</em> described in the <em>Scheme</em> spec, and the second (top) frame is the <em>interaction environment</em> also described there. Top-level definitions are installed the interaction environment.</p>
<p>When a function is called, its formal parameters are paired with the asscociated runtime values, and that set of pairs is added as a new frame on top of the current execution environment. This naturally and elegantly implements lexical scoping.</p>
<p> </p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md24"></a>
Objects are wrappers around <em>hierarchical dictionaries</em></h2>
<p>Hierachical dictionaries also form the basis for LampLisp's Object System (LOBS). Just as the dictionary presents an efficient model for the execution environment, is also provides an excellent base for an object-based appoach.</p>
<p>In the object view each frame in a dictionary represents an instance of a class, while the parent frames in the dictionary represent the parent object instance. This leads naturally to inheritance behavior, including multiple inheritance.</p>
<p>Ine the LambLisp Object System, there is no need to separate class definition from class instantiation. An association list is used to create a new dictionary, and the same alist can be used to produce new instances. In effect, the alist <em>is</em> the class definition.</p>
<p>This leads to some interesting freedoms as compared with the C++ or Python approach to class definition and instantiation.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LOBS features  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Objects are created from an association list and (optionally) parent objects.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Objects inherit from their parent objects.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Multiple objects may inherit from the same parent object.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Objects may initialize from the same alist, but have different parent objects.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Objects may initialize from different alists, but may share a common parent object.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Objects may have new fields added/deleted any time, as any other dictionary.  </td></tr>
</table>
<p>To use LOBS as a C++-style object system, do the following:</p><ol type="1">
<li><p class="startli">Initialize all objects of the same type from the same association list.</p>
</li>
<li><p class="startli">Create and initialize new parent objects for each new child object.</p>
</li>
</ol>
<p>To round out the object model, LambLisp provides <span class="tt">dict-&gt;obj</span>. You have correctly perceived that this will convert a dictionary into an "object". This provides a minimal object-style accessor for a dictionary, such that <span class="tt">(some-object 'foo)</span> will return the value of the field <span class="tt">foo</span> in the object <span class="tt">some-object</span>. and <span class="tt">(some-object 'foo 42)</span> will set the corresponding field on <span class="tt">some-object</span>.</p>
<p>The simple <em>set/get</em> object model suffices for many case. It is possible to add more complex behaviors by assigning procedues to dictionary values, and/or by enclosing dictionaries in a wrapper procedure.</p>
<p> </p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md25"></a>
Interpreter &amp; compiler organization</h2>
<p>Language implementations depend on <em>primitives</em>; these are the language elements that are assumed to exist when a programmer is programming in that language. For a high-level language, the <em>if-then-else</em> sequence is a common language primitive.</p>
<p>Low-level languages, such as assembly language, also have a set of primitives. Each primitive does less work when used, but by coding directly in assembly language optimization can be implemented that cannot at the higher level, and the result can be many times faster than a higher-level language. At some level, even a compiled high-level language is still interpreting a lower-level machine.</p>
<p>Many available Lisp implementations are based on underlying <em>abstract machines</em>. These mathematic constructs were developed in the 1990s as part of the emergence of the <em>Lisp machine industry</em>. Two of the most important abstract machines to emerge were the <b>SECD machine</b> and the <b>CEK machine</b>. <em>TinyScheme</em>, for example, uses an <em>SECD machine</em> as its execution target.</p>
<p>LambLisp's implements interpretation of Lisp at a high level; each of the functions in the <em>Scheme RxRS</em> specifications is implemented in C++. They all share the same C++ signature:</p>
<p><span class="tt">Sexpr_t any_function(<a class="el" href="classLamb.html">Lamb</a> &amp;lamb, Sexpr_t sexpr, Sexpr_t env_exec)</span></p>
<p>The <span class="tt">lamb</span> parameter is the <a class="el" href="classLamb.html">Lamb</a> virtual machine instance which is to execute the operation. The parameters <span class="tt">sexpr</span> is the <em>symbolic expression</em> to be operated upon by the function, and <span class="tt">env_exec</span> is the environment in which to execute the function. The return type is a also a <em>symbolic expression</em>. Note that <span class="tt">env_exec</span> is known to be a dictionary, and that its keys are all symbols.</p>
<p>This organization has several implications.</p>
<p>First, the language primitives are coded directly in C++, rather than interpreted at run time through a lower-level bytecode system. This makes compilation of the language primitives easy; simply replace the symbol with its value at read time, using a macro facility.</p>
<p>Second, the <em>Scheme</em> specification describes only a small set of primitives, with much of the language being "derived expressions". These derived expressions are not language primitives, but instead they either get expanded once at read time, or interpreted at run time. Their performance depends entirely on the expanded versions.</p>
<p>In the highest-performing cases, macros expand into machine code, utilizing the CPU registers directly to carry out <em>Lisp</em> operations. That high performance comes with costs. In an embedded system, that type of compiler would be included onboard, taking up space even though used only occasionally. Alternatively, an offboard compiler could be used. That makes some features difficult to implement, such as on-the-fly incremental code updates.</p>
<p>The derived expressions in the <em>Scheme</em> specification form a "compiler" that transforms <em>Scheme</em> source code into expanded code that relies on relatively few low-level primitives. Some of those lower-level primitives, such as <em>if</em>, <em>define</em>, and <em>set!</em>, are fundamental to the application of <em>lambda calculus</em> to computing, while other (such as mathematical functions) are necessary to solve practical problems.</p>
<p>The simple compiler has a disadvantage: the code it generates is simpler to execute than the source, but not simple enough to be fast unless it is designed to produce assembly-level native code. For example, an expansion of <span class="tt">cond</span> results in many sequential <span class="tt">if</span> functions to be executed. In an optimizing compiler, a series of low-level test-and-jump sequences will be coded inline, one for each <span class="tt">if</span>. This will be very fast.</p>
<p>Short of that, executing <span class="tt">cond</span> requires a pass through the main loop for each test clause. A system that expanded <span class="tt">cond</span>, but required sequential execution of <span class="tt">if</span> (in the <em>Lisp</em> context), would relatively slower.</p>
<p><em>LambLisp</em> has implemented nearly all the <em>Scheme</em> language elements as primitives, written in C++. This reduces the number of steps to be interpreted between source code intake, transformation in to an <em>abstract syntax tree</em> (AST), and its execution in C++. In the deign of <em>LambLisp</em>, a <span class="tt">cond</span> in <em>Lisp</em> source code correspond directly to a C++ function <span class="tt">cond(...)</span>. Encountering <span class="tt">cond</span> in an expression does not result in a chain of small bits of <span class="tt">if</span> execution. Instead, the C++ <span class="tt">cond</span> is called, either after its symbol is resolved in interpreted mode, or called diretly through a pointer in compiled mode. All the clauses of the <span class="tt">cond</span> are executed in a loop at C++ speed, and not in a loop at the <em>Lisp</em>-language level or in a bytecode interpreter.</p>
<p>When compiling LambLisp, an immediate performance improvement is realized by replacing symbols in the input (define, if, let, etc) with their values. The downside is that debugging information is unavailable when exceptions occur, most importantly the symbols associated with functions.</p>
<div class="image">
<img src="LambLisp_ImplementationPerformance.png" alt=""/>
<div class="caption">
Performance Characteristics of Several Implementation Strategies</div></div>
    <p>The compilation process begins by reading the source code and creating an <em>Abstract Syntax Tree</em> (AST). The AST is an internal representation of the program, with element of the source code being an element of the AST.</p>
<p>To represent the AST, <em>LambLisp</em> uses a "direct-connect" technique, in which high-level Lisp operations (implemented in C++) are executed through pointers directly embedded into Lisp objects. These objects correspond directly to high-level features in the language specification (define, lambda, etc). All of the LambLisp language primitives are implemented this way, and it is possible to add additional LambLisp functions implemented in C++. They are treated as any other first-class function.</p>
<p>As illustrated above and below, this architecture can provide high performance while remaining compact. The axis labeled "Complexity" is a proxy for "how much code transformation is performed?", and shows that there is not a simple choice of "compile or interpret", but a spectrum of solutions that begin with the simplest interpeter and ends with a compiler optimized for a particular CPU. Everything in between is "on the spectrum".</p>
<p>A compiler whose target is the hardware native machine registers will be fastest. The interesting thing to note is that bytecode interpreters can be outperformed by AST interpreters. The reason is that bytecode interpreters do only a small amount of work in the interpreter implementation language, for each pass through the loop while interpreting the implemented target language. A high-level AST interpreter does more work for each pass though the eval loop, as compared with a bytecode interpreter, and those larger chunks of work are done at C++ speed.</p>
<div class="image">
<img src="LambLisp_ImplementationMemoryReq.png" alt=""/>
<div class="caption">
Memory Requirements of Several Implementation Strategies</div></div>
    <p>Similarly, there is a relation between runtime memory requirements and position on the compile/interpret spectrum. Because individual bytecodes represent a small amount of computation, more of them are required to represent the original code. The AST representation is small, while retaining all the relationships embodied in the source.</p>
<p>Because <em>LambLisp</em>'s AST implementation is high-level and congruent to the features described in the specification, the "bytecode equivalents" used by <em>LambLisp</em> correspond exactly to specified features.</p>
<p>During compilation, the AST nodes representing language primitives implemented in C++ are replaced with AST nodes of the same size pointing directly to the C++ feature implementation. This compilation feature allows faster execution with no additional space overhead, because the C++ code reference is the same size as the original signal it replaces. The downside is that, should exceptions occur, the debugging iformation is more obscure, with human-readable code symbols replaced by addresses.</p>
<p>The compilation system is based on <em>nlambda</em> and <em>macro</em> primitives.</p>
<p> </p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
LambLisp Virtual Machine</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
Control Applications as Virtual Machines.</h3>
<p>It will help us to think of the running application as a layers of virtual machines. In fact, there is a stack of virtual machines, starting at the bottom with single transistor, and finishing at the top with whatever runtime inputrs the system is designed to respond to.</p>
<p>Those inputs themselves arrive from another, external virtual machine, which has its own internal organization and its own set of inputs, computation, and outputs.</p>
<p>It is also useful to identify the boundary between the <em>hardware virtual machines</em> and <em>software virtual machines</em>. The illustration below shows a few layers representing the virtual machines involved.</p>
<div class="image">
<img src="LambLisp_CPU_as_VM.png" alt=""/>
<div class="caption">
A CPU shown as a stack of Virtual Machines</div></div>
    <p>The item labeled "Programs" above is its own virtual machine, consisting of multiple software layers. The layers below that are typically considered "hardware".</p>
<p>At the bottom is the very lowest virtual machine - a field effect transistor. These are operated such that the gate either allows or blocks electron flow through the substrate. When we ascribe meaning to the flow (either a 1 or a 0), the physical flows become meaningful symbols that people can use to communicate.</p>
<p>Transistors are assembled into several types of micro-machines that, when used together, become what we recognize as a "CPU". Symbols of additional complexity are created at every level: numbers, sums and products of numbers, comparison of numbers, interpreting numbers as instructions, etc.</p>
<div class="image">
<img src="LambLisp_AppStack.png" alt=""/>
<div class="caption">
Typical Control Application Organization</div></div>
    <p>The illustration above shows a typical control application breakdown. In this view, the code entities form a set with a <em>partial ordering</em> relationship, so any of the code entities in the diagram can rely on any of the other entities at an equal or lower level. They can also rely on any entity to the left.</p>
<p>In many loop-based control applications, there are a also few exceptional dependencies, whereby an entity may call another to its right or above. These often occur at system startup. For example, if there is one entity TIME that is responsible for knowing the time, it should not fail under any circumstances, even of not initialized and is unsure of the time. It must provide an answer of some kind.</p>
<p>Another example is when several different types of measurements are required to meet thresholds before the next process step can proceed. These measurements are often averaged over time, and a simultaneous value is required for all them to ensure process synchronization. Each software entity may have some work to do at synchronization time. Each may query the application control layer to obtain formation about the larger environment it is operating in, such as whether the current loop is the synchronization loop, and adapt its behavior as needed.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md28"></a>
LambLisp Block Diagram</h3>
<div class="image">
<img src="LambLisp_BlockDiagram.png" alt=""/>
<div class="caption">
LambLisp Block Diagram</div></div>
    <p>When source code is read in, the <em>reader</em> front end of the interpreter tokenizes the text, parses the the resulting code, and constructs an <em>abstract syntax tree (AST)</em>. The AST is the executable version of the code, an ordered collection containing all the parts and their relationships. Because the resulting executable is a series of direct links, the AST can be traversed rapidly without a lookup table, and because the tree end nodes are high-level functions (rather than low-level bytecodes), the result is a fast interpreter.</p>
<p>Once the interpreter is available, and correctly executes the AST, the macro facility of <em>Lisp</em> is used to transform high-level nodes in the AST into a collection of lower-level nodes that perform the same computation. In a simple <em>Lisp</em>, consisting only of <em>if, eq? define, lambda, set! and cons</em>, every correct program will be factored into those primitives.</p>
<p>When macros are expanded at <em>read time</em>, then the effect is one of incremental compilation. After each macro is expanded in to a series of pointers to native C++ code, the result is a compiled program consisting of a tree of native code pointers to be traversed. In addition to allowing for faster execution, this tree-structured architecture is what allows <em>Lisp</em> programs to be modified on-the-fly.</p>
<p>One clear example of the performance advantage is in the <em>Scheme cond</em> function, which acts as a sequential if-then-elseif. Using the minimal set of primitives, <em>cond</em> would expand into a series of <em>if</em> functions, each of which would need to be processed by the <em>Lisp</em> eval loop. In <em>LambLisp</em>, <em>cond</em> is a primitve implemented in C++, and does not require its own set of passes through the <em>eval loop</em> of <em>Lisp</em>. This provides improved performance.</p>
<p> </p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md29"></a>
Memory Management</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md30"></a>
Overview</h3>
<p>Memory reuse was recognized as a challenge right from the early days of programmable computers. Most computational results are intermediate; once calculated, they are quickly combined with other results and no longer required. <em>Garbage collection</em> is the pejorative term for activities related to the identification and reclamation of unused memory. Every programming language must have a strategy for reusing the memory space that no longer holds useful results.</p>
<p>There are 4 main ways to allocate memory: 1) static allocation, 2) stack allocation, 3) heap allocation, and 4) "manually".</p>
<p>Static allocation is done once before the program starts. The memory remains available for use by the application for the life of the program. If this memory is to be used for multiple purposes, the processes involved in reuse must be done "manually" by the running application.</p>
<p>Stack allocation is what C programmers experience as "local variables". When a function is called, a new block is allocated from the top of the execution stack. These blocks are interwoven with the return address of the calling functions. When a function returns, the local storage block is popped off and the calling function's context is now at top of stack. In embedded control systems, the available stack space is usually small, often just 4k or 8k bytes.</p>
<p>The memory not allocated statically or to the stack is referred to as the "heap". C and C++ programmers must manage this space manually, using the alloc()/free() or new/delete functions, and employ bespoke tracking mechanisms to discriminate used space from unused.</p>
<p>Many other languages allocates large blocks from the heap, and manage the interior allocation of those blocks according to the requirements of the language. Among these languages are Python, Java, JavaScript, Lua, and of course Lisp.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md31"></a>
Cell Memory Model and List Structures</h3>
<p>At the lowest level, LambLisp depends on a <em>cell</em> structure in 3 consecutive words of computer memory. There are several assumptions about the computer words:</p><ul>
<li><p class="startli">each word consists of multiple bytes, and the bytes are individually addressable</p>
</li>
<li><p class="startli">each word is capable of holding an address</p>
</li>
<li><p class="startli">each word is capable of holding a signed integer of useful size</p>
</li>
<li><p class="startli">2 consecutive words of memory may be used to hold a floating-point value.</p>
</li>
</ul>
<p>Of the 3 words in a <a class="el" href="classCell.html">Cell</a>, the first word is called the <em>tag</em> and contains information about the cell, such as the cell type and its garbage collection state. If the tag indicates that the cell is a pair type, then the Lisp <em>car</em> and <em>cdr</em> are represented in the following 2 words of the cell. If the tag indicates an atom (such as a symbol, integer, string etc), then the remaining parts of the <a class="el" href="classCell.html">Cell</a> are used to encode the details of the atom.</p>
<p>Nearly all <em>Lisp</em> implementations use this <em>tagged</em> arrangement, sometimes with variations such as putting the tag, <em>car</em>, and <em>cdr</em> in separate parallel arrays, or storing some of the tag bits in unused bits of the <em>car</em> and <em>cdr</em> fields. These variations are generally not useful on today's microprocessors for 2 reasons: 1) Data structure fields are aligned on word boundaries by the C++ compiler. Defeating this feature results in reduced performance. 2) Separate, parallel arrays will reduce the efficiency of microprocessor's onboard cache.</p>
<p>Instead of a barrier, these features provide a new opportunity for embedded real-time control with <em>LambLisp</em>.</p>
<p>First, <em>LambLisp</em> devotes an entire byte for type codes. At present only 5 of the 8 type bits are used. It has proven beneficial to performance to add new types that correspond to the objects handled by the <em>LambLisp</em> interpreter. For example, the tail recursion implementation results in many <em>thunks</em>, packaged bits of code with an environment to run in, that should be executed to obtain a final result. As it turns out, there are 2 kinds of thunks: a single S-expressions, or a list of S-expressions. Once freed from the imperative to reduce the number of types, adding just a few types provides immense leverage in the <em>LambLisp</em> Virtual Machine. Also, using the entire byte means no mask is required, speeding up the very common operation of type-testing.</p>
<p>Second, <em>LambLisp</em> devotes the second byte to <a class="el" href="classCell.html">Cell</a> state information. Garbage collection relies on a state-based assessment of each <a class="el" href="classCell.html">Cell</a>, and cells have 5 GC states, requiring 3 bits. That leaves 5 bits unused, as well as 3 additional unused values for the GC state. These are available for debugging purposes.</p>
<p>Third, in word 0 of each <a class="el" href="classCell.html">Cell</a> bytes 2 and 3 are not required for the tag. In LambLisp, these are used to store <em>immediate</em> types, such as T_STR_IMM and T_BVEC_IMM. Using these types for short strings or byte vectors eliminates the need for heap operations. These can be especially useful for small-packet interactions with onboard devices via SPI or I2C.</p>
<div class="image">
<img src="LambLisp_CellStructure.png" alt=""/>
<div class="caption">
LambLisp VM Cell Structure</div></div>
    <p>At the <em>Lisp</em> level, only the <em>car</em> and <em>cdr</em> are visible; the tag word is not directly available. However, the <em>Lisp</em> language provides <em>predicates</em> for identifying the type of an S-expression, either a pair (using the <em>pair?</em> predicate), or a type of atom (using predicates <em>integer?</em>, <em>real?</em>, etc). This pattern is encouraged in applications programs, where new data types may be created and predicates provide confirmation of an object's type.</p>
<p>The following illustrates an example of a list structure constructed from the cells decsribed above:</p>
<div class="image">
<img src="LambLisp_ListStructure.png" alt=""/>
<div class="caption">
Typical List Structure</div></div>
    <p> </p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md32"></a>
Garbage Collection</h3>
<p>The literature on garbage collection is broad and deep, with several important behavioral features identified among the various possible algorithms, primarily:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Garbage collector distinguishing features  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">copying vs. not copying  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">compacting vs. not compacting  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">support for circular structures  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">need for auxiliary memory during GC  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">need for computational pause during GC  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">average throughput vs. peak pause time  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">concurrent access to shared memory  </td></tr>
</table>
<p>In a real-time control system, the discriminating factor for implementing a garbage collector is that it can perform its function incrementally. Time spent on GC is time spent not actively monitoring the controlled process. LambLisp implements a tunable control parameter (the <em>GC time quantum</em>), that limits the time spent on each GC increment, ensuring that the cell allocator will not become starved of free cells.</p>
<p>LambLisp's memory reuse strategy relies on these key papers:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key GC Papers  </th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Knuth 1963  </td><td class="markdownTableBodyNone">In "The Art of Programming", Algorithm 2.3.5b describes the fundamental GC stack-based marking strategy  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Dijkstra 1976  </td><td class="markdownTableBodyNone">Describes the "tricolor abstraction" and proves the correctness of incremental garbage collection  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Yuasa 1990  </td><td class="markdownTableBodyNone">Provides a method for determining optimum memory size and free reserve during incremental GC  </td></tr>
</table>
<p>LambLisp implements the stack-based idle-mark-sweep garbage collection cycle described by Knuth, the tri-color abstraction described by Dijkstra, and actively adapts GC performance based on analysis of the kind described by Yuasa.</p>
<p>Yuasa developed 2 parameters, M (GC start threshold), and N (minimum required cell population). The garbage collector begins in the <em>idle</em> state. <em>Marking</em> begins when the free cell reserve falls below the GC start threshold, and proceeds incrementally. When marking is complete, the <em>sweep</em> phase is begun and also proceeds incrementally. Each increment is less than or equal to the configured GC time quantum. Once sweeping has finished, the GC state is <em>idle</em> again until the next M threshold is reached.</p>
<div class="image">
<img src="LambLisp_GC_Cycle.png" alt=""/>
<div class="caption">
LambLisp VM Cell Life Cycle</div></div>
    <p>The GC strategy followed by LambLisp is roughly as follows:</p><ul>
<li><p class="startli">Each cell produced must be matched by an incremental amount of GC, and on the average, that GC must free up at least one cell per cons.</p>
</li>
<li><p class="startli">LambLisp performs an incremental GC pass at <span class="tt">cons</span> time.</p>
</li>
<li><p class="startli">LambLisp measures the time required for mark and sweep operations.</p>
</li>
<li><p class="startli">The system provides a tunable parameter, the <em>GC time quantum</em>, which is the number of microseconds allocated to garbage collection at <span class="tt">cons</span> time.</p>
</li>
<li><p class="startli">The time quantum is converted into mark and sweep quanta, which are the number of cells that can be marked/swept in the configured time quantum. The numeric quanta have a minimum value of 2.</p>
</li>
<li><p class="startli">The Yuasa parameters are recomputed at the end of every sweep. The parameter M (minimum free cell reserve) is continuously adjusted as required, and the parameter N (minimum required number of cells) is also checked; if N is greater than the available memory then more memory is requested from the system heap.</p>
</li>
</ul>
<p> </p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md33"></a>
Scalability</h2>
<p>Scalability is a matrix; one axis is simply "scale up or down". Another axis consists of discrete modes or techniques for scaling. LambLisp has several modes of scaling up and down.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md34"></a>
Scaling up by adding new fundamental features</h3>
<p>LambLisp has a clean, simple interface to C++ code. All the LambLisp native functions have the same signature. As part of the control application, additional native features can be added and will run at full C++ speed. These C++ additions may be useful in several circumstances:</p><ul>
<li><p class="startli">Implement a low-level hardware abstraction and make it available to Lisp.</p>
</li>
<li><p class="startli">Provide a Lisp interface to a specialized computation library.</p>
</li>
<li><p class="startli">Improve performance at key algorithmic bottlenecks.</p>
</li>
</ul>
<p>For example, LambLisp implements the <em>digitalWrite</em> function this way:</p>
<div class="fragment"><div class="line">Sexpr_t mop3_hal_digitalWrite(<a class="code hl_class" href="classLamb.html">Lamb</a> &amp;lamb, Sexpr_t sexpr, Sexpr_t env_stack)</div>
<div class="line">{</div>
<div class="line">  Sexpr_t sx_pin = lamb.car(sexpr);                     <span class="comment">//Get the pin # in S-expression form</span></div>
<div class="line">  Sexpr_t val    = lamb.cadr(sexpr);            <span class="comment">//Get the value in S-expression form</span></div>
<div class="line">  Int_t pin      = sx_pin-&gt;<a class="code hl_function" href="classCell.html#ad652ff1276570beb205c7805ee647b4f">mustbe_Int_t</a>();      <span class="comment">//throw error if an INT not provided</span></div>
<div class="line">  </div>
<div class="line">  digitalWrite(pin, val != HASHF);                      <span class="comment">//in Scheme, any value &quot;not false&quot; is &quot;true&quot;</span></div>
<div class="line">  <span class="keywordflow">return</span> val;                                                           <span class="comment">//return whatever value the pin was set to</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassCell_html_ad652ff1276570beb205c7805ee647b4f"><div class="ttname"><a href="classCell.html#ad652ff1276570beb205c7805ee647b4f">Cell::mustbe_Int_t</a></div><div class="ttdeci">Int_t mustbe_Int_t()</div><div class="ttdoc">Return the value of this cell as an integer.</div><div class="ttdef"><b>Definition</b> LambLisp.h:397</div></div>
<div class="ttc" id="aclassLamb_html"><div class="ttname"><a href="classLamb.html">Lamb</a></div><div class="ttdef"><b>Definition</b> LambLisp.h:651</div></div>
</div><!-- fragment --><p> To use this C++ function from within LambLisp to set pin 38 HIGH and then LOW: </p><div class="fragment"><div class="line">(digitalWrite 38 #t)</div>
<div class="line">(digitalWrite 38 #f)</div>
</div><!-- fragment --> <h3 class="doxsection"><a class="anchor" id="autotoc_md35"></a>
Scaling down by removing unneeded functions</h3>
<p>At build time, LambLisp allows fine-grained control of the system functions that are included in the application image.</p>
<p>For example, LambLisp supports all the math functions described in the <em>Scheme RxRS</em> specifications, and by default all are included in the build. Functions that are not needed can be commented out in the source code and will not be linked into the control application.</p>
<p>This same approach can be used for other groups of function, such as ports and strings. These groups of functions are completely defined in the spec to provide a full solution in their respective domains, but in practice each application uses only a subset of the available capability.</p>
<p>As another example, few embedded control applications will need the full set of case-independent string operators, and they are easy to add in Lisp later if needed, These functions are candidates for implementation in Lisp and loading at runtime, rather than including them in every binary application image.</p>
<p>This scalability feature provides a means to reduce the application size.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md36"></a>
Scaling up or down by controlling memory allocation.</h3>
<p>LambLisp has an adaptable real-time garbage collection implementation that can be scaled in several ways. At every <em>cons</em> operation, the GC has an opportunity to run, and may mark or sweep cells at that time.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">GC parameter  </th><th class="markdownTableHeadNone">Function  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GC time quantum  </td><td class="markdownTableBodyNone">Amount of time to spend on GC for each cons  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classCell.html">Cell</a> block size  </td><td class="markdownTableBodyNone"># cells per block  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Max cell blocks  </td><td class="markdownTableBodyNone">maximum # of blocks to allocate  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GC % threshold  </td><td class="markdownTableBodyNone">Increase memory until threshold reached (or max)  </td></tr>
</table>
<p>The GC time quantum determines how many mark or sweep operations to do during each increment. A smaller number results in shorter GC interruptions, but lower total throughput.</p>
<p>The cell block size is not critical, but the minimum system setup needs 4k cells, and so 8k is a natural default for this parameter, allowing space for a useful <em>Lisp</em> application.</p>
<p>The maximum number of cell blocks can be chosen to tune the amount of time spent in GC. The amount of time spent marking depends on the number of cells used by the <em>LambLisp</em> program, and not the total number of cells available. Conversely, when sweeping, the entire cell population must be swept.</p>
<p>With more cells in the population, more cells are swept and reclaimed with each GC mark/sweep cycle, because the fixed cost of marking the used cells is amortized over the entire cell population. More memory results in less time spent in garbage collection, but with diminishing returns as more memory is added with constant program size.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md37"></a>
LambLisp Adaptive Tuning</h3>
<p>LambLisp implements several adaptive tuning mechanisms in the GC implementation.</p>
<p>First, <em>LambLisp</em> provides an incremental garbage collector, based on the work of Taichi Tuasa. This eliminates extended pauses for garbage collection. Yuasa began with a stack-based, mark &amp; sweep, stop-the-world garbage collector, and transformed it into an incremental adaptation. In the incremental version, each time a new memory cell is issued, some quantum of garbage collection must also be done. The requirement is to keep the reclamation of memory ahead of the issuance, so for each memory cell issued, at least 1 must be reclaimed.</p>
<p>Yuasa determined several parameters required to optimize incremental garbage collection.</p><ul>
<li><p class="startli">The size of the <em>Lisp</em> program.</p>
</li>
<li><p class="startli">How many marks or sweeps to perform at each new memory issuance.</p>
</li>
<li><p class="startli">The minimal amount of free memory before GC begins.</p>
</li>
<li><p class="startli">The size of memory required to support the ongoing issuance rate.</p>
</li>
</ul>
<p>The amount of memory and the amount of free cell reserve is adjusted dynamically to preserve realtime behavior, based on a Yuasa analysis after every marking phase.</p>
<p>Another principal concern is the amount of CPU time devoted to garbage collection. In LambLisp, the percentage of time used in GC is one factor used to determine whether to expand the cell population. If the percentage time in GC is above the configured threshold, then an additional cell block is added. As long as the threshold is exceeded, new blocks will be added up to the configured maximum.</p>
<p>The Yuasa analysis determines how many cells total are required to maintain realtime production, and how many must be kept in free reserve to issue while GC collects some new free cells. The Yuasa parameters are recalculated during every garbage collection.</p>
<p>To allow for maximum throughput while maintaining low GC pause time, <em>LambLisp</em> provides a <em>target loop time</em> parameter. When each loop has finished, but before returning to the C++ main() that called it, the <em>LambLisp</em> virtual machine will check if the target loop time has been reach yet. If not, then there are potentially some idle tasks that could be done, that might perhaps usefully fill the time.</p>
<p>The most important of these is garbage collection. If there is loop time left before the target time limit, and if the garbage collection process is active (marking or sweeping) and not idle, <em>LambLisp</em> will calculate a new, temporary GC time quantum based on the time remaining, and run a GC incremental pass with that time quantum. This tends to put much of the GC effort into "idle time", so the GC subsystem moves more quickly into its own <em>idle</em> phase, where no GC is done at all until the Yuasa M parameter is breached.</p>
<p>Interestingly, the printing of messages on <em>Serial</em> (or equivalent) also takes time, despite the UARTs and software buffering involved. Two messages printed during the same loop might easily run the loop time up to 10 milliseconds, regardless of what the loop time is without the messages. <em>LambLisp</em> provides a means to make the printing occur only if idle time is available. This is useful for informational but noncritical messages. This feature has the added advantage of not computing the message contents if time is not available; it is not just skipping printing, but the entire message evaluation.</p>
<p>The <em>idle time</em> feature is available to <em>LambLisp</em> applications, as well in as the underlying C++ interface.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md38"></a>
Scaling by incremental compilation</h3>
<p>Once constructed, ASTs are subject to further optimization for speed, sometimes at the expense of size. ASTs are compounds of native Lisp functions (implemented in C++), as well as those composed in Lisp. By replacing Lisp functions with <em>macros</em>, expressions can be expanded once into their final forms, replacing functions composed in Lisp with their equivalent in Lisp primitives. By doing that replacement selectively, it is possible to tune the application while expanding only those portions that improve performance.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md39"></a>
Scaling by using remote memory</h3>
<p>Because programs are ASTs, and ASTs are data structures, it is possible to store programs, delete them from memory, and retrieve them later. This approach provides a <em>virtual memory</em> capability, which is useful in many circumstances.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Virtual memory advantages  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Startup code that is used once can afterward be purged and the space reclaimed.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Algorithms may be chosen and downloaded at runtime, depending on circumstance.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New algorithms may be introduced in the field, while the process is still under control.  </td></tr>
</table>
<p>Here are the layouts for the most common <em>LambLisp <a class="el" href="classCell.html">Cell</a></em> data types.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="classCell.html">Cell</a> type  </th><th class="markdownTableHeadNone">Word 0  </th><th class="markdownTableHeadNone">Word 1  </th><th class="markdownTableHeadNone">Word 2  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Pair types  </td><td class="markdownTableBodyNone">type + flags  </td><td class="markdownTableBodyNone">car  </td><td class="markdownTableBodyNone">cdr  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Boolean, character, integer  </td><td class="markdownTableBodyNone">type + flags  </td><td class="markdownTableBodyNone">value  </td><td class="markdownTableBodyNone">reserved  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Real numbers  </td><td class="markdownTableBodyNone">type + flags  </td><td class="markdownTableBodyNone">real part 1  </td><td class="markdownTableBodyNone">real part 2  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Vector, string, bytevector  </td><td class="markdownTableBodyNone">type + flags  </td><td class="markdownTableBodyNone">length  </td><td class="markdownTableBodyNone">pointer to native type  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Symbol  </td><td class="markdownTableBodyNone">type + flags  </td><td class="markdownTableBodyNone">hash  </td><td class="markdownTableBodyNone">pointer to string  </td></tr>
</table>
<p> </p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md40"></a>
Benefits of the LambLisp Scalable Architecture.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Benefit  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">The interpreter is compact, allowing more memory for the high-level control application.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">LambLisp's direct-connect parse tree execution provides high performance.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">The interpreter is the entire Lisp virtual machine runtime, already compiled from efficient C++. The Lisp runtime would anyway be included as the functional core of any compiled application.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">No need for full over-the-air updates and reboot. Download new code into the storage system and it can execute on next loop().  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Lisp code can be stored in file system, dynamically loaded &amp; purged, reloaded etc, providing a virtual memory capability.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">No off-board compiler/linker are required to run LambLisp code. Just download the source code to the device.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">LambLisp's incremental, adaptive garbage collector recycles memory automatically and predictably, without worst-case pauses.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">The LambLisp virtual machine, written in C++, is much smaller than an all-C++ application. This means there are fewer low-level features, fewer bugs, requiring less memory and fewer updates than a full C++ application.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Arduino compatibility, with easy addition of extensions.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">No "foreign functions" are required as in other Lisp implementations. Functions written in C++ can be natively incorporated into the Lisp execution environment at full speed.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Provides a basis for macro-based incremental &amp; just-in-time compilation  </td></tr>
</table>
<p> </p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md41"></a>
Advanced topics</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md42"></a>
lambda, nlambda, and macro</h3>
<p>From the beginning, <em>Lisp</em> functions have been divided into <b>special functions</b> and other functions, which have no special designation. They are <em>special</em> primarily in that they do not interact with their parameters in the same way as non-special functions. The main differences between these <em>special functions</em> and the non-special variety are these:</p>
<ul>
<li><p class="startli">Normal lambda functions have their arguments evaluated before the function is applied.</p>
</li>
<li><p class="startli">Special functions receive some or all of their arguments unevaluated.</p>
</li>
<li><p class="startli">Special functions may also be special in many other ways that are function-specific.</p>
</li>
</ul>
<p>While the notion of "function-specific features of special functions" may seem vague, it is a result of the evolutionary nature of early <em>Lisp</em>. It was the first computer programming language that understood itself, and that meta-understanding required and produced a lot of exploration.</p>
<p>The topic of <em>special functions</em> became inextricably bound up with the topic of <b>macros</b>. In all the many <em>Lisp</em> implementations over the years, macros have the largest variety of implementations of any other feature in the language.</p>
<p>A major shortcoming of <em>Scheme R5RS</em> is the inclusion of <span class="tt">syntax-rules</span> as the sole language element for a macro capability, Prior to <em>R5RS</em> <span class="tt">syntax-rules</span> was optional. It is not required to implement the rest of <em>Scheme</em>, when the simpler <b>nlambda</b> construct will do. There is no lower-level macro feature in the language itself that could support <span class="tt">syntax-rules</span>, even though there are several to choose from in previous <em>Lisps</em>. To use <span class="tt">syntax-rules</span> for creating macros first requires an implementation of another (non-*Scheme*) pattern-matching language. Therefore, every <em>Scheme</em> implementation needs to invent or borrow some other lower-level macro facility to support implementation of <span class="tt">syntax-rules</span>. This puts the cart before the horse, and goes against the original <em>Scheme</em> minimalist values.</p>
<p>As a result, there is no common best practice on the implementation of <span class="tt">syntax-rules</span>. And it gets worse: <span class="tt">syntax-rules</span> has now been superceded by <span class="tt">syntax-case</span>, which has the same drawbacks, while presenting new backward-compatibility challenges.</p>
<p>In <em>Common Lisp</em>, a macro system is described that has its own set of quirks, such as not being able to use <em>apply</em> with a macro.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md43"></a>
lambda</h4>
<p>Recall that a <b>lambda expression</b> is a pair, with the <em>car</em> being the formal parameter list and the <em>cdr</em> being the code body. Recall that the result evaluating a <span class="tt">lambda</span> expression is a <b>procedure</b>. A <em>procedure</em> is a first-class type in <em>Scheme</em>, which was an innovation at the time that <em>Scheme</em> was first formulated. The details of the <em>procedure</em> type are left unspecified, and yet one must be returned from <span class="tt">lambda</span>. In <em>LambLisp</em>, a <em>procedure</em> is a kind of <b>pair</b>, with one part being the lambda expression and the other being the environment that the <em>procedure</em> was created in.</p>
<p>In an application of a <em>procedure</em> to a set of parameters, the parameters are each first individually evaluated, and set of results submitted to the <em>procedure</em> as its arguments.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md44"></a>
nlambda</h4>
<p>In <em>LambLisp</em>, the first step to implementation of <em>special forms</em> is <b>nlambda</b>, a concept inherited from <b>InterLisp</b>. The <em>nlambda</em> operator returns a value of type <b>nprocedure</b>. An <em>nprocedure</em> is also a kind of <em>pair</em>, with one part being a body of code, and the other an environment, the same structure as a <em>procedure</em> created with <em>lambda</em>.</p>
<p>When applying an <em>nprocedure</em> to arguments, the arguments are <b>not evaluated</b>. The <em>nlambda</em> feature, by itself, is enough to implement all of <em>Scheme</em>, except for <span class="tt">syntax-rules</span>. Furthermore, <em>nlambda</em> can be used as an essential part of a <span class="tt">syntax-rules</span> implementation.</p>
<dl class="section note"><dt>Note</dt><dd>The key distinction between <span class="tt">lambda</span> and <span class="tt">nlambda</span> is that <b>nprocedure arguments are not evaluated</b>. This allows <em>Lisp</em> to operate on a body of source code, even as it evaluates the same body of source code.</dd></dl>
<h4 class="doxsection"><a class="anchor" id="autotoc_md45"></a>
macro</h4>
<p><em>LambLisp</em> provides the <b>macro</b> operator, which returns a <b>macro transformer</b>. A <em>transformer</em> is a procedure that receives its arguments unevaluated, and returns a value, just an <em>nlambda</em>. However, the value returned by a <em>macro transformer</em> has the additional property that it will be executed as <em>Scheme</em> code. Applying the <em>transformer</em> to a set of arguments is usually termed <em>expanding</em> the macro. When the expanded code runs, it is termed <em>executing the macro</em>.</p>
<p>Macro behavior is different when encountered at read time vs. evaluation time.</p>
<p>It usually desireable to expand macros once at read time, or at least before first use. At read time, the value produced by the <em>transformer</em> replaces the original macro invocation in the input stream. In that case, the expansion happens once and the transformed (expanded) code is what runs at execution time.</p>
<p>If a macro is encountered at execution time, the same expansion process takes place, and then the result is executed immediately. If a symbol is read, and later defined as a macro, performance will be negatively impacted because the symbol will be macro-expanded each time it is encountered by the evaluator. When defined before being read, the symbol is expanded once and the expansion is what gets executed later.</p>
<p>In <em>LambLisp</em> macros are first-class types. That means they can be used as values, as dictionary keys, passed as arguments, etc., like any other data type. Being a variation on procedures, they can be <em>applied</em> to a list of arguments. And being implemented as a list type, they are garbage collected as with any other pair.</p>
<dl class="section note"><dt>Note</dt><dd><b>lambda</b>, <b>nlambda</b>, and <b>macro</b> all create subtypes of procedures. These provide clean implementations of early <em>Lisp*concepts like *special forms</em>, <em>funargs</em> etc.</dd></dl>
 <h3 class="doxsection"><a class="anchor" id="autotoc_md46"></a>
Hash tables, environments, classes, dictionaries, and objects</h3>
<p>Like Python, LambLisp uses <em>dictionaries</em> extensively for flexibility and speed. Dictionaries associate a key with a value, and provide a means for rapid lookup (<em>O(1)</em> in the jargon) of values in the dictionary given a key. In <em>Lisp</em>, dictionaries are commonly implemented with a hash table, which is a vector of size 2^n, each element of which stores an alist of (key . value) pairs.</p>
<p>It will be useful to review hash tables, to see how dictionaries are built using them.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md47"></a>
Hash functions</h4>
<p>A hash function examines any S-expression and returns a hash. The S-expression is essentially used as the seed to a pseudo-random number. The resulting "random" number will be the same each time the S-expession hash is computed, so it is not truly random, and that is what makes it useful.</p>
<p>The hash function is chosen to be fast, and needs only to be reasonably random. The hash value is used as the index to a vector (modulo the vector size). At each element of the hash table will be an association list of (key . value) pairs that have hashed to that index.</p>
<p>When multiple items hash to the same index, it is referred to as a <em>collision</em>. Key runtime metrics are how much of the hash table is populated, and the length of the longest collision chain.</p>
<p>Collisions are common and usually not a problem. Hash tables are typically chosen to be 1-3 times the expected number of entries, so that the entries can be easily well-distributed by allowing for a significant number of empty hash table entries. This leads to short collision chains, mitigating the sequential performance of association lists.</p>
<p>Hash table size is rounded up to the next power of 2. This allows use of the C++ bitwise-and (&amp;) operator for extracting the hash index from the full hash value. That takes much less time than the C++ modulo (%) operator, which uses the underlying multiply instruction. This provides a significant performance improvement for an operation that is done frequently.</p>
<p>Because symbols hashes are used to look up variables values, symbol hashes are computed once when a symbol is created, and then stored with the rest of the symbol info. Symbols are stored in a hash table called <em>oblist</em>. Each symbol record includes a pointer to the print representation and a hash of the print representation. Therefter, testing for symbol equality is a simple pointer comparison, while lookups are speeded by using the pre-computed hash.</p>
<p>The <em>oblist</em> is a hash table, but not a <em>dictionary</em>. Its purpose is to record the text of all symbols encountered, and converting it to a unique number. That number is the address of the symbol in <em>oblist</em>.</p>
<p>It is possible that, for very large hash tables, rounding up to the next power of 2 is undesirable, but rounding down will unacceptably increase collisions. In that case it may be desirable to use a hash table that is not of the optimal size, and use the slower modulo operator for index calculation.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md48"></a>
Dictionaries and environments</h4>
<p>Dictionaries build on hash tables by requiring each element of the hash table to be a list of <span class="tt">(key . value)</span> pairs. It is possible to check for existence of a key with <span class="tt">(dict-ref? dict key)</span>, to obtain the value associated with a key using <span class="tt">(dict-ref dict key)</span>, and set the value associated with a key by executing <span class="tt">(dict-set! dict key value)</span>.</p>
<p>Basic <em>dictionaries</em> are <em>flat</em>, consisting of a single hash table.</p>
<p>LambLisp adds an additional feature, a <em>hierarchical dictionary</em>. A LambLisp dictionary is a <em>list of frames</em>, and each <em>frame</em> is either an association list (best for small frames), a hash table (medium-to-large), or a vector (hash table not of size 2^n) for large fames. When querying a dictionary, LambLisp will search successive frames to find a matching key.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md49"></a>
Environments</h4>
<p>This dictionary implementation is used within LambLisp as the data structure holding the <em>environment</em> in a series of <em>environment frames</em>. To obtain the desired behavior, all the keys in an <em>environment dictionary</em> are symbols.</p>
<p>To look up the value associated with a symbol, each frame is searched in turn to find an entry with a matching key. This key match if addresses of the two compared keys are the same.</p>
<p>Recall that symbol hash values are precomputed and stored with the symbol's characters in <em>oblist</em>. This provides improved performance in hashed frames, and so any symbols in the 2 large initial frames (base and interaction frames) will benefit from this optimization. Those symbols include all the language primitives (<em>define</em>, <em>if</em>, etc.)</p>
<p>The execution environment for LambLisp is a dictionary in which all the keys are symbols. Each symbol has a hash value computed at the time of its creation, and that hash is used to reduce the search time to <em>O(1)</em>.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md50"></a>
Objects</h4>
<p>The flexibility of the dictionary is not limited to the execution environment. In lambLisp, <em>dictionaries</em> are first-class types, so you can create new ones, query them, and add or replace their bindings. You can also add a new frame on to an existing dictionary.</p>
<p>It is easy to see that this implementation is useful to represent objects in general, including inheritance from parent objects. Each object will have its local data in the top frame of its dictionery, and parent data in successive frames.</p>
<p>It is not required that dictionary keys be symbols. Any type of LambLisp object can be used as a key, and they all benefit from the intensive use of hash tables. The general rules for hashing are:</p><ul>
<li><p class="startli">The system hash is djb2.</p>
</li>
<li><p class="startli">Symbol hashes are computed once, when the symbol is created.</p>
</li>
<li><p class="startli">Hashes for immutable atoms (integer, real etc) are computed based on the atom value.</p>
</li>
<li><p class="startli">All other hashes are done on the S-expression value (i.e., the address of a <a class="el" href="classCell.html">Cell</a>).</p>
</li>
<li><p class="startli">This effectively applies the <em>eq?</em> predicate for key matching.</p>
</li>
</ul>
<p>If you are familiar with Python, you may notice the last described behavior is different. Python requires that dictionary keys be immutable types such as <em>tuples</em> instead of <em>lists</em>. Because LambLisp hashes on address, any type may be used as a dictionary key.</p>
<p>Dictionaries themselves may be used as keys or values in other dictionaries.</p>
<p>Note that LambLisp supports object-oriented programming without requiring predeclared classes. If fact, because objects are dictionaries, and dictionaries are lists of frames, it is possible to create child objects from parent objects on the fly by simply using the list operator <em>append</em>.</p>
<p> </p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md51"></a>
Adding native C++ code to LambLisp.</h3>
<p>All of the LambLisp language primitives conform to the same function signature:</p>
<p><span class="tt">Sexpr_t f(<a class="el" href="classLamb.html">Lamb</a> &amp;lamb, Sexpr_t sexpr, Sexpr_t env_exec);</span></p>
<p>Where: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Sexpr_t  </td><td class="markdownTableBodyNone">Return value is a symbolic expression type, which is a pointer to a LambLisp memory cell.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">lamb  </td><td class="markdownTableBodyNone">An instance of a <a class="el" href="classLamb.html">Lamb</a> virtual machine; in C++ produced by <span class="tt"><a class="el" href="classLamb.html">Lamb</a> lamb = new <a class="el" href="classLamb.html">Lamb</a>;</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sexpr  </td><td class="markdownTableBodyNone">The symbolic expression to be evaluated  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">env_exec  </td><td class="markdownTableBodyNone">The environment in which the evaluation should take place.  </td></tr>
</table>
<p>To make the C++ function available in LambLisp, it must be bound into the execution environment. Because the environment is a hierarchical dictionary, the binding can occur in any frame of the dictionary. To bind function <span class="tt">cpp_func</span> to the LambLisp function <span class="tt">Lamb-func</span>, use the <a class="el" href="classLamb.html">Lamb</a> <em>bind_bang</em> function.</p>
<p>A few things to note about the <em>bind_bang</em> function:</p><ul>
<li><p class="startli">Like most other function in Scheme-based Lisps, a <em>bang</em> or exclamation point ! is used to highlight functions that cause mutations to existing data.</p>
</li>
<li><p class="startli">The <em>bind_bang</em> function takes 4 arguments, 2 of which are environments (i.e., dictionaries). One is the execution environment. All LambLisp native C++ functions require this argument. The other is the target environment (which is a dictionary) that is to be modified.</p>
</li>
<li><p class="startli">The full signature of <em>bind_bang</em> is:</p>
<div class="fragment"><div class="line">void bind_bang(</div>
<div class="line">                Sexpr_t env_to_be_modified,</div>
<div class="line">                Sexpr_t key_to_be_bound,</div>
<div class="line">                Sexpr_t value_to_be_bound,</div>
<div class="line">                Sexpr_t env_exec</div>
<div class="line">                );</div>
</div><!-- fragment --></li>
</ul>
<p>Sample code for adding a C++ function to LambLisp: </p><div class="fragment"><div class="line">//Define your native function somewhere, with the necessary signature.</div>
<div class="line">Sexpr_t my_native_operator(Lamb &amp;lamb, Sexpr_t sexpr, Sexpr_t env_exec);</div>
<div class="line"> </div>
<div class="line">Sexpr_t sym  = lamb.mk_symbol(&quot;Lamb-func&quot;, env_exec);   //Create a symbol in Lisp.</div>
<div class="line">Sexpr_t proc = lamb.mk_mop3_proc(cpp_proc, env_exec);   //Create a native code Lisp function.</div>
<div class="line"> </div>
<div class="line">//Bind the symbol to the function, in this example binding to the top-level environment.</div>
<div class="line">lamb-&gt;bind_bang(lamb.r5_interaction_environment(), sym, proc, enc_exec);</div>
</div><!-- fragment --><p> </p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md52"></a>
Interfacing to devices</h3>
<p>LambLisp provides several examples demonstrating how to interface with a variety of devices. Here we review the different approaches used for different types of devices.</p>
<p>Low level input/output, such as digitalRead(), analogRead() and similar functions are represented directly in LambLisp, identical to their Arduino counterparts, if one discounts the shift in parenthesis. The Sonar example illustrates the techniques required.</p>
<p>The Sonar example also shows that some things are best done in C++; in this case busy-waiting for a pin to change state and measure its time in state with microsecond resolution. Although the system is blocked waiting for the pin, other approaches fail on the ESP32-Arduino. Using interrupts avoids blocking, but the interrupt latency is large and variable, leading to a useless measurement. Use of threads (pthreads) with a dedicated wait thread leads to the same problem.</p>
<p>It's interesting that the Sonar measurement falls in the same range as the loop time, and that is the source of the requirement for busy-waiting. If the loop time was much longer, the interrupt jitter would not matter. If the loop time was much shorter, we would loop and poll instead of waiting.</p>
<p>The Sonar example also exhibits the <em>singleton</em> pattern. There is only 1 Sonar, and it has C++ operations, so it makes sense to bundle it into a C++ class and to create a single instance of that class. The interface then becomes very thin, just a matter of marshalling the parameters in the <em>mop3</em> interfaces for each function required in Lisp.</p>
<p>I2C and SPI are common board-level communication protocols used to control embedded devices. SPI is point-to-point, while I2C is a command/response protocol with one command device on the bus at any time, and multiple reponse devices available to receive commands and report data.</p>
<p>I2C has been implemented and included in LambLisp. SPI has not been implemented yet, but the same principles apply and SPI could be added to LambLisp in the field.</p>
<p>Interfaces to I2C devices fall into 3 sizes: small, medium, and large.</p>
<p>A simple device like the PCF8574 can be operated directly Lisp over I2C with minimal overhead; this device accepts only I2C write and read commands, which are available directly in Lisp. See the file PCF8574 for the minimal example using I2C low-level operations.</p>
<p>Devices like Wire (aka I2C) and WiFi are in the medium category. These libraries depend on predefined <em>singletons</em> of a predefined class. The LambLisp implementation is similar to Sonar, but a bit simpler because the Wire/WiFi class and instances are predefined. On the other hand, both Wire and WiFi have a lot more methods and parameters to deal with.</p>
<p>In the case of Wire and WiFi, C++ does a bit of work, checking and returning high-level errors rather than returning raw error codes to Lisp. Mostly though, the interface layer is concerned with marshalling parameters between C++ and Lisp.</p>
<p>The PCA9685 is a 16 channel PWN controller, originally advertised as an LED controller, but in fact it can be used anywhere a controllable square wave is needed. As it turns out, a variety of motors and linear actuators can be controlled this way.</p>
<p>The PCA9685 is simple in principle, but it allows multiple devices on the bus, and allows each of them to repond to a secondary address, which is programmable and may be shared between devices. This allows operating them in groups with a single command.</p>
<p>That is relevant because it makes the driver code much larger, more than most people would want to rework and take ownership. The PCA9685 LambLisp example shows how to incorporate a large driver without needing to undertand it in detail or modify it, by only interfacing the with behaviors required for your application.</p>
<p> </p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md53"></a>
Other Scheme Implementations</h2>
<p>This project was started after a review of available options for run-time languages to augment C++ embedded applications, and the likely candidates were all on the Lisp/Scheme spectrum. Some of the existing implementation that were examined include: TinyScheme, ulisp, microlisp, picolisp, T, L, Pre-Scheme, LispBM, chicken, bigloo, racket, chibi and others. Plug those into your favorite search engine to find even more.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">General objections to existing Lisp/Scheme implementations  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Required off-board compilation.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Out of scale for a microprocessor.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Non-portable hardware tricks (e.g., using the bottom bits of addresses as flag bits).  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Non-Scheme lisps (e.g., no lexical scoping or tail recursion).  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Bad fit on the interpret&lt;-&gt;compile spectrum (e.g, low-level interpeter or huge compiler).  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Lisp-on-Python, Lisp-on-JavaScript, and other such proofs.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Garbage collection: Real-time applications must avoid pauses, so stop-the-world, reference counting and generational GC cannot be used.  </td></tr>
</table>
<p> </p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md54"></a>
LambLisp Compatibility Matrix</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone" colspan="2">Feature status codes  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyNone">Supported  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyNone">In Progress  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyNone">Unsupported  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><p class="starttd"><img src="GreyCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyNone">Unspecified  </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><em>LambLisp</em> Compatibility Matrix  </th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Embedded Systems Adaptations</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Arduino-compatible API (Wire, WiFi, analog &amp; digital I/O, )  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Incremental adaptive garbage collector  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreyCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreyCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">High performance optimized type hierarchy  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreyCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreyCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Integrated high speed hash tables  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Object system  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Incremental over-the-air updates  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">High speed integer and float instructions  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"Bitwise operators &amp; \| ^ (i.e., bitwise AND OR XOR)"  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Timers to support asynchronous operation  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Common interface for all native procedures  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreyCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreyCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Links with existing C++ hardware drivers  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreyCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreyCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Logging facility  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Comprehensive interface to operating system  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreyCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreyCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><em>LambLisp</em> Compatibility Matrix  </th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Scheme language features</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Proper tail recursion, lexical scoping, duck typing, REPL  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Datum labels  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">#u8 data type  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Type predicates</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">boolean? char? number? symbol? pair? vector?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">procedure? string? port? eof-object?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">null? bytevector?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Symbols</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">symbol? symbol=? symbol-&gt;string string-&gt;symbol  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Procedures</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">define lambda  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">nlambda  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">macro  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Conditionals</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">if else cond case and or not  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">when unless  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cond-expand case-lambda  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
</table>
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><em>LambLisp</em> Compatibility Matrix  </th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Assignments, Binding, and Syntax Definition</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">set! define let let* letrec =&gt;  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">define-syntax let-syntax letrec-syntax  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">syntax-rules  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">syntax-error  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">let-values let*values define-values  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">include  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">include-ci  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">nlambda  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Evaluation and quotation</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">quote quasiquote unquote unquote-splicing  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Reader macros ' ` , ,@  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">begin do named let  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">delay force  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">delay-force promise? make-promise  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Dynamic bindings</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">make-parameter  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">parameterize  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Libraries and Importing</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">import only except prefix rename define library  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Records</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">define-record-type  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Equivalence Predicates</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">eq? eqv? equal?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
</table>
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><em>LambLisp</em> Compatibility Matrix  </th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Numeric types</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">integer real  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">complex  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">rational  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Numeric Operations</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">number? complex? real? rational? integer?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">exact? inexact? exact-integer? finite? infinite?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">nan? zero? positive? negative? odd? even?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">abs max min + - * / &lt; &lt;= = &gt;= &gt;  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">quotient remainder modulo  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">floor ceiling truncate round  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">floor/ floor-quotient floor-remainder  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">truncate/ truncate-quotient truncate-remainder  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">numerator denominator gcd lcd  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">abs expt log square sqrt  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">sin cos tan asin acos atan  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">exact-integer-sqrt  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">real-part imag-part magnitude angle  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">make-rectangular make-polar  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">number-&gt;string string-&gt;number  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
</table>
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><em>LambLisp</em> Compatibility Matrix  </th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Pairs and Lists</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">pair? cons car cdr set-car! set-cdr! list?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">null?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">atom?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">make-list list  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">caar .. cddr (all combinations of car &amp; cdr)  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">caaaar .. cddddr  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">append a reverse list-tail list-ref list-set! list-copy!  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">reverse!  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">memq memv member assq assv assoc  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">vector-&gt;alist alist-&gt;vector  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
</table>
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><em>LambLisp</em> Compatibility Matrix  </th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Characters</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">char? char=? char&lt;? char&gt;? char&lt;=? char&gt;=?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">char-alphabetic? char-numeric? char-whitespace?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">char-uppercase? char-lowercase?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">char-&gt;integer integer-&gt;char  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Case-independent char-ci-* functions  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">char-upcase char-downcase  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">char-foldcase  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">digit-value  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Strings</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">string? make-string string string-length string-ref string-set!  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">string&lt;? string &lt;=? string=? string&gt;=? string&gt;?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Case-independent string-ci functions  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">substring string-append string-&gt;list list-&gt;string  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">string-copy string-fill!  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">string-copy!  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">string-foldcase  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
</table>
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><em>LambLisp</em> Compatibility Matrix  </th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Vectors</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">vector? make-vector vactor-length vector-ref vector-set!  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">vector-fill! vector-&gt;list list-&gt;vector  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">vector-&gt;string string-&gt;vector vector-append  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">vector-&gt;alist alist-&gt;vector  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">vector-copy  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Bytevectors</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">bytevector? make-bytevector bytevector bytevector-length  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bytevector-u8-ref bytevector-u8-set!  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">bytevector-copy bytevector-copy! bytevector-append  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">utf8-&gt;string string-&gt;utf8  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Control Features</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">procedure? apply map for-each  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">string-map vector-map  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">string-for-each vector-for-each  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">force delay  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">call-with-current-continuation  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">values call-with-values  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dynamic-wind  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Environments and Evaluation</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">environment  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">eval scheme-report-environment  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">null-environment interaction-environment  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
</table>
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><em>LambLisp</em> Compatibility Matrix  </th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Ports</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">call-with-input-file call-with-output-file  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">call-with-port  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">port? input-port? output-port?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">textual-port? binary-port?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">input-port-open? output-port-open?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">current-input-port current-output-port close-port  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">current-error-port  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">with-input-from-file with-output-to-file  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">open-input-file open-output-file  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">open-input-binary-file open-output-binary-file  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">close-input-port close-output-port  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">open-input-string  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">open-output-string get-output-string  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">open-input-bytevector  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">open-output-bytevector  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
</table>
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><em>LambLisp</em> Compatibility Matrix  </th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Input and Output</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">read read-char peek-char eof-object? char-ready?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">read-string read-line  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">read-u8 peek-u8 u8-ready? read-bytevector read-bytevector!  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">write display newline  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">write-shared write-simple  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">write-char-string write-u8 write-bytevector flush-output-port  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>System Interface</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">load  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">file-exists? delete-file  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">command-line  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">exit emergency-exit  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">get-environment-variables  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">current-second current-jiffy jiffies-per-second  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">features  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Exception handling</b>  </td><td class="markdownTableBodyCenter">Scheme R5RS  </td><td class="markdownTableBodyCenter">Scheme R7RS  </td><td class="markdownTableBodyCenter">LambLisp  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">guard raise  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">with-exception-handler  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">raise-continuable  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">error error-object? error-object-message error-object-irritants  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">read-error? file-error?  </td><td class="markdownTableBodyCenter"><p class="starttd"><img src="RedCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="GreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td><td class="markdownTableBodyCenter"><p class="starttd"><img src="LightGreenCircle.png" alt="" class="inline"/>    </p>
<p class="endtd"></p>
</td></tr>
</table>
<p> </p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md55"></a>
LambLisp Frequently Asked Questions</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md56"></a>
What is a real-time control system?</h2>
<p>A control system senses the physical world and operates tools to influence the physical world. Today the term applies mainly to software-based controls, but in the past pneumatic and relay-based control systems were used.</p>
<p>A real-time control system offers guarantees that outputs will be updated within a certain time period (the "deadline") after inputs changing.</p>
<p>LambLisp provides "loop-based control", in which the control software has a time slice in which it can operate inputs and outputs in any order, and then returns to its caller. The time slice is not a fixed length, and the control software takes all the time needed to complete its slice. The "loop time" is the total time between the start of one time slice and the start of the next, so it includes system overhead, and also includes time used by any other software components that also get time slices.</p>
<p>It is easy to see that the loop time is closely related to the real-time guarantee that can be provided. Metrics such as maximum and average loop time are important in loop-based control.</p>
<p>There are other types of control systems. Some impose a strict order on the input-calculate-output cycle, with all inputs read at the beginning of the time slice, and all outputs written at the end. Others are asynchronous, with different sections of code running independently, and perhaps in parallel, in response to input changes. Some asynchronous control systems are simulated on top of a loop-based foundation layer.</p>
<p>The real-time guarantees may be described as "hard" or "soft", but these terms have no universally accepted definition.</p>
<p>A hard guarantee is sometimes used to describe applications with negative consequences for missing a deadline. This may be true in a financial application, for example.</p>
<p>However, a more strict definition of "hard guarantee" would be that the system has failed when a deadline is missed, and therefore it should signal the failure to a supervisory system, stop normal operation, and await some external stimulus. This is sometimes appropriate in physical systems, where a missed deadline indicates that the process is no longer under close control and requires a fallback strategy.</p>
<p>With the strict definition, if the system continues to operate, even in a sub-optimal mode or with additional missed deadlines, then it is "soft" real time.</p>
<p>Even with these definitions, the difference between a "fallback strategy" and a "sub-optimal mode" leaves a grey area. A fallback strategy will focus on safety and prevention of further losses. Operating in a sub-optimal mode provides continued economic value while the root cause is addressed.</p>
<p>Soft real-time solutions also commonly have a timeout threshold, after which they will declare failure; this further blurs the difference between hard and soft solutions.</p>
<p>Soft real-time applications vastly outnumber hard real-time. That is partly because these problems can be factored to reduce or eliminate the "hard" aspect. Some examples of factoring a hard RT problem: airbag chip, UART, other types of buffering (perhaps interrupt-driven), being provably "fast enough" by a known margin, using interlocks to pace the controlled process and therefore reduce dependency on timing.</p>
<p>A constrained system does not create a hard problem out of a soft problem. The processor must have enough capacity to solve the problem, else it is a system design defect, not a real-time problem. The real-time problem exists whether or not you have a solution for it.</p>
<p>Also, specifications other than the deadline do not create hard problems out of soft ones. A promise to deliver 10 millisecond loop times is not a "hard" guarantee, unless the system should declare failure and stop normal operation when the 10 ms is exceeded.</p>
<p>Industrial control systems rarely rely on timing to ensure that their different parts are in the correct position for the next operation. Eventually something will age, perform outside the assumed time envelope, and destruction results.</p>
<p>To assure correct operation, one or more sensors will be in place to confirm correct positioning of parts and equipment, and these sensors require an additional loop to fulfill an operating cycle. A faster control loop will result in faster throughput on the controlled system, up to its physical limits, but each step is controlled by its latest inputs, and not by timing expectations.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md57"></a>
What are the advantages of <em>LambLisp</em> in combination with C/C++ on micro-controllers?</h2>
<p>The Lisp language itself provides features not available in C/C++, such as interactive programming, dynamic "duck" typing, and dynamic loading and purging of code. While C++ and other Fortran descendants excel at rapid calculation, Lisp was the original language of AI, developed for solving problems that require reasoning. The definitive book, Common Lisp by Guy Steele, grew to 1000 pages. Lisp, including its Scheme dialect, is used by Cisco, Cadence, and Autodesk in their flagship products.</p>
<p>LambLisp is an implementation focused on real-time control applications while adhering to the well-known and popular Scheme R5RS specification (about 50 pages). The Scheme dialect of Lisp prescribes features familiar to C++ and Python programmers, such as lexical scoping, as well as advanced features such as tail recursion.</p>
<p>LambLisp adheres to the Scheme R5RS standard, and then adds specializations for real time control, including a few helpful features from Scheme R7RS. There are built-in interfaces to Arduino-style I/O, and a simple way to add additional external code, with plenty of examples.</p>
<p>LambLisp allows convenient scalability between C++ and Lisp. It is not required to choose one or the other; they may be used together, each for their advantages. It is easy to call back and forth, even multiple times within one loop.</p>
<p>All the top-level Scheme primitives are written in C++ using the same simple API used to interact with hardware drivers. This API is available to external developers.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md58"></a>
What makes LambLisp different from small Lisps, such as Picobit and uLisp, or big Lisps, such as racket, ChezScheme, and chicken?</h2>
<p>The limitation on complexity of embedded Lisp derives from limited memory and address space. The recent generation of inexpensive 32-bit ARM is thousands of times more capable than a PIC. Such peripherals as a file system, WiFi, or Bluetooth are not available on the tiny processors.</p>
<p>A Lisp implementation should look very different for a small platform vs. a larger one. Indeed that is what happened. Picobit requires offboard processing and uses a bytecode compiler, and then the bytecode is interpreted at runtime.</p>
<p>In contrast, LambLisp is completely onboard, and does not internally loop over bytecode. Instead it builds an abstract syntax tree and executes that. The nodes on the syntax tree may be interpreted or compiled. The nodes are high-level syntactic elements (not bytecode) specified in Scheme R5RS, such as if, define, set!. This architecture results in a very short interpret/compile stack, a fast transition to the underlying C++ implementation, and fast control loops.</p>
<p>While LambLisp is compact, it is not a "mini Lisp". LambLisp is not trying to occupy the tiniest cpus. Instead, it takes advantage of the increasing processing power to put a more powerful standards-conforming Lisp into recent-generation micro-controller cpus.</p>
<p>Likewise, LambLisp is not a "big Lisp", and is not a platform for general computer science investigations. The focus is on high-performance control.</p>
<p>There are other Lisps and Schemes, but LambLisp was designed with these constraints and differences from other implementations:</p>
<ul>
<li><p class="startli">Substantially conform to some recognized and popular specification</p>
</li>
<li><p class="startli">Small enough to fit in a micro-controller (so no ChezScheme and other <em>Big Lisps</em>)</p>
</li>
<li><p class="startli">Big enough to take full advantage of the latest 32-bit generation (ruling out Picobit and other tiny implementations)</p>
</li>
<li><p class="startli">Must offer real-time guarantees (no stop-the-world GC, no DSW pointer-inversion algorithm)</p>
</li>
<li><p class="startli">No bytecode interpreter (slow)</p>
</li>
<li><p class="startli">Vectors allocated from heap, not consecutive cells (slow)</p>
</li>
<li><p class="startli">Bytevector support</p>
</li>
<li><p class="startli">No off-board processing required</p>
</li>
<li><p class="startli">Easy reuse of existing Arduino-style hardware abstraction layer and existing hardware drivers</p>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md59"></a>
Why not use embedded Python derivatives?</h2>
<p>Python derivatives may work for a subset of embedded control applications, but will not thrive in that solution space. The garbage collector is tuned for throughput, without real-time guarantees. A python derivative called Serpent comes closest, with a real incremental garbage collector, but it is not Python, requires off-board processing, has no generalized interface to hardware, and otherwise does not fill the same solution space as LambLisp</p>
<p>Python syntax is a runtime burden for an interpreter. It is the result of a series of graduate school homework assignments, done in Scheme, and the homework answers were required to look very different from Scheme. Interpreting Python syntax requires solutions to all that homework, creating a greater challenge (relative to Lisp) when trying to completely embed a real-time Python programming system. One of the great strengths of Lisp is that the language already interprets itself.</p>
<p>Part of Python's strength is the many interfaces to external libraries, but the mini-pythons cannot take full advantage.</p>
<p>On the other hand, there is a lot to learn from Python, and lessons are incorporated into LambLisp wherever they apply. For example, <em>dictionaries</em> are a first-class type in LambLisp, as they are in Python.</p>
<p>LambLisp dictionaries are more powerful than those in Python. They can be stacked into a child/parent arrangement, supporting their use as directly by the application, as the data store for an object wrapper, and as execution environments for LambLisp itself. Also, LambLisp dictionary keys need not be immutable.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md60"></a>
How do I link existing libraries to <em>LambLisp</em>?</h2>
<p>The interface to external libraries is the same as that used for <em>LambLisp</em> top-level functions, so external C++ code just needs a <em>LambLisp</em> veneer to become available to the <em>Lisp</em> application.</p>
<p>Every <em>LambLisp</em> native operator is written in C++ and has the following signature:</p>
<p><span class="tt">Sexpr_t mop3_func(<a class="el" href="classLamb.html">Lamb</a> &amp;lamb, Sexpr_t sexpr, Sexpr_t env_exec)</span></p>
<dl class="section note"><dt>Note</dt><dd>There are just 2 data types required for C++/LambLisp interaction: symbolic expressions of type <span class="tt">Sexpr_t</span>, and a LambLisp virtual machine of type <span class="tt"><a class="el" href="classLamb.html">Lamb</a></span>.</dd></dl>
<p>By convention, functions with this signature are referred to as <b>mop3</b> type, because they are the fundamental <em>machine operations</em> in <em>LambLisp</em>, and they accept 3 parameters. LambLisp <em>mop3</em> language primitives all have the same signature:</p><ul>
<li><p class="startli">a reference to a <span class="tt"><a class="el" href="classLamb.html">Lamb</a></span> LambLisp virtual machine</p>
</li>
<li><p class="startli">an S-expression of type <span class="tt">Sexpr_t</span> to evaluate</p>
</li>
<li><p class="startli">an environment of type <span class="tt">Sexpr_t</span> to evaluate within; this is known to be a <em>LambLisp hierarchical dictionary</em>.</p>
</li>
</ul>
<p>On the ESP32-S3 devkit module there is an LED accessed via the C++ <span class="tt">neopixel</span> function:<br  />
 This examples shows how to attach the <span class="tt">neopixel</span> function to <em>LambLisp</em>.</p>
<p>The native <span class="tt">neopixel</span> signature is this: </p><div class="fragment"><div class="line">void neopixel(int pin, int red, int green, int blue);</div>
</div><!-- fragment --><p> To make this available in <em>LambLisp</em>, first create the C++ <em>mop3</em> function that you want to appear in <em>LambLisp</em>.</p>
<div class="fragment"><div class="line">Sexpr_t mop3_neopixel(Lamb &amp;lamb, Sexpr_t sexpr, Sexpr_t env_exec)</div>
<div class="line">{</div>
<div class="line">   int pin   = lamb.car(sexpr)-&gt;as_Int_t();</div>
<div class="line">   int red   = lamb.cadr(sexpr)-&gt;as_Int_t();</div>
<div class="line">   int green = lamb.caddr(sexpr)-&gt;as_Int_t();</div>
<div class="line">   int blue  = lamb.cadddr(sexpr)-&gt;as_Int_t();</div>
<div class="line">   neopixel(pin, red, green, blue);</div>
<div class="line">   return OBJ_VOID;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Then, create a new variable (a [name, value] pair) in the environment:</p>
<div class="fragment"><div class="line">Lamb *lamb = new Lamb;</div>
<div class="line">lamb-&gt;setup();</div>
<div class="line"> </div>
<div class="line">//make a new symbol, or obtain the existing symbol</div>
<div class="line">Sexpr_t sym = lamb-&gt;mk_symbol(&quot;neopixel&quot;, env_exec);</div>
<div class="line"> </div>
<div class="line">//preserve the symbol from GC while the procedure is under construction</div>
<div class="line">lamb-&gt;gc_root_push(sym);</div>
<div class="line"> </div>
<div class="line">//create the native (&quot;mop3&quot;) procedure </div>
<div class="line">Sexpr_t proc  = lamb-&gt;mk_Mop3_procst_t(mop3_neopixel, env_exec);</div>
<div class="line"> </div>
<div class="line">//unpreserve the symbol</div>
<div class="line">lamb-&gt;gc_root_pop();</div>
<div class="line"> </div>
<div class="line">//add the variable into the target environment (often the same as the execution environment).</div>
<div class="line">lamb-&gt;bind_bang(env_target, sym, proc, env_exec);</div>
</div><!-- fragment --><p> To operate the LED from <em>Lisp</em>: </p><div class="fragment"><div class="line">(neopixel 38 128 0 0)  ;pin 38, half red, no green, no blue</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Garbage collection can happen anytime a new cell is created. Items not in the current environment, or saved on the GC protect stack, are subject to collection. If a native function consumes several cells, each must be pushed onto the GC protect stack before the next is created. All must then be popped off before returning the function result.</dd>
<dd>
</dd></dl>
<h2 class="doxsection"><a class="anchor" id="autotoc_md61"></a>
What are the currently implemented features?</h2>
<p>LambLisp v01 Red Fox Alpha is the inaugural release. It is ALPHA - do not use it on applications that put persons or property at risk.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md62"></a>
Scheme R5RS coverage</h3>
<p>LambLisp is designed to substantially cover the Scheme R5RS specification. All the major language elements (define, set!, if, cond, case, let ,...) have been implemented. There are a few areas that are unfilled, such as the many versions of the "floor" function, but every element of the spec has been stubbed in at least. It passes the chibi tests for the functions that have been implemented (with a couple of bugs).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md63"></a>
Adaptive Real-Time Garbage Collector</h3>
<p>The adaptive real-time garbage collector is implemented and thoroughly tested. It automatically tunes the GC start threshold based on the analysis published by Taichi Yuasa in 1990.</p>
<p>It also implements idle-time collection, time-shifting GC activity out of the program execution phase and into the end of short loops. By collecting ahead, later GC passes during program execution can be skipped entirely. Idle-time collection also processes many more cells than the normal GC increment, reducing the loop overhead associated with the incremental GC.</p>
<p>The GC will also request more memory from the system if the GC load is above a programmed percentage, or if the Yuasa analysis indicates the need for more cells to maintain real-time cell production.</p>
<p>The optimized Yuasa parameters may be stored as initial values for later sessions, which will optimize the allocated cell block size.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md64"></a>
Tail recursion and Continuation-Passing Style</h3>
<p>Tail recursion is supported, and so continuation-passing style can be used in the LambLisp application. For best performance tail recursion has been implemented directly in C++ using the "trampoline" technique, and not through the use of a bytecode virtual machine with its own linked stack.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md65"></a>
What is still being developed?</h3>
<p>The macro system is still under development, so there is no <em>syntax-rules</em> yet. Instead <em>nlambda</em> is used for syntax elements. Borrowed from <em>InterLisp</em>, <em>nlambda</em> is similar to <em>lambda</em>, but at run time arguments to <em>nlambda</em> are <b>not</b> evaluated before the procedure body is executed. This has proved sufficient for implementing the <em>Scheme</em> language, except for <em>syntax-rules</em>. There is a <em>macro</em> facility, that will run (aka <em>expand</em>) at read time or execution time, and the resulting expansion will execute at execution time. In <em>LambLisp</em>, <em>macro expressions</em> and <em>nlambda expressions</em> are both implemented as variants of <em>lambda expressions</em>.</p>
<p>Work on the macro system will continue, and it's not clear that <em>syntax-rules</em> is the best way to do that. It was optional in Scheme R4RS, then mandatory in R5RS, and is rumored to be optional again in a hypothetical future R8RS. Something called <em>syntax-case</em> has arisen in the meantime.</p>
<p>Given the multi-decade approval process for Scheme specifications, it's reasonable to explore macro techniques that have been used successfully in other Lisps, and look for advantages in the embedded control context.</p>
<p>The quasiquote function is buggy.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md66"></a>
What is not supported?</h3>
<p>As a side effect of the efficient C++ tail recursion, it is not convenient to capture the <em>current continuation</em>. A continuation is essentially a complete process context, containing the execution state (CPU registers, CPU flags, stack, and perhaps main memory) of a thread with the expectation of restoring it later. In C++ the continuation contains (among other things) a complete contiguous stack history (not a linked stack).</p>
<p>That kind of stack horsemanship is burdensome and provides limited value in the embedded control context, not least because there are alternatives (such as actual <em>threads</em>). Therefore there is no <em>call-with-current-continuation</em> function.</p>
<p>To be clear, <em>tail recursion</em> is supported, and therefore <em>continuation-passing style</em>; it is just the capture of the <em>current continuation</em> that is not supported.</p>
<p>The built-in funtion syntax-rules<span class="tt"> is not implemented.
It is not possible to implement this function without having already implemented another macro capability to support it.
Therefore, *LambLisp* focused first on </span>nlambda<span class="tt"> and </span>macro<span class="tt">.
</span>nlambda<span class="tt"> operates like *lambda* except that its arguments are not evaluated before the function body is applied.
</span>macro<span class="tt"> operates like </span>nlambda`, but offers 2 additonal behaviors. When a macro expression is encountered at read time, the result of its evaluation replaces the original macro expression in the input; it is the macro expansion that will be evaluated at runtime. When a macro expression is encountered at runtime, the macro is expanded just as at read time, and then the result is executed immediately.</p>
<p>While <span class="tt">syntax-rules</span> can surely be implemented using <span class="tt">nlambda</span>/<span class="tt">macro</span> as a base, it is not a priority at present.</p>
<p>Functions that are easy to implement directly in Scheme, such as the case-independent string functions, are omitted temporarily. Ultimately they will be loadable application code and not part of the LambLisp virtual machine.</p>
<p>Rational numbers are not supported, but may be added if demand requires.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md67"></a>
Why is it called LambLisp instead of Scheme?</h3>
<p>During the 1960s, a great many of the desired and desirable behaviors of programming languages were still being worked out. While Fortran was used heavily for numeric computation, <em>lexical scoping</em> (which C programmers experience as "local variables") arose in the Algol language, and later "message passing" systems (primarily <em>SmallTalk</em>) resulted in the "tail recursion" technique and interactive computing.</p>
<p><em>LISP</em> provided a significant abstraction of the computation process. By operating primarily on addresses rather than values, <em>Lisp</em> provided a method for creating new and arbitrary data structures. A great deal of research and discussion was expended on functions and their abstract properties (fexprs, property lists, nlambdas and the rest). With these tools and techniques, <em>Lisp</em> provided a facility for reasoning, not just calculating.</p>
<p>The experimental nature of <em>Lisp</em> let to a large number of overlapping solutions to overlapping problems. This led to the development of <b>Common Lisp</b>, a 1000-page compendium of <em>Lisp</em> functions that had proven useful.</p>
<p>At the same time, there was a realization that "more and bigger" <em>Lisp</em> was not necessarily a good thing, producing many incompatible partial implementations. An alternative mindset emerged, that a small set of language primitives would be easier to standardize. The key to success is to be sure that the set of primitives is sufficient to create the kinds of more complex functions found in <em>Common Lisp</em>.</p>
<p>These and other ideas (especially <em>tail recursion</em> and <em>continuation-passing style</em>) came together in <em>Scheme</em>, which was designed in the 1970s to integrate the theoretical advances and practical understanding that had occurred over the previous 15 years.</p>
<p><em>Scheme</em> went through several iterations and the usual technical committee sausage-making process, resulting in two main specifications today, known as R5RS and R7RS.</p>
<p>There has always been tension between <em>Scheme</em> minimalists, who prefer to specify a small set of language primitives, and utilitarians, who prefer a language that is useful for real-world problems.</p>
<p>This had led to the sadly comical state where the R7RS specification had to be divided into R7RS-small and R7RS-large, with R7RS-small already being significantly larger tha R5RS specification.</p>
<p>There are few <em>Scheme</em> implementations that are completely conformant to R5RS or R7RS. Both specs allow plenty of leeway for alterative behaviors, for example in the implementation of macros, or the results of invalid computations.</p>
<p>For some <em>Scheme</em> enthusiasts, the function <em>call-with-current-continuation</em> is the <em>sine qua non</em> of <em>Scheme</em> implementations, so that argues against labeling this system <em>Scheme</em>. The latest thinking seems to be that this feature is actually not as great in practice as in theory, and may be removed (or optionalized) in some future R8RS specification.</p>
<p>Likewise, <em>LambLisp</em> has a simple macro system based on the <em>nlambda</em> feature of InterLisp, while the RxRS specs call for a macro system based on the language primitive <em>syntax-rules</em>. This seems to be in flux with <em>syntax-case</em> proposed as an improved alternative to <em>syntax-rules</em>.</p>
<p>Because <em>nlambda</em> is sufficient for <em>LambLisp</em> implementation, <em>syntax-rules</em> is parked. Macros are implemented for use in just-in-time compilation.</p>
<p>The differences in support for <em>call-with-current-continuation</em> and <em>syntax-rules</em> argue against calling this language <em>Scheme</em>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md68"></a>
Acknowledgements</h1>
<p>I reviewed many <em>Lisp</em> and <em>Scheme</em> implementations, but the one I studied in detail was <em>TinyScheme 1.42</em>, writen in 5000+ lines of high-quality circa-1992 C code. It was too big for the processor I was working on at the time (in 2020). Ultimately I returned to the embedded Lisp problem, but made different design choices than the TinyScheme authors, especially on the compile-vs-interpret spectrum and garbage collection techniques. The study was hugely informative nonetheless.</p>
<p><em>Chez Scheme</em> is the ultimate large implementation. It is the work of a lifetime, primarily of one man, and a standard for performance and completeness in the Scheme world. During the development of <em>LambLisp</em>, <em>Chez Scheme</em> was used to provide benchmark behavior in cases where the spec is not clear or offers a choice of outcomes.</p>
<p>I have provided an extensive bibliography that also informed my efforts. If the reader would like to better understand Lisp design, begin your journey there. No doubt you will discover a different destination.</p>
<p>Some images above require:</p>
<p>By VectorVoyagerPNG version: user:rogerb - Own work CC BY-SA 3.0, <a href="https://commons.wikimedia.org/w/index.php?curid=127589172">https://commons.wikimedia.org/w/index.php?curid=127589172</a> Harke CC BY-SA 3.0 <a href="https://creativecommons.org/licenses/by-sa/3.0">https://creativecommons.org/licenses/by-sa/3.0</a>, via Wikimedia Commons</p>
<p>Bill White 2025 </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.16.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.0 </li>
  </ul>
</div>
</body>
</html>
