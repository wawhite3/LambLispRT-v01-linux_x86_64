<!-- HTML header for doxygen 1.16.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LambLisp: Lamb Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome-cust.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="lamb-39.jpeg"/></td>
  <td id="projectalign">
   <div id="projectname">LambLisp<span id="projectnumber">&#160;01 Red Fox Alpha</span>
   </div>
   <div id="projectbrief">Lisp For Real-Time Control</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classLamb.html','','classLamb-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Lamb Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1f2e3ba9db4055bd60f1e765b9ecfaf4" id="r_a1f2e3ba9db4055bd60f1e765b9ecfaf4"><td class="memItemLeft">typedef Sexpr_t(*&#160;</td><td class="memItemRight"><a class="el" href="#a1f2e3ba9db4055bd60f1e765b9ecfaf4">Mop3st_t</a>) (<a class="el" href="classLamb.html">Lamb</a> &amp;lamb, Sexpr_t sexpr, Sexpr_t env_exec)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af836071fde5f37dc0cc230fd7a24102b" id="r_af836071fde5f37dc0cc230fd7a24102b"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#af836071fde5f37dc0cc230fd7a24102b">load</a> (Charst_t name, Sexpr_t env_exec, Int_t verbosity=0)</td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Arduino-compatible loop-based control interface.</div></td></tr>
<tr class="memitem:afb2727349ae14d921df777a5577c8fb1" id="r_afb2727349ae14d921df777a5577c8fb1"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#afb2727349ae14d921df777a5577c8fb1">setup</a> (void)</td></tr>
<tr class="memitem:a24a675444f8914eb9bbc8bd38df95682" id="r_a24a675444f8914eb9bbc8bd38df95682"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a24a675444f8914eb9bbc8bd38df95682">loop</a> (void)</td></tr>
<tr class="memitem:aa927683a9cbbeed045b742cf7127c428" id="r_aa927683a9cbbeed045b742cf7127c428"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aa927683a9cbbeed045b742cf7127c428">end</a> (void)</td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">A few foundational functions for embedded debugging.</div></td></tr>
<tr class="memitem:aa174993fcf84dfc13057742d6a22ef09" id="r_aa174993fcf84dfc13057742d6a22ef09"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aa174993fcf84dfc13057742d6a22ef09">log</a> (const char *fmt,...) CHECKPRINTF_pos2</td></tr>
<tr class="memitem:a2a036d13e5bdf866c3736af78be70718" id="r_a2a036d13e5bdf866c3736af78be70718"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a2a036d13e5bdf866c3736af78be70718">printf</a> (const char *fmt,...) CHECKPRINTF_pos2</td></tr>
<tr class="memitem:aac335c8d8124c33b46abc80e3697771b" id="r_aac335c8d8124c33b46abc80e3697771b"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#aac335c8d8124c33b46abc80e3697771b">debug</a> (void)</td></tr>
<tr class="memitem:accb257177bebdc68f9832da848af24ab" id="r_accb257177bebdc68f9832da848af24ab"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#accb257177bebdc68f9832da848af24ab">debug</a> (bool onoff)</td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Information about the current build.</div></td></tr>
<tr class="memitem:aef8f98f440b7c0b94eb00adb93844ab8" id="r_aef8f98f440b7c0b94eb00adb93844ab8"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#aef8f98f440b7c0b94eb00adb93844ab8">build_isDebug</a> ()</td></tr>
<tr class="memitem:a47a885405830eec85726b2df71cd652c" id="r_a47a885405830eec85726b2df71cd652c"><td class="memItemLeft">unsigned long&#160;</td><td class="memItemRight"><a class="el" href="#a47a885405830eec85726b2df71cd652c">build_version</a> ()</td></tr>
<tr class="memitem:a96d46abfc546800799333debbb58dcc0" id="r_a96d46abfc546800799333debbb58dcc0"><td class="memItemLeft">unsigned long&#160;</td><td class="memItemRight"><a class="el" href="#a96d46abfc546800799333debbb58dcc0">build_UTC</a> ()</td></tr>
<tr class="memitem:ae253defe92fad5cee7b522c8121ce008" id="r_ae253defe92fad5cee7b522c8121ce008"><td class="memItemLeft">unsigned long&#160;</td><td class="memItemRight"><a class="el" href="#ae253defe92fad5cee7b522c8121ce008">build_pushUTC</a> ()</td></tr>
<tr class="memitem:a7b7e5798eb649068941e9032e5a4ac50" id="r_a7b7e5798eb649068941e9032e5a4ac50"><td class="memItemLeft">const char *&#160;</td><td class="memItemRight"><a class="el" href="#a7b7e5798eb649068941e9032e5a4ac50">build_buildRelease</a> ()</td></tr>
<tr class="memitem:a215a6eae1a41be8036f20d41a0cc2d5b" id="r_a215a6eae1a41be8036f20d41a0cc2d5b"><td class="memItemLeft">const char *&#160;</td><td class="memItemRight"><a class="el" href="#a215a6eae1a41be8036f20d41a0cc2d5b">build_buildDate</a> ()</td></tr>
<tr class="memitem:a60d45dc974542f205686c3c801a968df" id="r_a60d45dc974542f205686c3c801a968df"><td class="memItemLeft">const char *&#160;</td><td class="memItemRight"><a class="el" href="#a60d45dc974542f205686c3c801a968df">build_pushDate</a> ()</td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Cell constructors</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>Garbage collection may happen at any time during the execution of the <a class="el" href="classCell.html">Cell</a> constructors. The cell constructors that accept S-expression arguments will protect those arguments from GC during the operation, using the gc root push/pop functions. </p>
</div></td></tr>
<tr class="memitem:a9beeee579b2bfc35cabdecd71587e624" id="r_a9beeee579b2bfc35cabdecd71587e624"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a9beeee579b2bfc35cabdecd71587e624">expand</a> ()</td></tr>
<tr class="memitem:a2809eabb44af7dbe41915000fd8e6908" id="r_a2809eabb44af7dbe41915000fd8e6908"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a2809eabb44af7dbe41915000fd8e6908">tcons</a> (Int_t typ, Word_t a, Word_t b, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a29e559db0aac8843b8ace5f9cd370379" id="r_a29e559db0aac8843b8ace5f9cd370379"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a29e559db0aac8843b8ace5f9cd370379">tcons</a> (Int_t typ, Sexpr_t a, Sexpr_t b, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a36f015662ed557d84c2a711a43f34887" id="r_a36f015662ed557d84c2a711a43f34887"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a36f015662ed557d84c2a711a43f34887">cons</a> (Sexpr_t a, Sexpr_t b, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a256fa30acb8ffe154e6f0953ffaa9628" id="r_a256fa30acb8ffe154e6f0953ffaa9628"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a256fa30acb8ffe154e6f0953ffaa9628">gensym</a> (Sexpr_t env_exec)</td></tr>
<tr class="memitem:acca4657377d79e76892d40a9dc85be22" id="r_acca4657377d79e76892d40a9dc85be22"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#acca4657377d79e76892d40a9dc85be22">gc_root_push</a> (Sexpr_t p)</td></tr>
<tr class="memitem:a6aa5bf20c2c7ae74ccd63f706b907bd7" id="r_a6aa5bf20c2c7ae74ccd63f706b907bd7"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a6aa5bf20c2c7ae74ccd63f706b907bd7">gc_root_pop</a> (Int_t n=1)</td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">A subset of the car/cdr accessors for list cells. This is the subset used within LambLisp.</div></td></tr>
<tr class="memitem:aa0af1d7da9f0ae8eecc6e1d156ad3e13" id="r_aa0af1d7da9f0ae8eecc6e1d156ad3e13"><td class="memItemLeft"><a id="aa0af1d7da9f0ae8eecc6e1d156ad3e13" name="aa0af1d7da9f0ae8eecc6e1d156ad3e13"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>car</b> (Sexpr_t l)</td></tr>
<tr class="memitem:ad66bc3f67738f512e71f4e872b8dad25" id="r_ad66bc3f67738f512e71f4e872b8dad25"><td class="memItemLeft"><a id="ad66bc3f67738f512e71f4e872b8dad25" name="ad66bc3f67738f512e71f4e872b8dad25"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>cdr</b> (Sexpr_t l)</td></tr>
<tr class="memitem:affbe68335eb9e61fd814c8b8ece55037" id="r_affbe68335eb9e61fd814c8b8ece55037"><td class="memItemLeft"><a id="affbe68335eb9e61fd814c8b8ece55037" name="affbe68335eb9e61fd814c8b8ece55037"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>caar</b> (Sexpr_t l)</td></tr>
<tr class="memitem:a1cac2e6ddecb7e3f085adf04965dfc3c" id="r_a1cac2e6ddecb7e3f085adf04965dfc3c"><td class="memItemLeft"><a id="a1cac2e6ddecb7e3f085adf04965dfc3c" name="a1cac2e6ddecb7e3f085adf04965dfc3c"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>cadr</b> (Sexpr_t l)</td></tr>
<tr class="memitem:a3764d49eb5a669d6b232cf8098dda92f" id="r_a3764d49eb5a669d6b232cf8098dda92f"><td class="memItemLeft"><a id="a3764d49eb5a669d6b232cf8098dda92f" name="a3764d49eb5a669d6b232cf8098dda92f"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>cdar</b> (Sexpr_t l)</td></tr>
<tr class="memitem:abc650685d4235b734408196174ae0c4e" id="r_abc650685d4235b734408196174ae0c4e"><td class="memItemLeft"><a id="abc650685d4235b734408196174ae0c4e" name="abc650685d4235b734408196174ae0c4e"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>cddr</b> (Sexpr_t l)</td></tr>
<tr class="memitem:a37b748f76600bedae2b0679d58d9e708" id="r_a37b748f76600bedae2b0679d58d9e708"><td class="memItemLeft"><a id="a37b748f76600bedae2b0679d58d9e708" name="a37b748f76600bedae2b0679d58d9e708"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>caddr</b> (Sexpr_t l)</td></tr>
<tr class="memitem:a7e399312b783fa0f5f0b85dc5ae247d8" id="r_a7e399312b783fa0f5f0b85dc5ae247d8"><td class="memItemLeft"><a id="a7e399312b783fa0f5f0b85dc5ae247d8" name="a7e399312b783fa0f5f0b85dc5ae247d8"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>cdddr</b> (Sexpr_t l)</td></tr>
<tr class="memitem:aef2860187e1916daafe828a8f5e31ee0" id="r_aef2860187e1916daafe828a8f5e31ee0"><td class="memItemLeft"><a id="aef2860187e1916daafe828a8f5e31ee0" name="aef2860187e1916daafe828a8f5e31ee0"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>cadddr</b> (Sexpr_t l)</td></tr>
<tr class="memitem:a4f8de629ee77bf264c34129e968ffcd2" id="r_a4f8de629ee77bf264c34129e968ffcd2"><td class="memItemLeft"><a id="a4f8de629ee77bf264c34129e968ffcd2" name="a4f8de629ee77bf264c34129e968ffcd2"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>cddddr</b> (Sexpr_t l)</td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">The "bang" functions are the "mutators" of GC literature.</div></td></tr>
<tr class="memitem:af67e288ddedf61aa4e3960031cdd1e1a" id="r_af67e288ddedf61aa4e3960031cdd1e1a"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#af67e288ddedf61aa4e3960031cdd1e1a">set_car_bang</a> (Sexpr_t c, Sexpr_t val)</td></tr>
<tr class="memitem:a7df100ee91d8e28fe3eec41a07bc1911" id="r_a7df100ee91d8e28fe3eec41a07bc1911"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a7df100ee91d8e28fe3eec41a07bc1911">set_cdr_bang</a> (Sexpr_t c, Sexpr_t val)</td></tr>
<tr class="memitem:aede13d19ee7f41767ac3b93b4f1b2d9f" id="r_aede13d19ee7f41767ac3b93b4f1b2d9f"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aede13d19ee7f41767ac3b93b4f1b2d9f">vector_set_bang</a> (Sexpr_t vec, Int_t k, Sexpr_t val)</td></tr>
<tr class="memitem:a4990161fdb806f5f4a080c77eedaf0f0" id="r_a4990161fdb806f5f4a080c77eedaf0f0"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a4990161fdb806f5f4a080c77eedaf0f0">reverse_bang</a> (Sexpr_t l)</td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Equivalence tests and sequential search</div></td></tr>
<tr class="memitem:a2c95851876043ded3da4ca4faaf8f5a4" id="r_a2c95851876043ded3da4ca4faaf8f5a4"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a2c95851876043ded3da4ca4faaf8f5a4">eq_q</a> (Sexpr_t obj1, Sexpr_t obj2)</td></tr>
<tr class="memitem:a25eb1361fcd92d5f1cad240ee068ce97" id="r_a25eb1361fcd92d5f1cad240ee068ce97"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a25eb1361fcd92d5f1cad240ee068ce97">eqv_q</a> (Sexpr_t obj1, Sexpr_t obj2)</td></tr>
<tr class="memitem:a8efb889bc900669b178001cdc6941354" id="r_a8efb889bc900669b178001cdc6941354"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a8efb889bc900669b178001cdc6941354">equal_q</a> (Sexpr_t obj1, Sexpr_t obj2)</td></tr>
<tr class="memitem:a12396fb0a2a3d57dd085df40da87c164" id="r_a12396fb0a2a3d57dd085df40da87c164"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a12396fb0a2a3d57dd085df40da87c164">assq</a> (Sexpr_t obj, Sexpr_t alist)</td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Interned symbols</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>There are just a few operations on symbols:</p><ul>
<li><p class="startli">Remember a new symbol.</p>
</li>
<li><p class="startli">Check if symbol has already been seen.</p>
</li>
<li><p class="startli">Compare 2 symbols for equality.</p>
</li>
<li><p class="startli">At evaluation time, lookup the symbol in the <em>current environment</em>.</p>
</li>
</ul>
<p>For best performance, symbols in LambLisp are <em>interned</em>. This means a single copy of the symbol's characters are stored in a data structure containing the set of all <em>interned symbols</em>. Once interned, symbols can be tested for equality by address rather than character-by-character.</p>
<p>Traditionally, the data structure was called <em>oblist</em> if an association list was used, or called <em>obarray</em> if an array was used. Arrays allow for a hash table implementation, which greatly reduces search time, and can be further optimized if the array size is a power of 2 (2^n).</p>
<p>LambLisp uses the term <em>oblist</em> for the interned symbol table, implemented using a 2^n hash table. Symbol hashes are computed only once and are stored with the symbol, speeding runtime lookups. </p>
</div></td></tr>
<tr class="memitem:a118e8da7e6c4d29788c616c7dbfba610" id="r_a118e8da7e6c4d29788c616c7dbfba610"><td class="memItemLeft"><a id="a118e8da7e6c4d29788c616c7dbfba610" name="a118e8da7e6c4d29788c616c7dbfba610"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>oblist_query</b> (Sexpr_t oblist, const char *identifier, Bool_t force, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a08341114c24f962da6bca5470d789226" id="r_a08341114c24f962da6bca5470d789226"><td class="memItemLeft"><a id="a08341114c24f962da6bca5470d789226" name="a08341114c24f962da6bca5470d789226"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>oblist_test</b> (Sexpr_t oblist, const char *identifier, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a3260672f14ee1b3312cf6c59226418b2" id="r_a3260672f14ee1b3312cf6c59226418b2"><td class="memItemLeft"><a id="a3260672f14ee1b3312cf6c59226418b2" name="a3260672f14ee1b3312cf6c59226418b2"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>oblist_intern</b> (Sexpr_t oblist, const char *identifier, Sexpr_t env_exec)</td></tr>
<tr class="memitem:acea095af910388483588b9349d3b2f76" id="r_acea095af910388483588b9349d3b2f76"><td class="memItemLeft"><a id="acea095af910388483588b9349d3b2f76" name="acea095af910388483588b9349d3b2f76"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>oblist_analyze</b> (Sexpr_t oblist, Int_t verbosity, Sexpr_t env_exec)</td></tr>
<tr id="pub-methods-8" class="groupHeader"><td colspan="2"><div class="groupHeader">Hierarchical Dictionary type</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>LambLisp's high-performance hierarchical dictionary implementation is used internally to represent the runtime environment. Dictionaries are also directly usable in the Lisp applications, and the dictionary data type is the basis for the LambLisp Object System (LOBS). </p>
</div></td></tr>
<tr class="memitem:ae746ee259f35deb8edbe8e8b9c03999e" id="r_ae746ee259f35deb8edbe8e8b9c03999e"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#ae746ee259f35deb8edbe8e8b9c03999e">dict_new</a> (Int_t framesize, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ac40867630c1ed1b9292f213ef773cc23" id="r_ac40867630c1ed1b9292f213ef773cc23"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#ac40867630c1ed1b9292f213ef773cc23">dict_new</a> (Sexpr_t env_exec)</td></tr>
<tr class="memitem:a3a6ea3bfac24c67ec7ed9fefec7149e9" id="r_a3a6ea3bfac24c67ec7ed9fefec7149e9"><td class="memItemLeft"><a id="a3a6ea3bfac24c67ec7ed9fefec7149e9" name="a3a6ea3bfac24c67ec7ed9fefec7149e9"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>dict_add_empty_frame</b> (Sexpr_t dict, Int_t framesize, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a8d058d659552023cade51553bcad7c65" id="r_a8d058d659552023cade51553bcad7c65"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a8d058d659552023cade51553bcad7c65">dict_add_empty_frame</a> (Sexpr_t dict, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ace672ca89aa77258b0740e69469088d6" id="r_ace672ca89aa77258b0740e69469088d6"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#ace672ca89aa77258b0740e69469088d6">dict_add_keyval_frame</a> (Sexpr_t dict, Sexpr_t keys, Sexpr_t vals, Sexpr_t env_exec)</td></tr>
<tr class="memitem:aaddd2546ce874edc72ec8230a2b61cd0" id="r_aaddd2546ce874edc72ec8230a2b61cd0"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#aaddd2546ce874edc72ec8230a2b61cd0">dict_add_alist_frame</a> (Sexpr_t dict, Sexpr_t alist, Sexpr_t env_exec)</td></tr>
<tr class="memitem:acb296d231e3d05b1edc117a1e67f4638" id="r_acb296d231e3d05b1edc117a1e67f4638"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#acb296d231e3d05b1edc117a1e67f4638">dict_bind_bang</a> (Sexpr_t dict, Sexpr_t key, Sexpr_t value, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ad2c047480a9250592e981b33a0ceb188" id="r_ad2c047480a9250592e981b33a0ceb188"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#ad2c047480a9250592e981b33a0ceb188">dict_rebind_bang</a> (Sexpr_t dict, Sexpr_t key, Sexpr_t value, Sexpr_t env_exec)</td></tr>
<tr class="memitem:aacf595cc8339d6123b94f100fc447f2b" id="r_aacf595cc8339d6123b94f100fc447f2b"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aacf595cc8339d6123b94f100fc447f2b">dict_bind_alist_bang</a> (Sexpr_t dict, Sexpr_t alist, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ab365d7e1bda470277e3986555a3005bd" id="r_ab365d7e1bda470277e3986555a3005bd"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#ab365d7e1bda470277e3986555a3005bd">dict_rebind_alist_bang</a> (Sexpr_t dict, Sexpr_t alist, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a90cdf1a6ccb69c9198e7779ff0c71317" id="r_a90cdf1a6ccb69c9198e7779ff0c71317"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a90cdf1a6ccb69c9198e7779ff0c71317">dict_ref_q</a> (Sexpr_t dict, Sexpr_t key)</td></tr>
<tr class="memitem:aade8fb852aa5ea06024ae250d80ddf3f" id="r_aade8fb852aa5ea06024ae250d80ddf3f"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#aade8fb852aa5ea06024ae250d80ddf3f">dict_ref</a> (Sexpr_t dict, Sexpr_t key)</td></tr>
<tr class="memitem:aad8ad0f4b9ccf82019a2ea9bb058eb4d" id="r_aad8ad0f4b9ccf82019a2ea9bb058eb4d"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#aad8ad0f4b9ccf82019a2ea9bb058eb4d">dict_keys</a> (Sexpr_t dict, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a3b5bf69d1ef926a0dcc6f650b0192311" id="r_a3b5bf69d1ef926a0dcc6f650b0192311"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a3b5bf69d1ef926a0dcc6f650b0192311">dict_values</a> (Sexpr_t dict, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a9ab88bc97fe713a60d5e52865a2592db" id="r_a9ab88bc97fe713a60d5e52865a2592db"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a9ab88bc97fe713a60d5e52865a2592db">dict_to_alist</a> (Sexpr_t dict, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a8a9a1d8df1493b320cc676f8e74f4752" id="r_a8a9a1d8df1493b320cc676f8e74f4752"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a8a9a1d8df1493b320cc676f8e74f4752">dict_to_2list</a> (Sexpr_t dict, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a17a118ef0820f32f2d99839c983ce701" id="r_a17a118ef0820f32f2d99839c983ce701"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a17a118ef0820f32f2d99839c983ce701">alist_to_dict</a> (Sexpr_t alist, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a84e5e5d26ee7c66ff09af4f9f5c5497d" id="r_a84e5e5d26ee7c66ff09af4f9f5c5497d"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a84e5e5d26ee7c66ff09af4f9f5c5497d">twolist_to_dict</a> (Sexpr_t twolist, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ad8f788ab9ebf9bbc257c4b2748a8d593" id="r_ad8f788ab9ebf9bbc257c4b2748a8d593"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#ad8f788ab9ebf9bbc257c4b2748a8d593">dict_analyze</a> (Sexpr_t dict, Int_t verbosity=0)</td></tr>
<tr id="pub-methods-9" class="groupHeader"><td colspan="2"><div class="groupHeader">Reading and writing</div></td></tr>
<tr class="memitem:ad5250cc39c9d66f782fbe888f00e761e" id="r_ad5250cc39c9d66f782fbe888f00e761e"><td class="memItemLeft"><a id="ad5250cc39c9d66f782fbe888f00e761e" name="ad5250cc39c9d66f782fbe888f00e761e"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>read</b> (LL_Port &amp;src, Sexpr_t env_exec)</td></tr>
<tr class="memitem:aeb5d84c6aa8f544e41a98e6586530e5a" id="r_aeb5d84c6aa8f544e41a98e6586530e5a"><td class="memItemLeft"><a id="aeb5d84c6aa8f544e41a98e6586530e5a" name="aeb5d84c6aa8f544e41a98e6586530e5a"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>write_or_display</b> (Sexpr_t sexpr, Bool_t do_write)</td></tr>
<tr class="memitem:ab7adc7e908f71ffe1509c55d4a7486e0" id="r_ab7adc7e908f71ffe1509c55d4a7486e0"><td class="memItemLeft"><a id="ab7adc7e908f71ffe1509c55d4a7486e0" name="ab7adc7e908f71ffe1509c55d4a7486e0"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>write_simple</b> (Sexpr_t sexpr)</td></tr>
<tr class="memitem:a5d678dafafb0b9df79a5837c05c0dd8d" id="r_a5d678dafafb0b9df79a5837c05c0dd8d"><td class="memItemLeft"><a id="a5d678dafafb0b9df79a5837c05c0dd8d" name="a5d678dafafb0b9df79a5837c05c0dd8d"></a>
String&#160;</td><td class="memItemRight"><b>sprintf</b> (Charst_t fmt, Sexpr_t sexpr, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a2c26dcbb0c5709692892a8ecb405a95b" id="r_a2c26dcbb0c5709692892a8ecb405a95b"><td class="memItemLeft"><a id="a2c26dcbb0c5709692892a8ecb405a95b" name="a2c26dcbb0c5709692892a8ecb405a95b"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>printf</b> (Sexpr_t args, LL_Port &amp;outp)</td></tr>
<tr class="memitem:a1d0deec24618d60becf9261fa5f1d106" id="r_a1d0deec24618d60becf9261fa5f1d106"><td class="memItemLeft"><a id="a1d0deec24618d60becf9261fa5f1d106" name="a1d0deec24618d60becf9261fa5f1d106"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>printf</b> (Sexpr_t args)</td></tr>
<tr id="pub-methods-10" class="groupHeader"><td colspan="2"><div class="groupHeader">Evaluation and function application</div></td></tr>
<tr class="memitem:a62684ca4e1d99334efa9a929ba71a336" id="r_a62684ca4e1d99334efa9a929ba71a336"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a62684ca4e1d99334efa9a929ba71a336">quasiquote</a> (Sexpr_t sexpr, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ae2128177edc320bb4a340149c8783793" id="r_ae2128177edc320bb4a340149c8783793"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#ae2128177edc320bb4a340149c8783793">eval</a> (Sexpr_t sexpr, Sexpr_t env_exec)</td></tr>
<tr class="memitem:aa0945d032c8c0e9a76276b39aeb88e84" id="r_aa0945d032c8c0e9a76276b39aeb88e84"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#aa0945d032c8c0e9a76276b39aeb88e84">eval_list</a> (Sexpr_t args, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a08b628887841c154f312696440158c5f" id="r_a08b628887841c154f312696440158c5f"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a08b628887841c154f312696440158c5f">apply_proc_partial</a> (Sexpr_t proc, Sexpr_t sexpr, Sexpr_t env_exec)</td></tr>
<tr class="memitem:af94560296430fe61a8deafe4e8861b0f" id="r_af94560296430fe61a8deafe4e8861b0f"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#af94560296430fe61a8deafe4e8861b0f">map_proc</a> (Sexpr_t proc, Sexpr_t lists, Sexpr_t env_exec)</td></tr>
<tr id="pub-methods-11" class="groupHeader"><td colspan="2"><div class="groupHeader">Querying underlying system features defined by Scheme.</div></td></tr>
<tr class="memitem:a13a810bc849cb8dd078cc17ab8cb9b8e" id="r_a13a810bc849cb8dd078cc17ab8cb9b8e"><td class="memItemLeft"><a id="a13a810bc849cb8dd078cc17ab8cb9b8e" name="a13a810bc849cb8dd078cc17ab8cb9b8e"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>r5_base_environment</b> ()</td></tr>
<tr class="memitem:aa77c25ae64f506e12d24c1338ed02925" id="r_aa77c25ae64f506e12d24c1338ed02925"><td class="memItemLeft"><a id="aa77c25ae64f506e12d24c1338ed02925" name="aa77c25ae64f506e12d24c1338ed02925"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>r5_interaction_environment</b> ()</td></tr>
<tr class="memitem:a9c301ce9f6342f4dcd9c479fc22597dc" id="r_a9c301ce9f6342f4dcd9c479fc22597dc"><td class="memItemLeft"><a id="a9c301ce9f6342f4dcd9c479fc22597dc" name="a9c301ce9f6342f4dcd9c479fc22597dc"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>lamb_oblist</b> ()</td></tr>
<tr class="memitem:a389deebcaeb354fee7e4ec52d3867701" id="r_a389deebcaeb354fee7e4ec52d3867701"><td class="memItemLeft"><a id="a389deebcaeb354fee7e4ec52d3867701" name="a389deebcaeb354fee7e4ec52d3867701"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>current_input_port</b> ()</td></tr>
<tr class="memitem:a9d4ecc9f969c8ea8c4fb90fb851bf3ee" id="r_a9d4ecc9f969c8ea8c4fb90fb851bf3ee"><td class="memItemLeft"><a id="a9d4ecc9f969c8ea8c4fb90fb851bf3ee" name="a9d4ecc9f969c8ea8c4fb90fb851bf3ee"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>current_output_port</b> ()</td></tr>
<tr class="memitem:a3991c78d860bcdb46abbc695193c0c5f" id="r_a3991c78d860bcdb46abbc695193c0c5f"><td class="memItemLeft"><a id="a3991c78d860bcdb46abbc695193c0c5f" name="a3991c78d860bcdb46abbc695193c0c5f"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>current_error_port</b> ()</td></tr>
<tr id="pub-methods-12" class="groupHeader"><td colspan="2"><div class="groupHeader">Useful list processing used internally by the LambLisp virtual machine.</div></td></tr>
<tr class="memitem:a5daa14c0801aad22eeae0eb861842058" id="r_a5daa14c0801aad22eeae0eb861842058"><td class="memItemLeft"><a id="a5daa14c0801aad22eeae0eb861842058" name="a5daa14c0801aad22eeae0eb861842058"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>append</b> (Sexpr_t sexpr, Sexpr_t env_exec)</td></tr>
<tr class="memitem:aec197c7ef2f90c21cfb4a8b20ab6e3ed" id="r_aec197c7ef2f90c21cfb4a8b20ab6e3ed"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#aec197c7ef2f90c21cfb4a8b20ab6e3ed">append2</a> (Sexpr_t lis, Sexpr_t obj, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a44e943f8d6bce3fbb01410889165ced3" id="r_a44e943f8d6bce3fbb01410889165ced3"><td class="memItemLeft"><a id="a44e943f8d6bce3fbb01410889165ced3" name="a44e943f8d6bce3fbb01410889165ced3"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>list_copy</b> (Sexpr_t sexpr, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a5737a80fc54bec9a9f215f03d1536854" id="r_a5737a80fc54bec9a9f215f03d1536854"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a5737a80fc54bec9a9f215f03d1536854">list_analyze</a> (Sexpr_t sexpr, Sexpr_t env_exec)</td></tr>
<tr class="memitem:afd99d40ada4dbd101b7dbb51e8f3f990" id="r_afd99d40ada4dbd101b7dbb51e8f3f990"><td class="memItemLeft"><a id="afd99d40ada4dbd101b7dbb51e8f3f990" name="afd99d40ada4dbd101b7dbb51e8f3f990"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>list_to_vector</b> (Sexpr_t l, Sexpr_t env_exec)</td></tr>
<tr class="memitem:acdb4daf5b2d24c1fe398b2c8b92d5161" id="r_acdb4daf5b2d24c1fe398b2c8b92d5161"><td class="memItemLeft"><a id="acdb4daf5b2d24c1fe398b2c8b92d5161" name="acdb4daf5b2d24c1fe398b2c8b92d5161"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>vector_to_list</b> (Sexpr_t v, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a745cd62f35fd7094dd3900263f0e66b3" id="r_a745cd62f35fd7094dd3900263f0e66b3"><td class="memItemLeft"><a id="a745cd62f35fd7094dd3900263f0e66b3" name="a745cd62f35fd7094dd3900263f0e66b3"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>vector_copy</b> (Sexpr_t from, Sexpr_t env_exec)</td></tr>
<tr id="pub-methods-13" class="groupHeader"><td colspan="2"><div class="groupHeader">Sparse vectors</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>The sparse vector representation is a sorted association list, in which the car of each pair is the vector index and the cdr is the vector value at that index. </p>
</div></td></tr>
<tr class="memitem:acd66456d079eba63389c9695c2d100cd" id="r_acd66456d079eba63389c9695c2d100cd"><td class="memItemLeft"><a id="acd66456d079eba63389c9695c2d100cd" name="acd66456d079eba63389c9695c2d100cd"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>vector_to_sparsevec</b> (Sexpr_t vec, Sexpr_t skip, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a09dabae5edacc08c4b5f9d7c1ff5c8c2" id="r_a09dabae5edacc08c4b5f9d7c1ff5c8c2"><td class="memItemLeft"><a id="a09dabae5edacc08c4b5f9d7c1ff5c8c2" name="a09dabae5edacc08c4b5f9d7c1ff5c8c2"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>sparsevec_to_vector</b> (Sexpr_t alist, Sexpr_t fill, Sexpr_t env_exec)</td></tr>
<tr id="pub-methods-14" class="groupHeader"><td colspan="2"><div class="groupHeader">Makers for error types</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These functions will sprintf a message into a buffer, and return an error object containing the message. They differ in that one (mk_error) creates a new error object, and the other (mk_syserror) avoids use of the memory manager by reusing the system error singleton. </p>
</div></td></tr>
<tr class="memitem:af06199f7adaa96a9db06a2db66d06023" id="r_af06199f7adaa96a9db06a2db66d06023"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#af06199f7adaa96a9db06a2db66d06023">mk_error</a> (Sexpr_t env_exec, Sexpr_t irritants, const char *fmt,...) CHECKPRINTF_pos4</td></tr>
<tr class="memitem:afd00b10ada1aae47b4e7dd6bc2c87d02" id="r_afd00b10ada1aae47b4e7dd6bc2c87d02"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#afd00b10ada1aae47b4e7dd6bc2c87d02">mk_error</a> (Sexpr_t env_exec, const char *fmt,...) CHECKPRINTF_pos3</td></tr>
<tr class="memitem:a9cf3c8f4c0a27f1c588f46cb71f2999d" id="r_a9cf3c8f4c0a27f1c588f46cb71f2999d"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a9cf3c8f4c0a27f1c588f46cb71f2999d">mk_syserror</a> (const char *fmt,...) CHECKPRINTF_pos2</td></tr>
<tr class="memitem:a0019fef1005d1dc5fbc3612f8896d2fd" id="r_a0019fef1005d1dc5fbc3612f8896d2fd"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a0019fef1005d1dc5fbc3612f8896d2fd">mk_syserror</a> (Sexpr_t irritants, const char *fmt,...) CHECKPRINTF_pos3</td></tr>
<tr id="pub-methods-15" class="groupHeader"><td colspan="2"><div class="groupHeader">Makers for simple compact types with embedded values, without external storage or dependencies</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These types all have their values embedded in the <a class="el" href="classCell.html">Cell</a>. Note that other types may also hold immediate values, but are "less simple" because they are C++ subtypes that are variations on the <em>Lisp</em>-declared types. </p>
</div></td></tr>
<tr class="memitem:a52971b88a3717a11997289ce18296934" id="r_a52971b88a3717a11997289ce18296934"><td class="memItemLeft"><a id="a52971b88a3717a11997289ce18296934" name="a52971b88a3717a11997289ce18296934"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_bool</b> (Bool_t b, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ac2239066a108b296491917255be7daff" id="r_ac2239066a108b296491917255be7daff"><td class="memItemLeft"><a id="ac2239066a108b296491917255be7daff" name="ac2239066a108b296491917255be7daff"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_character</b> (Char_t ch, Sexpr_t env_exec)</td></tr>
<tr class="memitem:afb6d8629210e2d1ab05e7ffe310e51a1" id="r_afb6d8629210e2d1ab05e7ffe310e51a1"><td class="memItemLeft"><a id="afb6d8629210e2d1ab05e7ffe310e51a1" name="afb6d8629210e2d1ab05e7ffe310e51a1"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_integer</b> (Int_t i, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a38eb1970152468fb7650425c9bbcbcfa" id="r_a38eb1970152468fb7650425c9bbcbcfa"><td class="memItemLeft"><a id="a38eb1970152468fb7650425c9bbcbcfa" name="a38eb1970152468fb7650425c9bbcbcfa"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_real</b> (Real_t r, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a367287da4e277fa3f9f85f2ed52df09d" id="r_a367287da4e277fa3f9f85f2ed52df09d"><td class="memItemLeft"><a id="a367287da4e277fa3f9f85f2ed52df09d" name="a367287da4e277fa3f9f85f2ed52df09d"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_number</b> (Charst_t str, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a05941882bdb4c49b219347911515f13e" id="r_a05941882bdb4c49b219347911515f13e"><td class="memItemLeft"><a id="a05941882bdb4c49b219347911515f13e" name="a05941882bdb4c49b219347911515f13e"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_sharp_const</b> (Charst_t name, Sexpr_t env_exec)</td></tr>
<tr id="pub-methods-16" class="groupHeader"><td colspan="2"><div class="groupHeader">Makers for heap storage types</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>In principle, these types require space from the system heap. At GC time, they may also require specialized marking, and also specialized sweeping.</p>
<p>As an optimization, <em>LambLisp</em> also implements <b>immediate</b> types. When the size required for the object is small, the internal bytes of the <a class="el" href="classCell.html">Cell</a> can be used to hold the contents, avoiding heap operations. Using immediate types in this way has been common practice for integers and real numbers. LambLisp makes some additional use of immediate types. Immediate types are a LambLisp internal optimization, and they are all subtypes of the main <em>Lisp</em> type.</p>
<p>The types that employ the <em>immediate</em> optimization are:</p><ul>
<li><p class="startli">strings, providing up to 9 content bytes plus trailing 0 (32 bit word) or 22 content bytes (64 bit).</p>
</li>
<li><p class="startli">bytevectors a count plus up to 9 or 22 content bytes.</p>
</li>
<li><p class="startli">vectors of length 0, 1 or 2.</p>
</li>
</ul>
<p>There are also <b>EXTERNAL</b> versions of those data types. These data types can be used to accesss data that should not be garbage collected, such as data contained in the application image, or C++ objects provided by another application.</p>
<p>A variant of the EXTERNAL types is also provided, so that objects created in C++ can be passed to LambLisp, along with an optional <em>deleter function</em>. In C++, the deleter is best implemented as a one-line C++ lambda function accepting 1 argument (a void* pointer to a C++ object). The deleter function casts the void* pointer to match the C++ object type, and applies the C++ <em>delete</em> or <em>delete[]</em> operators to free the object space and any dependent resources.</p>
<p>By passing the C++ objects to LambLisp, they can be automatically garbage collected when LambLisp has finished with them. </p>
</div></td></tr>
<tr class="memitem:a7e533f9a2c11434f88ea3a2ebec1f5da" id="r_a7e533f9a2c11434f88ea3a2ebec1f5da"><td class="memItemLeft"><a id="a7e533f9a2c11434f88ea3a2ebec1f5da" name="a7e533f9a2c11434f88ea3a2ebec1f5da"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_string</b> (Sexpr_t env_exec, const char *fmt,...) CHECKPRINTF_pos3</td></tr>
<tr class="memitem:af8d73e0d3d1f45d1e037986adeb38791" id="r_af8d73e0d3d1f45d1e037986adeb38791"><td class="memItemLeft"><a id="af8d73e0d3d1f45d1e037986adeb38791" name="af8d73e0d3d1f45d1e037986adeb38791"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_string</b> (Int_t k, Charst_t src, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ac76b72e36b287f9bd559f9203e8fda36" id="r_ac76b72e36b287f9bd559f9203e8fda36"><td class="memItemLeft"><a id="ac76b72e36b287f9bd559f9203e8fda36" name="ac76b72e36b287f9bd559f9203e8fda36"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_string</b> (String s, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a4c6354f3fc9a55bcd1f3d233b38b4685" id="r_a4c6354f3fc9a55bcd1f3d233b38b4685"><td class="memItemLeft"><a id="a4c6354f3fc9a55bcd1f3d233b38b4685" name="a4c6354f3fc9a55bcd1f3d233b38b4685"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_symbol_or_number</b> (Charst_t str, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a429c9c926b2e292696b50184ac34d433" id="r_a429c9c926b2e292696b50184ac34d433"><td class="memItemLeft"><a id="a429c9c926b2e292696b50184ac34d433" name="a429c9c926b2e292696b50184ac34d433"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_symbol</b> (Charst_t str, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a4436c845b50e5c2b90ac578b2dcd7062" id="r_a4436c845b50e5c2b90ac578b2dcd7062"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a4436c845b50e5c2b90ac578b2dcd7062">mk_bytevector</a> (Int_t k, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a3dd18d5af752246c9787df88dddc0b8c" id="r_a3dd18d5af752246c9787df88dddc0b8c"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a3dd18d5af752246c9787df88dddc0b8c">mk_bytevector</a> (Int_t k, Bytest_t src, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a5b8ec660aca35f120b91995c2e22e70f" id="r_a5b8ec660aca35f120b91995c2e22e70f"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a5b8ec660aca35f120b91995c2e22e70f">mk_bytevector</a> (Int_t k, Int_t fill, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a088e2a3ae214cba206e1e9eb7a15891c" id="r_a088e2a3ae214cba206e1e9eb7a15891c"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a088e2a3ae214cba206e1e9eb7a15891c">mk_bytevector_ext</a> (Int_t k, Bytest_t ext, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a951b513180e8a23fcbd2c1d52bd155de" id="r_a951b513180e8a23fcbd2c1d52bd155de"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a951b513180e8a23fcbd2c1d52bd155de">mk_intvector</a> (Int_t k, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a221cf5302ff753c237bf0b8380ceb329" id="r_a221cf5302ff753c237bf0b8380ceb329"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a221cf5302ff753c237bf0b8380ceb329">mk_realvector</a> (Int_t k, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ae82a727cfc95c0aa3593cd163a8ea305" id="r_ae82a727cfc95c0aa3593cd163a8ea305"><td class="memItemLeft"><a id="ae82a727cfc95c0aa3593cd163a8ea305" name="ae82a727cfc95c0aa3593cd163a8ea305"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_intvector</b> (Int_t k, Int_t fill, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a37270c548a2f2ba74a929bec03ac0138" id="r_a37270c548a2f2ba74a929bec03ac0138"><td class="memItemLeft"><a id="a37270c548a2f2ba74a929bec03ac0138" name="a37270c548a2f2ba74a929bec03ac0138"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_realvector</b> (Int_t k, Real_t fill, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a77ef99ee03e8a086ade8d47db51b30a1" id="r_a77ef99ee03e8a086ade8d47db51b30a1"><td class="memItemLeft"><a id="a77ef99ee03e8a086ade8d47db51b30a1" name="a77ef99ee03e8a086ade8d47db51b30a1"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_vector</b> (Int_t len, Sexpr_t fill, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ac048a23054f0a5a1ba95373c54778475" id="r_ac048a23054f0a5a1ba95373c54778475"><td class="memItemLeft"><a id="ac048a23054f0a5a1ba95373c54778475" name="ac048a23054f0a5a1ba95373c54778475"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_hashtbl</b> (Int_t len, Sexpr_t fill, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ab97c55c15ff2896f0e2f97d337f2f4b4" id="r_ab97c55c15ff2896f0e2f97d337f2f4b4"><td class="memItemLeft"><a id="ab97c55c15ff2896f0e2f97d337f2f4b4" name="ab97c55c15ff2896f0e2f97d337f2f4b4"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_serial_port</b> (Sexpr_t env_exec)</td></tr>
<tr class="memitem:a64134d2729c00a89ce84f2d1bc5ecdc1" id="r_a64134d2729c00a89ce84f2d1bc5ecdc1"><td class="memItemLeft"><a id="a64134d2729c00a89ce84f2d1bc5ecdc1" name="a64134d2729c00a89ce84f2d1bc5ecdc1"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_input_file_port</b> (Charst_t name, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a57863f133ae105c015da3c51316139f5" id="r_a57863f133ae105c015da3c51316139f5"><td class="memItemLeft"><a id="a57863f133ae105c015da3c51316139f5" name="a57863f133ae105c015da3c51316139f5"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_output_file_port</b> (Charst_t name, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a9dfd68da350bf0ae926dfed8a753c9e2" id="r_a9dfd68da350bf0ae926dfed8a753c9e2"><td class="memItemLeft"><a id="a9dfd68da350bf0ae926dfed8a753c9e2" name="a9dfd68da350bf0ae926dfed8a753c9e2"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_input_string_port</b> (Charst_t inp, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a469758e4d115f5a690f68a9c0fa028b7" id="r_a469758e4d115f5a690f68a9c0fa028b7"><td class="memItemLeft"><a id="a469758e4d115f5a690f68a9c0fa028b7" name="a469758e4d115f5a690f68a9c0fa028b7"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_output_string_port</b> (Sexpr_t env_exec)</td></tr>
<tr id="pub-methods-17" class="groupHeader"><td colspan="2"><div class="groupHeader">Makers for interface to native procedures and C++ objects.</div></td></tr>
<tr class="memitem:a42c54af1afa0102a7c2f65d4eb37ea0e" id="r_a42c54af1afa0102a7c2f65d4eb37ea0e"><td class="memItemLeft"><a id="a42c54af1afa0102a7c2f65d4eb37ea0e" name="a42c54af1afa0102a7c2f65d4eb37ea0e"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_Mop3_procst_t</b> (<a class="el" href="#a1f2e3ba9db4055bd60f1e765b9ecfaf4">Mop3st_t</a> f, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a777df391b9a517f42df59d24d7abed64" id="r_a777df391b9a517f42df59d24d7abed64"><td class="memItemLeft"><a id="a777df391b9a517f42df59d24d7abed64" name="a777df391b9a517f42df59d24d7abed64"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_Mop3_nprocst_t</b> (<a class="el" href="#a1f2e3ba9db4055bd60f1e765b9ecfaf4">Mop3st_t</a> f, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a19dae2d1ada42030c2413dd28fc3d944" id="r_a19dae2d1ada42030c2413dd28fc3d944"><td class="memItemLeft"><a id="a19dae2d1ada42030c2413dd28fc3d944" name="a19dae2d1ada42030c2413dd28fc3d944"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_cppobj</b> (void *obj, CPPDeleterPtr deleter, Sexpr_t env_exec)</td></tr>
<tr id="pub-methods-18" class="groupHeader"><td colspan="2"><div class="groupHeader">Makers for pair types.</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These <b>pair</b> types all have the same structure for construction and garbage collection purposes, but are not <em>Scheme pair</em> types. LambLisp*'s scalable type system presents opportunities for efficiency when implementing common operations on lists. These are executed by the <em>LambLisp</em> virtual machine at C++ speed, rather than at the slower speed of the <em>Lisp</em> evaluation loop.</p>
<ul>
<li><p class="startli">procedures ... the evaluator must be able to identify these directly.</p>
</li>
<li><p class="startli">dictionaries ... often containing cycles when used as environments, so a depth limit is imposed when traversing.</p>
</li>
<li><p class="startli">thunks ... used in combination with the trampoline technique to implement tail recursion.</p>
</li>
</ul>
<p>Note that there is no need for mk_pair(), it is just <a class="el" href="#a36f015662ed557d84c2a711a43f34887" title="Cell constructor for normal pairs.">cons()</a>. </p>
</div></td></tr>
<tr class="memitem:a86cc06bf803a591d8f9ed594995109f0" id="r_a86cc06bf803a591d8f9ed594995109f0"><td class="memItemLeft"><a id="a86cc06bf803a591d8f9ed594995109f0" name="a86cc06bf803a591d8f9ed594995109f0"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_macro</b> (Sexpr_t nlam, Sexpr_t env_nlam, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ab86201f8f79fcb4a8dda7bb223f60597" id="r_ab86201f8f79fcb4a8dda7bb223f60597"><td class="memItemLeft"><a id="ab86201f8f79fcb4a8dda7bb223f60597" name="ab86201f8f79fcb4a8dda7bb223f60597"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_procedure</b> (Sexpr_t formals, Sexpr_t body, Sexpr_t env_proc, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a633ff61ee82702aeadd9c2f00ab94447" id="r_a633ff61ee82702aeadd9c2f00ab94447"><td class="memItemLeft"><a id="a633ff61ee82702aeadd9c2f00ab94447" name="a633ff61ee82702aeadd9c2f00ab94447"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_nprocedure</b> (Sexpr_t formals, Sexpr_t body, Sexpr_t env_nproc, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a47d4c356bc9b7aaf6da3e0eab79cfae6" id="r_a47d4c356bc9b7aaf6da3e0eab79cfae6"><td class="memItemLeft"><a id="a47d4c356bc9b7aaf6da3e0eab79cfae6" name="a47d4c356bc9b7aaf6da3e0eab79cfae6"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_thunk_sexpr</b> (Sexpr_t sexpr, Sexpr_t env_thunk, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a840d7b20dc62e9e8383c8138b50f71cb" id="r_a840d7b20dc62e9e8383c8138b50f71cb"><td class="memItemLeft"><a id="a840d7b20dc62e9e8383c8138b50f71cb" name="a840d7b20dc62e9e8383c8138b50f71cb"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_thunk_body</b> (Sexpr_t body, Sexpr_t env_thunk, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a646d6e2914e19b657df0552268f644fd" id="r_a646d6e2914e19b657df0552268f644fd"><td class="memItemLeft"><a id="a646d6e2914e19b657df0552268f644fd" name="a646d6e2914e19b657df0552268f644fd"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_dict</b> (Sexpr_t frame, Sexpr_t base, Sexpr_t env_exec)</td></tr>
<tr class="memitem:aee2771d71a0847756cf5eb53d562c28b" id="r_aee2771d71a0847756cf5eb53d562c28b"><td class="memItemLeft"><a id="aee2771d71a0847756cf5eb53d562c28b" name="aee2771d71a0847756cf5eb53d562c28b"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>mk_dict</b> (Int_t framesize, Sexpr_t env_exec)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Macro support</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These macro primitives behave as described in Steele's <em>Common Lisp</em>. </p>
</td></tr>
<tr class="memitem:a33748ec7d0a2fcf00ab34c6374d1a8cc" id="r_a33748ec7d0a2fcf00ab34c6374d1a8cc"><td class="memItemLeft"><a id="a33748ec7d0a2fcf00ab34c6374d1a8cc" name="a33748ec7d0a2fcf00ab34c6374d1a8cc"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>macroexpand</b> (Sexpr_t form, Sexpr_t env_exec)</td></tr>
<tr class="memitem:a884f7ffa3e456bef0b0ebbc22c91e04e" id="r_a884f7ffa3e456bef0b0ebbc22c91e04e"><td class="memItemLeft"><a id="a884f7ffa3e456bef0b0ebbc22c91e04e" name="a884f7ffa3e456bef0b0ebbc22c91e04e"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>macroexpand1</b> (Sexpr_t form, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ad6f5f0423800385a70e0c12a94a0393e" id="r_ad6f5f0423800385a70e0c12a94a0393e"><td class="memItemLeft"><a id="ad6f5f0423800385a70e0c12a94a0393e" name="ad6f5f0423800385a70e0c12a94a0393e"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>macroexpand</b> (Sexpr_t proc, Sexpr_t args, Sexpr_t env_exec)</td></tr>
<tr class="memitem:ab05cdcdbc835d201ebde0dc22fdae3f7" id="r_ab05cdcdbc835d201ebde0dc22fdae3f7"><td class="memItemLeft"><a id="ab05cdcdbc835d201ebde0dc22fdae3f7" name="ab05cdcdbc835d201ebde0dc22fdae3f7"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>macroexpand1</b> (Sexpr_t proc, Sexpr_t args, Sexpr_t env_exec)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classLamb.html">Lamb</a> class represents a single Lisp virtual machine. To closely match the Arduino-style of loop-based control, LambLisp provides begin(), <a class="el" href="#a24a675444f8914eb9bbc8bd38df95682" title="Run often to maintain control. The main responsibility of C++ Lamb::loop() is to call the LambLisp fu...">loop()</a>, and <a class="el" href="#aa927683a9cbbeed045b742cf7127c428" title="Release resources used by the Lamb virtual machine.">end()</a>.</p>
<p>To initialize the LambLisp VM, begin() should be called once before any other call. Generally LambLisp <a class="el" href="#a24a675444f8914eb9bbc8bd38df95682" title="Run often to maintain control. The main responsibility of C++ Lamb::loop() is to call the LambLisp fu...">loop()</a> will be called one time for every main <a class="el" href="#a24a675444f8914eb9bbc8bd38df95682" title="Run often to maintain control. The main responsibility of C++ Lamb::loop() is to call the LambLisp fu...">loop()</a>, but it is not necessary. If <a class="el" href="#aa927683a9cbbeed045b742cf7127c428" title="Release resources used by the Lamb virtual machine.">end()</a> is called, all LambLisp resources are freed; <a class="el" href="#afb2727349ae14d921df777a5577c8fb1" title="Run once after base platform has started. In particular, Serial should be initialized before calling ...">Lamb::setup()</a> can be called again to restart that LambLisp VM.</p>
<p>The LambLisp VM functions are grouped this way:</p><ul>
<li><p class="startli">Logging functions</p>
</li>
<li><p class="startli">Build and version informational functions.</p>
</li>
<li><p class="startli"><a class="el" href="classCell.html">Cell</a> constructors, getters &amp; setters</p>
</li>
<li><p class="startli">Base data structures for the interpreter: alist, hash tables, and environments, along with their getters &amp; setters.</p>
</li>
<li><p class="startli">Printers</p>
</li>
<li><p class="startli">Partial evaluation and application</p>
</li>
<li><p class="startli">Port access from <em>Lisp</em></p>
</li>
<li><p class="startli">Vector, list, and dictionary utilities, used internally and also available in <em>Lisp</em>.</p>
</li>
<li><p class="startli">GC interface functions to protect critical sections.</p>
</li>
<li><p class="startli">Bindings</p>
</li>
<li><p class="startli">Makers </p>
</li>
</ul>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a1f2e3ba9db4055bd60f1e765b9ecfaf4" name="a1f2e3ba9db4055bd60f1e765b9ecfaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2e3ba9db4055bd60f1e765b9ecfaf4">&#9670;&#160;</a></span>Mop3st_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Sexpr_t(* Lamb::Mop3st_t) (<a class="el" href="classLamb.html">Lamb</a> &amp;lamb, Sexpr_t sexpr, Sexpr_t env_exec)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a pointer to a C++ native function that interacts directly with the S-expression in the given environment. Every LambLisp native function shares this signature. New external functions that conform to this signature can be used from within LambLisp and will run at full speed. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="afb2727349ae14d921df777a5577c8fb1" name="afb2727349ae14d921df777a5577c8fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2727349ae14d921df777a5577c8fb1">&#9670;&#160;</a></span>setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::setup </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run once after base platform has started. In particular, <em>Serial</em> should be initialized before calling <a class="el" href="#afb2727349ae14d921df777a5577c8fb1" title="Run once after base platform has started. In particular, Serial should be initialized before calling ...">setup()</a>. </p>

</div>
</div>
<a id="a24a675444f8914eb9bbc8bd38df95682" name="a24a675444f8914eb9bbc8bd38df95682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a675444f8914eb9bbc8bd38df95682">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::loop </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run often to maintain control. The main responsibility of C++ <a class="el" href="#a24a675444f8914eb9bbc8bd38df95682" title="Run often to maintain control. The main responsibility of C++ Lamb::loop() is to call the LambLisp fu...">Lamb::loop()</a> is to call the LambLisp function of the same name (loop). </p>

</div>
</div>
<a id="aa927683a9cbbeed045b742cf7127c428" name="aa927683a9cbbeed045b742cf7127c428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa927683a9cbbeed045b742cf7127c428">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::end </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release resources used by the <a class="el" href="classLamb.html">Lamb</a> virtual machine. </p>

</div>
</div>
<a id="aa174993fcf84dfc13057742d6a22ef09" name="aa174993fcf84dfc13057742d6a22ef09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa174993fcf84dfc13057742d6a22ef09">&#9670;&#160;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::log </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-level printf feature with a limit on the length of strings produced. Takes care of log prompt. </p>

</div>
</div>
<a id="a2a036d13e5bdf866c3736af78be70718" name="a2a036d13e5bdf866c3736af78be70718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a036d13e5bdf866c3736af78be70718">&#9670;&#160;</a></span>printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::printf </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-level printf feature with a limit on the length of strings produced. </p>

</div>
</div>
<a id="aac335c8d8124c33b46abc80e3697771b" name="aac335c8d8124c33b46abc80e3697771b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac335c8d8124c33b46abc80e3697771b">&#9670;&#160;</a></span>debug() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Lamb::debug </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the state of the <a class="el" href="classLamb.html">Lamb</a> internal debug flag. </p>

</div>
</div>
<a id="accb257177bebdc68f9832da848af24ab" name="accb257177bebdc68f9832da848af24ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb257177bebdc68f9832da848af24ab">&#9670;&#160;</a></span>debug() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::debug </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>onoff</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state of the <a class="el" href="classLamb.html">Lamb</a> debug flag. </p>

</div>
</div>
<a id="aef8f98f440b7c0b94eb00adb93844ab8" name="aef8f98f440b7c0b94eb00adb93844ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8f98f440b7c0b94eb00adb93844ab8">&#9670;&#160;</a></span>build_isDebug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Lamb::build_isDebug </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this build is not checked in. This is unrelated to the runtime <span class="tt"><a class="el" href="#aac335c8d8124c33b46abc80e3697771b" title="Return the state of the Lamb internal debug flag.">debug</a></span> flag. </p>

</div>
</div>
<a id="a47a885405830eec85726b2df71cd652c" name="a47a885405830eec85726b2df71cd652c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a885405830eec85726b2df71cd652c">&#9670;&#160;</a></span>build_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Lamb::build_version </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the build version as a long integer (implemented as a UTC time stamp). </p>

</div>
</div>
<a id="a96d46abfc546800799333debbb58dcc0" name="a96d46abfc546800799333debbb58dcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d46abfc546800799333debbb58dcc0">&#9670;&#160;</a></span>build_UTC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Lamb::build_UTC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the UTC time of this build. </p>

</div>
</div>
<a id="ae253defe92fad5cee7b522c8121ce008" name="ae253defe92fad5cee7b522c8121ce008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae253defe92fad5cee7b522c8121ce008">&#9670;&#160;</a></span>build_pushUTC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Lamb::build_pushUTC </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the UTC time this repo was last pushed. </p>

</div>
</div>
<a id="a7b7e5798eb649068941e9032e5a4ac50" name="a7b7e5798eb649068941e9032e5a4ac50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7e5798eb649068941e9032e5a4ac50">&#9670;&#160;</a></span>build_buildRelease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Lamb::build_buildRelease </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a character array containing the release description. </p>

</div>
</div>
<a id="a215a6eae1a41be8036f20d41a0cc2d5b" name="a215a6eae1a41be8036f20d41a0cc2d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215a6eae1a41be8036f20d41a0cc2d5b">&#9670;&#160;</a></span>build_buildDate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Lamb::build_buildDate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a character array containing the build date. </p>

</div>
</div>
<a id="a60d45dc974542f205686c3c801a968df" name="a60d45dc974542f205686c3c801a968df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d45dc974542f205686c3c801a968df">&#9670;&#160;</a></span>build_pushDate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Lamb::build_pushDate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a character array containing the date this repo was last pushed. </p>

</div>
</div>
<a id="a9beeee579b2bfc35cabdecd71587e624" name="a9beeee579b2bfc35cabdecd71587e624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9beeee579b2bfc35cabdecd71587e624">&#9670;&#160;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::expand </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add another block of cells to the population. </p>

</div>
</div>
<a id="a2809eabb44af7dbe41915000fd8e6908" name="a2809eabb44af7dbe41915000fd8e6908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2809eabb44af7dbe41915000fd8e6908">&#9670;&#160;</a></span>tcons() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::tcons </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>typ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic cell constructor with no GC protection for its arguments. </p>

</div>
</div>
<a id="a29e559db0aac8843b8ace5f9cd370379" name="a29e559db0aac8843b8ace5f9cd370379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e559db0aac8843b8ace5f9cd370379">&#9670;&#160;</a></span>tcons() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::tcons </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>typ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for any pair type; protects both S-expression arguments. </p>

</div>
</div>
<a id="a36f015662ed557d84c2a711a43f34887" name="a36f015662ed557d84c2a711a43f34887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f015662ed557d84c2a711a43f34887">&#9670;&#160;</a></span>cons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::cons </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classCell.html">Cell</a> constructor for normal pairs. </p>

</div>
</div>
<a id="a256fa30acb8ffe154e6f0953ffaa9628" name="a256fa30acb8ffe154e6f0953ffaa9628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256fa30acb8ffe154e6f0953ffaa9628">&#9670;&#160;</a></span>gensym()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::gensym </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a new unique symbol. </p>

</div>
</div>
<a id="acca4657377d79e76892d40a9dc85be22" name="acca4657377d79e76892d40a9dc85be22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca4657377d79e76892d40a9dc85be22">&#9670;&#160;</a></span>gc_root_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::gc_root_push </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preserve the cell given from GC, until popped. </p>

</div>
</div>
<a id="a6aa5bf20c2c7ae74ccd63f706b907bd7" name="a6aa5bf20c2c7ae74ccd63f706b907bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa5bf20c2c7ae74ccd63f706b907bd7">&#9670;&#160;</a></span>gc_root_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::gc_root_pop </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the preserved cells for normal GC processing. </p>

</div>
</div>
<a id="af67e288ddedf61aa4e3960031cdd1e1a" name="af67e288ddedf61aa4e3960031cdd1e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67e288ddedf61aa4e3960031cdd1e1a">&#9670;&#160;</a></span>set_car_bang()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::set_car_bang </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the car field in the cell with <em>val</em>. GC flags will be maintained as required. </p>

</div>
</div>
<a id="a7df100ee91d8e28fe3eec41a07bc1911" name="a7df100ee91d8e28fe3eec41a07bc1911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df100ee91d8e28fe3eec41a07bc1911">&#9670;&#160;</a></span>set_cdr_bang()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::set_cdr_bang </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the cdr field in the cell with <em>val</em>. GC flags will be maintained as required. </p>

</div>
</div>
<a id="aede13d19ee7f41767ac3b93b4f1b2d9f" name="aede13d19ee7f41767ac3b93b4f1b2d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede13d19ee7f41767ac3b93b4f1b2d9f">&#9670;&#160;</a></span>vector_set_bang()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::vector_set_bang </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the specified vector element with <em>val</em>. GC flags will be maintained as required. </p>

</div>
</div>
<a id="a4990161fdb806f5f4a080c77eedaf0f0" name="a4990161fdb806f5f4a080c77eedaf0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4990161fdb806f5f4a080c77eedaf0f0">&#9670;&#160;</a></span>reverse_bang()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::reverse_bang </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the list in-place and return the new list head (the former list tail). </p>

</div>
</div>
<a id="a2c95851876043ded3da4ca4faaf8f5a4" name="a2c95851876043ded3da4ca4faaf8f5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c95851876043ded3da4ca4faaf8f5a4">&#9670;&#160;</a></span>eq_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::eq_q </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>obj1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>obj2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if 2 cells are the same cell, or are atoms with the same value. </p>

</div>
</div>
<a id="a25eb1361fcd92d5f1cad240ee068ce97" name="a25eb1361fcd92d5f1cad240ee068ce97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25eb1361fcd92d5f1cad240ee068ce97">&#9670;&#160;</a></span>eqv_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::eqv_q </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>obj1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>obj2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if 1 cells are the same cell, or are atoms with the same value. </p>

</div>
</div>
<a id="a8efb889bc900669b178001cdc6941354" name="a8efb889bc900669b178001cdc6941354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efb889bc900669b178001cdc6941354">&#9670;&#160;</a></span>equal_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::equal_q </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>obj1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>obj2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when obj1 and obj2 are eqv?, and also all their descendants. </p>

</div>
</div>
<a id="a12396fb0a2a3d57dd085df40da87c164" name="a12396fb0a2a3d57dd085df40da87c164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12396fb0a2a3d57dd085df40da87c164">&#9670;&#160;</a></span>assq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::assq </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>alist</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search an association list for a matching key, and return the <span class="tt">(key . value)</span> pair, or <b>false</b> if not found. </p>

</div>
</div>
<a id="ae746ee259f35deb8edbe8e8b9c03999e" name="ae746ee259f35deb8edbe8e8b9c03999e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae746ee259f35deb8edbe8e8b9c03999e">&#9670;&#160;</a></span>dict_new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::dict_new </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>framesize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new empty dictionary with the given top frame size. </p>

</div>
</div>
<a id="ac40867630c1ed1b9292f213ef773cc23" name="ac40867630c1ed1b9292f213ef773cc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40867630c1ed1b9292f213ef773cc23">&#9670;&#160;</a></span>dict_new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::dict_new </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new empty dictionary with alist top frame. </p>

</div>
</div>
<a id="a8d058d659552023cade51553bcad7c65" name="a8d058d659552023cade51553bcad7c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d058d659552023cade51553bcad7c65">&#9670;&#160;</a></span>dict_add_empty_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::dict_add_empty_frame </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new dictionary with an empty top frame, and an existing dictionary as parent. </p>

</div>
</div>
<a id="ace672ca89aa77258b0740e69469088d6" name="ace672ca89aa77258b0740e69469088d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace672ca89aa77258b0740e69469088d6">&#9670;&#160;</a></span>dict_add_keyval_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::dict_add_keyval_frame </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>vals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new dictionary with a new top frame containing the keys bound to the values. </p>

</div>
</div>
<a id="aaddd2546ce874edc72ec8230a2b61cd0" name="aaddd2546ce874edc72ec8230a2b61cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddd2546ce874edc72ec8230a2b61cd0">&#9670;&#160;</a></span>dict_add_alist_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::dict_add_alist_frame </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>alist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new dictionary with the alist bindings added in a new frame on top of the base dictionary. </p>

</div>
</div>
<a id="acb296d231e3d05b1edc117a1e67f4638" name="acb296d231e3d05b1edc117a1e67f4638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb296d231e3d05b1edc117a1e67f4638">&#9670;&#160;</a></span>dict_bind_bang()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::dict_bind_bang </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the target dictionary; <span class="tt">value</span> is re-assigned to <span class="tt">key</span>if found, else created in the top frame. </p>

</div>
</div>
<a id="ad2c047480a9250592e981b33a0ceb188" name="ad2c047480a9250592e981b33a0ceb188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c047480a9250592e981b33a0ceb188">&#9670;&#160;</a></span>dict_rebind_bang()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::dict_rebind_bang </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the target dictionary; <span class="tt">value</span> is assigned to <span class="tt">key</span> wherever first found in env, else error if not found. </p>

</div>
</div>
<a id="aacf595cc8339d6123b94f100fc447f2b" name="aacf595cc8339d6123b94f100fc447f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf595cc8339d6123b94f100fc447f2b">&#9670;&#160;</a></span>dict_bind_alist_bang()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::dict_bind_alist_bang </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>alist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the target dictionary; binding keys in the alist to their corresponding values. </p>

</div>
</div>
<a id="ab365d7e1bda470277e3986555a3005bd" name="ab365d7e1bda470277e3986555a3005bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab365d7e1bda470277e3986555a3005bd">&#9670;&#160;</a></span>dict_rebind_alist_bang()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lamb::dict_rebind_alist_bang </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>alist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the target dictionary; rebinding keys in the alist to their corresponding values. </p>

</div>
</div>
<a id="a90cdf1a6ccb69c9198e7779ff0c71317" name="a90cdf1a6ccb69c9198e7779ff0c71317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cdf1a6ccb69c9198e7779ff0c71317">&#9670;&#160;</a></span>dict_ref_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::dict_ref_q </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns (key value) pair, or <b>false</b> if key is unbound. </p>

</div>
</div>
<a id="aade8fb852aa5ea06024ae250d80ddf3f" name="aade8fb852aa5ea06024ae250d80ddf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade8fb852aa5ea06024ae250d80ddf3f">&#9670;&#160;</a></span>dict_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::dict_ref </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value associated with the key in the given dictionary; throws error if key is unbound. </p>

</div>
</div>
<a id="aad8ad0f4b9ccf82019a2ea9bb058eb4d" name="aad8ad0f4b9ccf82019a2ea9bb058eb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8ad0f4b9ccf82019a2ea9bb058eb4d">&#9670;&#160;</a></span>dict_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::dict_keys </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note that keys and values are guaranteed to return in the corresponding order in dict_keys and dict_values, duplicate keys may occur. </p>
<p>Return a list of all the keys in this dictionary. If the dictionary has parents, keys may appear multiple times. </p>

</div>
</div>
<a id="a3b5bf69d1ef926a0dcc6f650b0192311" name="a3b5bf69d1ef926a0dcc6f650b0192311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5bf69d1ef926a0dcc6f650b0192311">&#9670;&#160;</a></span>dict_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::dict_values </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of all the values in this dictionary. If the dictionary has parents, values may appear multiple times for each key. </p>

</div>
</div>
<a id="a9ab88bc97fe713a60d5e52865a2592db" name="a9ab88bc97fe713a60d5e52865a2592db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab88bc97fe713a60d5e52865a2592db">&#9670;&#160;</a></span>dict_to_alist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::dict_to_alist </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the dictionary to an alist, retaining only the top-level <span class="tt">(key . value)</span> pairs. </p>

</div>
</div>
<a id="a8a9a1d8df1493b320cc676f8e74f4752" name="a8a9a1d8df1493b320cc676f8e74f4752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9a1d8df1493b320cc676f8e74f4752">&#9670;&#160;</a></span>dict_to_2list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::dict_to_2list </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the dictionary to a list of 2-element lists, retaining only the top-level <span class="tt">(key value)</span> sublists. </p>

</div>
</div>
<a id="a17a118ef0820f32f2d99839c983ce701" name="a17a118ef0820f32f2d99839c983ce701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a118ef0820f32f2d99839c983ce701">&#9670;&#160;</a></span>alist_to_dict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::alist_to_dict </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>alist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an alist into a dictionary. The resulting dictionary has no parent. </p>

</div>
</div>
<a id="a84e5e5d26ee7c66ff09af4f9f5c5497d" name="a84e5e5d26ee7c66ff09af4f9f5c5497d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e5e5d26ee7c66ff09af4f9f5c5497d">&#9670;&#160;</a></span>twolist_to_dict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::twolist_to_dict </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>twolist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list of 2-element lists into a dictionary. The resulting dictionary has no parent. </p>

</div>
</div>
<a id="ad8f788ab9ebf9bbc257c4b2748a8d593" name="ad8f788ab9ebf9bbc257c4b2748a8d593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f788ab9ebf9bbc257c4b2748a8d593">&#9670;&#160;</a></span>dict_analyze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::dict_analyze </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>dict</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>verbosity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal integrity check. </p>

</div>
</div>
<a id="a62684ca4e1d99334efa9a929ba71a336" name="a62684ca4e1d99334efa9a929ba71a336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62684ca4e1d99334efa9a929ba71a336">&#9670;&#160;</a></span>quasiquote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::quasiquote </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>sexpr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial quotation per RxRS. </p>

</div>
</div>
<a id="ae2128177edc320bb4a340149c8783793" name="ae2128177edc320bb4a340149c8783793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2128177edc320bb4a340149c8783793">&#9670;&#160;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::eval </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>sexpr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the S-expression in the environment provided. </p>

</div>
</div>
<a id="aa0945d032c8c0e9a76276b39aeb88e84" name="aa0945d032c8c0e9a76276b39aeb88e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0945d032c8c0e9a76276b39aeb88e84">&#9670;&#160;</a></span>eval_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::eval_list </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the list of S-expressions in the environment provided, and return a lkist of results. </p>

</div>
</div>
<a id="a08b628887841c154f312696440158c5f" name="a08b628887841c154f312696440158c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b628887841c154f312696440158c5f">&#9670;&#160;</a></span>apply_proc_partial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::apply_proc_partial </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>proc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>sexpr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the function arguments and then apply the function to them. The result may be a tail requiring further evaluation. </p>

</div>
</div>
<a id="af94560296430fe61a8deafe4e8861b0f" name="af94560296430fe61a8deafe4e8861b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94560296430fe61a8deafe4e8861b0f">&#9670;&#160;</a></span>map_proc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::map_proc </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>proc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>lists</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the procecure to the lists per R5RS. </p>

</div>
</div>
<a id="af836071fde5f37dc0cc230fd7a24102b" name="af836071fde5f37dc0cc230fd7a24102b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af836071fde5f37dc0cc230fd7a24102b">&#9670;&#160;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::load </td>
          <td>(</td>
          <td class="paramtype">Charst_t</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>verbosity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and evaluate S-expressions from the named file. </p>

</div>
</div>
<a id="aec197c7ef2f90c21cfb4a8b20ab6e3ed" name="aec197c7ef2f90c21cfb4a8b20ab6e3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec197c7ef2f90c21cfb4a8b20ab6e3ed">&#9670;&#160;</a></span>append2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::append2 </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>lis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructively attach <em>obj</em> to the end of <em>lis</em>, which must be a proper list. </p>

</div>
</div>
<a id="a5737a80fc54bec9a9f215f03d1536854" name="a5737a80fc54bec9a9f215f03d1536854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5737a80fc54bec9a9f215f03d1536854">&#9670;&#160;</a></span>list_analyze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::list_analyze </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>sexpr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the list and return either false (if circular), the list length (if a proper list), ###. </p>

</div>
</div>
<a id="af06199f7adaa96a9db06a2db66d06023" name="af06199f7adaa96a9db06a2db66d06023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06199f7adaa96a9db06a2db66d06023">&#9670;&#160;</a></span>mk_error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::mk_error </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>irritants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a new error object with the information given, and return it. </p>

</div>
</div>
<a id="afd00b10ada1aae47b4e7dd6bc2c87d02" name="afd00b10ada1aae47b4e7dd6bc2c87d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd00b10ada1aae47b4e7dd6bc2c87d02">&#9670;&#160;</a></span>mk_error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::mk_error </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a new error object with the information given, and return it. The <em>irritants</em> field is left NIL. </p>

</div>
</div>
<a id="a9cf3c8f4c0a27f1c588f46cb71f2999d" name="a9cf3c8f4c0a27f1c588f46cb71f2999d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf3c8f4c0a27f1c588f46cb71f2999d">&#9670;&#160;</a></span>mk_syserror() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::mk_syserror </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the system error object with the info given, and return it. </p>

</div>
</div>
<a id="a0019fef1005d1dc5fbc3612f8896d2fd" name="a0019fef1005d1dc5fbc3612f8896d2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0019fef1005d1dc5fbc3612f8896d2fd">&#9670;&#160;</a></span>mk_syserror() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::mk_syserror </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>irritants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the system error object with the info given, and return it. </p>

</div>
</div>
<a id="a4436c845b50e5c2b90ac578b2dcd7062" name="a4436c845b50e5c2b90ac578b2dcd7062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4436c845b50e5c2b90ac578b2dcd7062">&#9670;&#160;</a></span>mk_bytevector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::mk_bytevector </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplest heap allocation with no initialization. </p>

</div>
</div>
<a id="a3dd18d5af752246c9787df88dddc0b8c" name="a3dd18d5af752246c9787df88dddc0b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd18d5af752246c9787df88dddc0b8c">&#9670;&#160;</a></span>mk_bytevector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::mk_bytevector </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bytest_t</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Heap allocation with initialization. </p>

</div>
</div>
<a id="a5b8ec660aca35f120b91995c2e22e70f" name="a5b8ec660aca35f120b91995c2e22e70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8ec660aca35f120b91995c2e22e70f">&#9670;&#160;</a></span>mk_bytevector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::mk_bytevector </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>fill</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Heap allocation with initialization. </p>

</div>
</div>
<a id="a088e2a3ae214cba206e1e9eb7a15891c" name="a088e2a3ae214cba206e1e9eb7a15891c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088e2a3ae214cba206e1e9eb7a15891c">&#9670;&#160;</a></span>mk_bytevector_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::mk_bytevector_ext </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bytest_t</td>          <td class="paramname"><span class="paramname"><em>ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Injection of externally allocated memory, which will not be freed at GC time. </p>

</div>
</div>
<a id="a951b513180e8a23fcbd2c1d52bd155de" name="a951b513180e8a23fcbd2c1d52bd155de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951b513180e8a23fcbd2c1d52bd155de">&#9670;&#160;</a></span>mk_intvector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::mk_intvector </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note that integer vectors and real vectors are just bytevectors underneath. </p>
<p>Allocates a bytevector from the heap to ensure proper alignment (no IMM type). </p>

</div>
</div>
<a id="a221cf5302ff753c237bf0b8380ceb329" name="a221cf5302ff753c237bf0b8380ceb329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221cf5302ff753c237bf0b8380ceb329">&#9670;&#160;</a></span>mk_realvector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Lamb::mk_realvector </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>env_exec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a bytevector from the heap to ensure proper alignment (no IMM type). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.16.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="classLamb.html">Lamb</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.0 </li>
  </ul>
</div>
</body>
</html>
