<!-- HTML header for doxygen 1.16.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LambLisp: Cell Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome-cust.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="lamb-39.jpeg"/></td>
  <td id="projectalign">
   <div id="projectname">LambLisp<span id="projectnumber">&#160;01 Red Fox Alpha</span>
   </div>
   <div id="projectbrief">Lisp For Real-Time Control</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classCell.html','','classCell-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Cell Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr id="pub-types-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Cell type enumeration</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Note the following properties of this enumeration:  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NIL is a singleton, in the middle of the enumeration.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Types &lt;= NIL are atoms.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Types &gt;= NIL are lists.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Types &gt; NIL are pairs.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Types &lt;= T_PORT_HEAP are heap-allocated objects, requiring specialized finalizing but not specialized marking.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Types &lt;= T_ANY_HEAP_SVEC are heap allocated vectors requiring specialized marking in addition to finalizing.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">For Scheme purposes, there is one <span class="tt">pair</span> type, but there are several other specialized <span class="tt">pair</span> types that facilitate execution.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">These additional <span class="tt">pair</span> types are <em>atoms</em>, but list operations such as <span class="tt">car</span>, <span class="tt">cdr</span>, and <span class="tt">append</span> can operate on them.  </td></tr>
</table>
</div></td></tr>
<tr class="memitem:aa11b65afd71903a81bbc611dcf5b3b8c" id="r_aa11b65afd71903a81bbc611dcf5b3b8c"><td class="memItemLeft">enum &#160;</td><td class="memItemRight">{ <br />
&#160;&#160;<a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca34c898f666ae7b1cd78e138fe3805896">T_SVEC_HEAP</a> =0
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca419215921b4442d1d11142ba4c63d6dd">T_SVEC2N_HEAP</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8cae3c2432ff84ab3007e9ad3bb3554290d">T_ANY_HEAP_SVEC</a> = T_SVEC2N_HEAP
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca8ab19c778062aec94fb9a1a1dcebb644">T_SYM_HEAP</a>
, <br />
&#160;&#160;<a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca879397f195a8fed9db3734e90b17a5fc">T_BVEC_HEAP</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca88560b011409adab2b1456d5bd498cdf">T_STR_HEAP</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca7768ac295eae706204b55f6664701aab">T_CPP_HEAP</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca2e03113f4fa69af6344fda68d2a41bf7">T_PORT_HEAP</a>
, <br />
&#160;&#160;<a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca1aef18ad4c492ee07632b3e80e8fb69a">T_NEEDS_FINALIZING</a> = T_PORT_HEAP
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca342541e1951e63d9fcdeae16376691d2">T_BVEC_EXT</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca003bac7c143522cfb88cb7998a88c6e1">T_STR_EXT</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca2b9c906cd20f95a4b1aca242103dfcc5">T_BVEC_IMM</a>
, <br />
&#160;&#160;<a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8cafc1ecdcd1708cbc2d16275990de41cf6">T_STR_IMM</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca3eeaf9b8541ed055954a9acf88173c95">T_GENSYM</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8cad42fbbdccc92d223e29392cd8ec73a68">T_BOOL</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca08f796237599216e7d2fe5e228a9af6a">T_CHAR</a>
, <br />
&#160;&#160;<a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca376763b8c92a0384401f9422bcb72ba3">T_INT</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8cac1b31c80ab486e824e2efb5bd51937f1">T_REAL</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8cafd4fc46b1ef43d0bfe15dd988add143f">T_RATIONAL</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8cae7e0fb7d2964e355d3511ce9937ffb7d">T_MOP3_PROC</a>
, <br />
&#160;&#160;<a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8caa0c452a237d17de864a87b55ffc0a1ca">T_MOP3_NPROC</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca3621c153246bc6d5edeb45ddf30c2f77">T_VOID</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca526409f000bb42377070662b985b281a">T_UNDEF</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca8764542fbfeec3419c75b33dbd5a5261">T_NIL</a>
, <br />
&#160;&#160;<a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca37c9f1f9a1e3f5faa0e1ce8f44032b4f">T_PAIR</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8cabfa5235660df11ed7d225d7bf02403fa">T_SVEC_IMM</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8cad01c5c3afca169d5752437aad874a13e">T_PROC</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8cae432c7864195cfb23f2cefcb6b4966b0">T_NPROC</a>
, <br />
&#160;&#160;<a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca47360afc9a084831e79a16bf53b37a0c">T_MACRO</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8cad6cd21de81fa6dbffd8e8e5a727b888a">T_DICT</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca590421f2b070efbc217c95c8c42b3c37">T_THUNK_SEXPR</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca7d1e0fccb360f16b598aefe7f00e2b53">T_THUNK_BODY</a>
, <br />
&#160;&#160;<a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8ca0692d4fb60cb00594a5998ebcf39883b">T_ERROR</a>
, <a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8caa222aa22504f258f7550461e9c88b152">Ntypes</a>
<br />
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3904b29bfd9688456754f2f99c8005e" id="r_ac3904b29bfd9688456754f2f99c8005e"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#ac3904b29bfd9688456754f2f99c8005e">mk_error</a> (const char *fmt,...) CHECKPRINTF_pos2</td></tr>
<tr class="memitem:a68bd39dbebac4d554b9d7088f38bc899" id="r_a68bd39dbebac4d554b9d7088f38bc899"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a68bd39dbebac4d554b9d7088f38bc899">mk_error</a> (Sexpr_t irritants, const char *fmt,...) CHECKPRINTF_pos3</td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Static Cell constructors, used only for "well-known" atomic cells (nilL, true, false etc).</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>In general, it is best not to do anything complex at static construction time. There is no guarantee that dependencies will be ready. In particular, use of the terminal may cause the system to crash. Most applications should leave any construction activities to more purposeful code at runtime, using only cells obtained through <em>cons</em>. </p>
</div></td></tr>
<tr class="memitem:a975a99d4808720bd60780f5c0cb7dfa5" id="r_a975a99d4808720bd60780f5c0cb7dfa5"><td class="memItemLeft"><a id="a975a99d4808720bd60780f5c0cb7dfa5" name="a975a99d4808720bd60780f5c0cb7dfa5"></a>
&#160;</td><td class="memItemRight"><b>Cell</b> (Word_t typ, Word_t w1, Word_t w2)</td></tr>
<tr class="memitem:a0ba98ce2dce18f5a379c3d70f6017048" id="r_a0ba98ce2dce18f5a379c3d70f6017048"><td class="memItemLeft"><a id="a0ba98ce2dce18f5a379c3d70f6017048" name="a0ba98ce2dce18f5a379c3d70f6017048"></a>
&#160;</td><td class="memItemRight"><b>Cell</b> (Word_t typ, Int_t w1, Sexpr_t w2)</td></tr>
<tr class="memitem:a9b5983cda51447d99748a4a48dc5aaa3" id="r_a9b5983cda51447d99748a4a48dc5aaa3"><td class="memItemLeft"><a id="a9b5983cda51447d99748a4a48dc5aaa3" name="a9b5983cda51447d99748a4a48dc5aaa3"></a>
&#160;</td><td class="memItemRight"><b>Cell</b> (Word_t typ, Sexpr_t w1, Sexpr_t w2)</td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Low-level cell field manipulation.</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>Note that the type field occupies all of byte 0, although not all bits are required. This speeds up the very common type-checking operation, because no mask is required to extract the type bits.</p>
<p>The flags are in byte 1, and a mask operation is required to access the individual flag fields. </p>
</div></td></tr>
<tr class="memitem:a9d3e868f803fc5f83ef0a973fedd3e94" id="r_a9d3e868f803fc5f83ef0a973fedd3e94"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a9d3e868f803fc5f83ef0a973fedd3e94">zero</a> ()</td></tr>
<tr class="memitem:a4f27baeb49e15a3591d07288fc6a19ce" id="r_a4f27baeb49e15a3591d07288fc6a19ce"><td class="memItemLeft">Int_t&#160;</td><td class="memItemRight"><a class="el" href="#a4f27baeb49e15a3591d07288fc6a19ce">type</a> (void)</td></tr>
<tr class="memitem:aff015cf4a13e61fa2361c383f1fb84ba" id="r_aff015cf4a13e61fa2361c383f1fb84ba"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aff015cf4a13e61fa2361c383f1fb84ba">type</a> (Int_t t)</td></tr>
<tr class="memitem:ad6c6a46173b370759db1a33ee9e51724" id="r_ad6c6a46173b370759db1a33ee9e51724"><td class="memItemLeft">Int_t&#160;</td><td class="memItemRight"><a class="el" href="#ad6c6a46173b370759db1a33ee9e51724">flags</a> (void)</td></tr>
<tr class="memitem:a0f5da45b73bd704677e0475fdfefe8eb" id="r_a0f5da45b73bd704677e0475fdfefe8eb"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a0f5da45b73bd704677e0475fdfefe8eb">flags_set</a> (Int_t f)</td></tr>
<tr class="memitem:a6e5e78964f1560157d4f67ac7aae3d9e" id="r_a6e5e78964f1560157d4f67ac7aae3d9e"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a6e5e78964f1560157d4f67ac7aae3d9e">flags_clr</a> (Int_t f)</td></tr>
<tr class="memitem:a107d6f43bebb8e34b5d14d2443362d7b" id="r_a107d6f43bebb8e34b5d14d2443362d7b"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a107d6f43bebb8e34b5d14d2443362d7b">rplaca</a> (Word_t p)</td></tr>
<tr class="memitem:a33fd270edc4c9bbd2766129400349b60" id="r_a33fd270edc4c9bbd2766129400349b60"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a33fd270edc4c9bbd2766129400349b60">rplacd</a> (Word_t p)</td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Cell value extractors, dependent on Cell type.</div></td></tr>
<tr class="memitem:a364b771ac8ee90f164eb4fbab92d9d31" id="r_a364b771ac8ee90f164eb4fbab92d9d31"><td class="memItemLeft">Ptr_t&#160;</td><td class="memItemRight"><a class="el" href="#a364b771ac8ee90f164eb4fbab92d9d31">get_car_addr</a> ()</td></tr>
<tr class="memitem:a322233cd39ef9fc3724573f50fab03ac" id="r_a322233cd39ef9fc3724573f50fab03ac"><td class="memItemLeft">Word_t&#160;</td><td class="memItemRight"><a class="el" href="#a322233cd39ef9fc3724573f50fab03ac">get_car</a> (void)</td></tr>
<tr class="memitem:a71633104c9a8d4a8601d7fd88f77166f" id="r_a71633104c9a8d4a8601d7fd88f77166f"><td class="memItemLeft">Word_t&#160;</td><td class="memItemRight"><a class="el" href="#a71633104c9a8d4a8601d7fd88f77166f">get_cdr</a> (void)</td></tr>
<tr class="memitem:a65758e75669f3026a385a1a166f4a2f6" id="r_a65758e75669f3026a385a1a166f4a2f6"><td class="memItemLeft">Bool_t&#160;</td><td class="memItemRight"><a class="el" href="#a65758e75669f3026a385a1a166f4a2f6">as_Bool_t</a> ()</td></tr>
<tr class="memitem:a43cf331a13d2d2f5dcf70f9eea572f2e" id="r_a43cf331a13d2d2f5dcf70f9eea572f2e"><td class="memItemLeft">Char_t&#160;</td><td class="memItemRight"><a class="el" href="#a43cf331a13d2d2f5dcf70f9eea572f2e">as_Char_t</a> ()</td></tr>
<tr class="memitem:a5063fe8a7022342b50b15be54c0afe2e" id="r_a5063fe8a7022342b50b15be54c0afe2e"><td class="memItemLeft">Int_t&#160;</td><td class="memItemRight"><a class="el" href="#a5063fe8a7022342b50b15be54c0afe2e">as_Int_t</a> ()</td></tr>
<tr class="memitem:a0a07f6ddb36824aca07c03ccf4741c93" id="r_a0a07f6ddb36824aca07c03ccf4741c93"><td class="memItemLeft">Real_t&#160;</td><td class="memItemRight"><a class="el" href="#a0a07f6ddb36824aca07c03ccf4741c93">as_Real_t</a> ()</td></tr>
<tr class="memitem:a5373d587dae40805e94f97d1f7d6ab81" id="r_a5373d587dae40805e94f97d1f7d6ab81"><td class="memItemLeft">Ptr_t&#160;</td><td class="memItemRight"><a class="el" href="#a5373d587dae40805e94f97d1f7d6ab81">as_Ptr_t</a> ()</td></tr>
<tr class="memitem:a81f257368a5df0b56255f48826d5fadf" id="r_a81f257368a5df0b56255f48826d5fadf"><td class="memItemLeft">Charst_t&#160;</td><td class="memItemRight"><a class="el" href="#a81f257368a5df0b56255f48826d5fadf">as_Charst_t</a> ()</td></tr>
<tr class="memitem:aa48a9eecffb0163b4a5884b571d84a66" id="r_aa48a9eecffb0163b4a5884b571d84a66"><td class="memItemLeft">Bytest_t&#160;</td><td class="memItemRight"><a class="el" href="#aa48a9eecffb0163b4a5884b571d84a66">as_Bytest_t</a> ()</td></tr>
<tr class="memitem:a438d4a6aa534369e19a2cc85e6b48f81" id="r_a438d4a6aa534369e19a2cc85e6b48f81"><td class="memItemLeft">CharVec_t&#160;</td><td class="memItemRight"><a class="el" href="#a438d4a6aa534369e19a2cc85e6b48f81">as_CharVec_t</a> ()</td></tr>
<tr class="memitem:a23f0b4b3e7d4f086a3218eb1c22a3eb0" id="r_a23f0b4b3e7d4f086a3218eb1c22a3eb0"><td class="memItemLeft">ByteVec_t&#160;</td><td class="memItemRight"><a class="el" href="#a23f0b4b3e7d4f086a3218eb1c22a3eb0">as_ByteVec_t</a> ()</td></tr>
<tr class="memitem:ac5b69357e77184493db61f8572bfe0ae" id="r_ac5b69357e77184493db61f8572bfe0ae"><td class="memItemLeft">Portst_t&#160;</td><td class="memItemRight"><a class="el" href="#ac5b69357e77184493db61f8572bfe0ae">as_Portst_t</a> ()</td></tr>
<tr class="memitem:a6a152074d19914ceabe424ba418898e8" id="r_a6a152074d19914ceabe424ba418898e8"><td class="memItemLeft">Int_t&#160;</td><td class="memItemRight"><a class="el" href="#a6a152074d19914ceabe424ba418898e8">as_numerator</a> ()</td></tr>
<tr class="memitem:af212b8574301560ba04938c7deb68f3c" id="r_af212b8574301560ba04938c7deb68f3c"><td class="memItemLeft">Int_t&#160;</td><td class="memItemRight"><a class="el" href="#af212b8574301560ba04938c7deb68f3c">as_denominator</a> ()</td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Cell hash value</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>Hashing is used extensively throughout <em>LambLisp</em>. Each <a class="el" href="classCell.html">Cell</a> has a hash value, calculated as follows:</p><ul>
<li><p class="startli">If the <a class="el" href="classCell.html">Cell</a> is a symbol, the <a class="el" href="classCell.html">Cell</a>'s hash value is the hash value of the symbol.</p>
</li>
<li><p class="startli">Otherwise, the address of the <a class="el" href="classCell.html">Cell</a> is hashed, and that is the result. </p>
</li>
</ul>
</div></td></tr>
<tr class="memitem:a9e8b0e506738768655a3fc877fadbaf1" id="r_a9e8b0e506738768655a3fc877fadbaf1"><td class="memItemLeft">Int_t&#160;</td><td class="memItemRight"><a class="el" href="#a9e8b0e506738768655a3fc877fadbaf1">hash_sexpr</a> (void)</td></tr>
<tr class="memitem:ad4678ca82413e46e827c53ccb228c531" id="r_ad4678ca82413e46e827c53ccb228c531"><td class="memItemLeft">Int_t&#160;</td><td class="memItemRight"><a class="el" href="#ad4678ca82413e46e827c53ccb228c531">hash_contents</a> (void)</td></tr>
<tr class="memitem:ac64d511f91458fa7072a1325f1a652e6" id="r_ac64d511f91458fa7072a1325f1a652e6"><td class="memItemLeft">Int_t&#160;</td><td class="memItemRight"><a class="el" href="#ac64d511f91458fa7072a1325f1a652e6">hash</a> (void)</td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Cell setters converting the C types into S-expressions.</div></td></tr>
<tr class="memitem:aa3890dc292814a07257b7955dfefa6fc" id="r_aa3890dc292814a07257b7955dfefa6fc"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#aa3890dc292814a07257b7955dfefa6fc">set</a> (Int_t typ, Word_t w1, Word_t w2)</td></tr>
<tr class="memitem:abca5d1ff979dca624397e3e7e4d28451" id="r_abca5d1ff979dca624397e3e7e4d28451"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#abca5d1ff979dca624397e3e7e4d28451">set</a> (Int_t typ, Int_t a, Sexpr_t b)</td></tr>
<tr class="memitem:aad5c6bb9fcd77ef2c51df69fa4e046e5" id="r_aad5c6bb9fcd77ef2c51df69fa4e046e5"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#aad5c6bb9fcd77ef2c51df69fa4e046e5">set</a> (Int_t typ, Sexpr_t a, Sexpr_t b)</td></tr>
<tr class="memitem:a04b15a010dd6946a700250c57bd7c0a9" id="r_a04b15a010dd6946a700250c57bd7c0a9"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a04b15a010dd6946a700250c57bd7c0a9">set</a> (Bool_t b)</td></tr>
<tr class="memitem:ad27d4b1daa039bfd2fb925c1ce33fe21" id="r_ad27d4b1daa039bfd2fb925c1ce33fe21"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#ad27d4b1daa039bfd2fb925c1ce33fe21">set</a> (Char_t c)</td></tr>
<tr class="memitem:a2ea142f8dd9b34e535a145e1bc0ffcc5" id="r_a2ea142f8dd9b34e535a145e1bc0ffcc5"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a2ea142f8dd9b34e535a145e1bc0ffcc5">set</a> (Int_t i)</td></tr>
<tr class="memitem:a4dd11aac5af3b679e10083b90d87fd78" id="r_a4dd11aac5af3b679e10083b90d87fd78"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a4dd11aac5af3b679e10083b90d87fd78">set</a> (Real_t r)</td></tr>
<tr class="memitem:ae44f742c2fd4cc7734474c24f5e88059" id="r_ae44f742c2fd4cc7734474c24f5e88059"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#ae44f742c2fd4cc7734474c24f5e88059">set</a> (Port_t &amp;p)</td></tr>
<tr class="memitem:a6b54c4fe1d55befc316de78dd9a5fb86" id="r_a6b54c4fe1d55befc316de78dd9a5fb86"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a6b54c4fe1d55befc316de78dd9a5fb86">set</a> (Int_t typ, Int_t a, Charst_t b)</td></tr>
<tr class="memitem:a00e86fd8c56ae7ac484dcf8cb0f6b236" id="r_a00e86fd8c56ae7ac484dcf8cb0f6b236"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a00e86fd8c56ae7ac484dcf8cb0f6b236">set</a> (Int_t typ, Int_t a, Bytest_t b)</td></tr>
<tr class="memitem:a0d8191bee104e35cdd63a003933bbdcc" id="r_a0d8191bee104e35cdd63a003933bbdcc"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a0d8191bee104e35cdd63a003933bbdcc">set</a> (Int_t typ, Int_t a, CharVec_t b)</td></tr>
<tr class="memitem:a1a5d375340f4da8978b5cf79c003deb7" id="r_a1a5d375340f4da8978b5cf79c003deb7"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a1a5d375340f4da8978b5cf79c003deb7">set</a> (Int_t typ, Int_t a, ByteVec_t b)</td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Accessors for use when the type is known.</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>If the cell type is already known, then these accessors can be used to efficiently access the cell contents. </p>
</div></td></tr>
<tr class="memitem:a8f525aa4c1d4f82fe600c682afd56677" id="r_a8f525aa4c1d4f82fe600c682afd56677"><td class="memItemLeft"><a id="a8f525aa4c1d4f82fe600c682afd56677" name="a8f525aa4c1d4f82fe600c682afd56677"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>prechecked_anypair_get_car</b> ()</td></tr>
<tr class="memitem:ad3c07064aa95d900656eef269fd8ee55" id="r_ad3c07064aa95d900656eef269fd8ee55"><td class="memItemLeft"><a id="ad3c07064aa95d900656eef269fd8ee55" name="ad3c07064aa95d900656eef269fd8ee55"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>prechecked_anypair_get_cdr</b> ()</td></tr>
<tr class="memitem:a9688b1e93c85c9e1607f2e843fd61e69" id="r_a9688b1e93c85c9e1607f2e843fd61e69"><td class="memItemLeft"><a id="a9688b1e93c85c9e1607f2e843fd61e69" name="a9688b1e93c85c9e1607f2e843fd61e69"></a>
Int_t&#160;</td><td class="memItemRight"><b>prechecked_sym_heap_get_hash</b> ()</td></tr>
<tr class="memitem:aebdba8aed805e44b5f57ec9011e581fe" id="r_aebdba8aed805e44b5f57ec9011e581fe"><td class="memItemLeft"><a id="aebdba8aed805e44b5f57ec9011e581fe" name="aebdba8aed805e44b5f57ec9011e581fe"></a>
Charst_t&#160;</td><td class="memItemRight"><b>prechecked_sym_heap_get_chars</b> ()</td></tr>
<tr class="memitem:aadee185007294189ceb65b6bd39f8fad" id="r_aadee185007294189ceb65b6bd39f8fad"><td class="memItemLeft"><a id="aadee185007294189ceb65b6bd39f8fad" name="aadee185007294189ceb65b6bd39f8fad"></a>
void&#160;</td><td class="memItemRight"><b>prechecked_sym_heap_get_info</b> (Int_t &amp;hsh, Charst_t &amp;chars)</td></tr>
<tr class="memitem:af2597eb1793b008a65782296f7ef027d" id="r_af2597eb1793b008a65782296f7ef027d"><td class="memItemLeft">CharVec_t&#160;</td><td class="memItemRight"><a class="el" href="#af2597eb1793b008a65782296f7ef027d">prechecked_str_heap_get_chars</a> ()</td></tr>
<tr class="memitem:a1fd585692aefb1d73653ffda48b4a443" id="r_a1fd585692aefb1d73653ffda48b4a443"><td class="memItemLeft">CharVec_t&#160;</td><td class="memItemRight"><a class="el" href="#a1fd585692aefb1d73653ffda48b4a443">prechecked_str_ext_get_chars</a> ()</td></tr>
<tr class="memitem:a9cf08a22d5fc8ef04d540bc20353fc43" id="r_a9cf08a22d5fc8ef04d540bc20353fc43"><td class="memItemLeft">CharVec_t&#160;</td><td class="memItemRight"><a class="el" href="#a9cf08a22d5fc8ef04d540bc20353fc43">prechecked_str_imm_get_chars</a> ()</td></tr>
<tr class="memitem:a72f8bf4dad4c835cbbec73fa3601cc1e" id="r_a72f8bf4dad4c835cbbec73fa3601cc1e"><td class="memItemLeft"><a id="a72f8bf4dad4c835cbbec73fa3601cc1e" name="a72f8bf4dad4c835cbbec73fa3601cc1e"></a>
void&#160;</td><td class="memItemRight"><b>prechecked_bvec_imm_set_length</b> (Int_t l)</td></tr>
<tr class="memitem:a5eaa36b3f90449dd09b8db82c0e08810" id="r_a5eaa36b3f90449dd09b8db82c0e08810"><td class="memItemLeft"><a id="a5eaa36b3f90449dd09b8db82c0e08810" name="a5eaa36b3f90449dd09b8db82c0e08810"></a>
Charst_t&#160;</td><td class="memItemRight"><b>prechecked_gensym_get_chars</b> ()</td></tr>
<tr class="memitem:a089947035d12cf728e650eca694ad426" id="r_a089947035d12cf728e650eca694ad426"><td class="memItemLeft"><a id="a089947035d12cf728e650eca694ad426" name="a089947035d12cf728e650eca694ad426"></a>
void&#160;</td><td class="memItemRight"><b>prechecked_gensym_get_info</b> (Int_t &amp;hsh, Charst_t &amp;chars)</td></tr>
<tr class="memitem:a43b1de08602c1c5f53b678fb2085ac77" id="r_a43b1de08602c1c5f53b678fb2085ac77"><td class="memItemLeft"><a id="a43b1de08602c1c5f53b678fb2085ac77" name="a43b1de08602c1c5f53b678fb2085ac77"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>prechecked_error_get_irritants</b> ()</td></tr>
<tr class="memitem:adab6f5c5d3d0578c1524c5570320f2fb" id="r_adab6f5c5d3d0578c1524c5570320f2fb"><td class="memItemLeft"><a id="adab6f5c5d3d0578c1524c5570320f2fb" name="adab6f5c5d3d0578c1524c5570320f2fb"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>prechecked_error_get_str</b> ()</td></tr>
<tr class="memitem:ab03b6f0558442afc3e1255174ae3f154" id="r_ab03b6f0558442afc3e1255174ae3f154"><td class="memItemLeft"><a id="ab03b6f0558442afc3e1255174ae3f154" name="ab03b6f0558442afc3e1255174ae3f154"></a>
Charst_t&#160;</td><td class="memItemRight"><b>prechecked_error_get_chars</b> ()</td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Accessors for use when the cell type is unverified.</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>The <b>any</b> and <b>mustbe</b> accessors will perform type checking and throw an error if an improper access is attempted. The <b>coerce</b> operators will perform C coercion on its operand if possible, otherwise throw an error. </p>
</div></td></tr>
<tr class="memitem:ac1e4b2d3caad7e7a941c2d585c2a929c" id="r_ac1e4b2d3caad7e7a941c2d585c2a929c"><td class="memItemLeft">Bool_t&#160;</td><td class="memItemRight"><a class="el" href="#ac1e4b2d3caad7e7a941c2d585c2a929c">mustbe_Bool_t</a> ()</td></tr>
<tr class="memitem:a44220de7d2f21182e625ec4911296563" id="r_a44220de7d2f21182e625ec4911296563"><td class="memItemLeft">Char_t&#160;</td><td class="memItemRight"><a class="el" href="#a44220de7d2f21182e625ec4911296563">mustbe_Char_t</a> ()</td></tr>
<tr class="memitem:ad652ff1276570beb205c7805ee647b4f" id="r_ad652ff1276570beb205c7805ee647b4f"><td class="memItemLeft">Int_t&#160;</td><td class="memItemRight"><a class="el" href="#ad652ff1276570beb205c7805ee647b4f">mustbe_Int_t</a> ()</td></tr>
<tr class="memitem:a3d01c0b8436bdb2a7ce314575940d2f7" id="r_a3d01c0b8436bdb2a7ce314575940d2f7"><td class="memItemLeft">Real_t&#160;</td><td class="memItemRight"><a class="el" href="#a3d01c0b8436bdb2a7ce314575940d2f7">mustbe_Real_t</a> ()</td></tr>
<tr class="memitem:a6c6c1cbc18b59808234273cb1a8765e6" id="r_a6c6c1cbc18b59808234273cb1a8765e6"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a6c6c1cbc18b59808234273cb1a8765e6">mustbe_any_str_t</a> ()</td></tr>
<tr class="memitem:a109ae6cbbb6a3a3a51c12fa032b9e5fa" id="r_a109ae6cbbb6a3a3a51c12fa032b9e5fa"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a109ae6cbbb6a3a3a51c12fa032b9e5fa">mustbe_cppobj_t</a> ()</td></tr>
<tr class="memitem:ac7bb3c494eb42f3f7ced79a5b12174fe" id="r_ac7bb3c494eb42f3f7ced79a5b12174fe"><td class="memItemLeft">CPPDeleterPtr&#160;</td><td class="memItemRight"><a class="el" href="#ac7bb3c494eb42f3f7ced79a5b12174fe">prechecked_cppobj_get_deleter</a> ()</td></tr>
<tr class="memitem:aaec0ece3c1dc827b408a30fccd61ba8f" id="r_aaec0ece3c1dc827b408a30fccd61ba8f"><td class="memItemLeft">Ptr_t&#160;</td><td class="memItemRight"><a class="el" href="#aaec0ece3c1dc827b408a30fccd61ba8f">prechecked_cppobj_get_ptr</a> ()</td></tr>
<tr class="memitem:a92c9653c14a6adeec7a63ac7ecaa4259" id="r_a92c9653c14a6adeec7a63ac7ecaa4259"><td class="memItemLeft"><a id="a92c9653c14a6adeec7a63ac7ecaa4259" name="a92c9653c14a6adeec7a63ac7ecaa4259"></a>
CPPDeleterPtr&#160;</td><td class="memItemRight"><b>any_cppobj_get_deleter</b> ()</td></tr>
<tr class="memitem:af934b6cde67f56a5fa5c4d63a313d6c4" id="r_af934b6cde67f56a5fa5c4d63a313d6c4"><td class="memItemLeft"><a id="af934b6cde67f56a5fa5c4d63a313d6c4" name="af934b6cde67f56a5fa5c4d63a313d6c4"></a>
Ptr_t&#160;</td><td class="memItemRight"><b>any_cppobj_get_ptr</b> ()</td></tr>
<tr class="memitem:a9c77b588991635002db3b146ff6c3b89" id="r_a9c77b588991635002db3b146ff6c3b89"><td class="memItemLeft"><a id="a9c77b588991635002db3b146ff6c3b89" name="a9c77b588991635002db3b146ff6c3b89"></a>
void&#160;</td><td class="memItemRight"><b>any_cppobj_get_info</b> (CPPDeleterPtr &amp;d, Ptr_t &amp;p)</td></tr>
<tr class="memitem:ab69eae1d70e328e11332e670346cec08" id="r_ab69eae1d70e328e11332e670346cec08"><td class="memItemLeft"><a id="ab69eae1d70e328e11332e670346cec08" name="ab69eae1d70e328e11332e670346cec08"></a>
Real_t&#160;</td><td class="memItemRight"><b>coerce_Real_t</b> ()</td></tr>
<tr class="memitem:a9310cef1d784750c37727b1f62bfd6a9" id="r_a9310cef1d784750c37727b1f62bfd6a9"><td class="memItemLeft"><a id="a9310cef1d784750c37727b1f62bfd6a9" name="a9310cef1d784750c37727b1f62bfd6a9"></a>
Real_t&#160;</td><td class="memItemRight"><b>coerce_Int_t</b> ()</td></tr>
<tr class="memitem:a14905a9e8458b26ccf9954117ea18138" id="r_a14905a9e8458b26ccf9954117ea18138"><td class="memItemLeft"><a id="a14905a9e8458b26ccf9954117ea18138" name="a14905a9e8458b26ccf9954117ea18138"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>anypair_get_car</b> ()</td></tr>
<tr class="memitem:abf405e1a3fdfc358fa70b4cb7cf6fbee" id="r_abf405e1a3fdfc358fa70b4cb7cf6fbee"><td class="memItemLeft"><a id="abf405e1a3fdfc358fa70b4cb7cf6fbee" name="abf405e1a3fdfc358fa70b4cb7cf6fbee"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>anypair_get_cdr</b> ()</td></tr>
<tr class="memitem:ae3cb2c44daa50b8b3972b3ff71a985cc" id="r_ae3cb2c44daa50b8b3972b3ff71a985cc"><td class="memItemLeft"><a id="ae3cb2c44daa50b8b3972b3ff71a985cc" name="ae3cb2c44daa50b8b3972b3ff71a985cc"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>error_get_str</b> ()</td></tr>
<tr class="memitem:a6cc29a88d92ef8f4e072939ba0c75585" id="r_a6cc29a88d92ef8f4e072939ba0c75585"><td class="memItemLeft"><a id="a6cc29a88d92ef8f4e072939ba0c75585" name="a6cc29a88d92ef8f4e072939ba0c75585"></a>
Sexpr_t&#160;</td><td class="memItemRight"><b>error_get_irritants</b> ()</td></tr>
<tr class="memitem:ac7607a75b04bf420f7773e30736bfc2a" id="r_ac7607a75b04bf420f7773e30736bfc2a"><td class="memItemLeft"><a id="ac7607a75b04bf420f7773e30736bfc2a" name="ac7607a75b04bf420f7773e30736bfc2a"></a>
Charst_t&#160;</td><td class="memItemRight"><b>error_get_chars</b> ()</td></tr>
<tr class="memitem:a1344828aa95759e8511a49796ad6007a" id="r_a1344828aa95759e8511a49796ad6007a"><td class="memItemLeft"><a id="a1344828aa95759e8511a49796ad6007a" name="a1344828aa95759e8511a49796ad6007a"></a>
Int_t&#160;</td><td class="memItemRight"><b>any_sym_get_hash</b> ()</td></tr>
<tr class="memitem:a65e76c13f0de66790a8df6abc8c58e2a" id="r_a65e76c13f0de66790a8df6abc8c58e2a"><td class="memItemLeft"><a id="a65e76c13f0de66790a8df6abc8c58e2a" name="a65e76c13f0de66790a8df6abc8c58e2a"></a>
Charst_t&#160;</td><td class="memItemRight"><b>any_sym_get_chars</b> ()</td></tr>
<tr class="memitem:a7f0b1a3fe0ebb3a86ebe3b9147dd890c" id="r_a7f0b1a3fe0ebb3a86ebe3b9147dd890c"><td class="memItemLeft"><a id="a7f0b1a3fe0ebb3a86ebe3b9147dd890c" name="a7f0b1a3fe0ebb3a86ebe3b9147dd890c"></a>
void&#160;</td><td class="memItemRight"><b>any_sym_get_info</b> (Int_t &amp;hsh, Charst_t &amp;chars)</td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Operations on strings</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>LambLisp supports several subtypes of <b>strings</b>. At the time of writing, there are heap-allocated strings (read-write), strings whose characters outside of LambLisp's managed memory, (aka external or EXT strings), and short <b>immediate</b> strings that are contained completely within a single cell. Additional subtypes (such as load-on-demand strings) may be added in future.</p>
<p>There are functions of the form any_xxx() that can be used with any subtype, and there are type-specific functions of the form any_xxx_yyy() for use where the type is already known, with yyy being a code hint. </p>
</div></td></tr>
<tr class="memitem:a0dcf7b0134d26f24e32ab61aabffe202" id="r_a0dcf7b0134d26f24e32ab61aabffe202"><td class="memItemLeft">CharVec_t&#160;</td><td class="memItemRight"><a class="el" href="#a0dcf7b0134d26f24e32ab61aabffe202">any_str_get_chars</a> ()</td></tr>
<tr class="memitem:a16dcc5c5da9904bf8621ad1bc59c044c" id="r_a16dcc5c5da9904bf8621ad1bc59c044c"><td class="memItemLeft"><a id="a16dcc5c5da9904bf8621ad1bc59c044c" name="a16dcc5c5da9904bf8621ad1bc59c044c"></a>
Int_t&#160;</td><td class="memItemRight"><b>any_str_get_length</b> ()</td></tr>
<tr class="memitem:a5fa02d8ce624a58328ec0e23e183209b" id="r_a5fa02d8ce624a58328ec0e23e183209b"><td class="memItemLeft"><a id="a5fa02d8ce624a58328ec0e23e183209b" name="a5fa02d8ce624a58328ec0e23e183209b"></a>
void&#160;</td><td class="memItemRight"><b>any_str_get_info</b> (Int_t &amp;len, CharVec_t &amp;chars)</td></tr>
<tr id="pub-methods-8" class="groupHeader"><td colspan="2"><div class="groupHeader">Operations on vectors and sub-types of vectors</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>Within the LambLisp virtual machine, a <em>Lisp vector</em> is referred to as <em>svec</em>. This is an array of S-expressions having a fixed dimension. There are also <em>bytevectors</em>; these are an array of bytes, also of fixed dimension.</p>
<p>As with <em>strings</em>, there are several subtypes of S-expression vectors. There is a heap-allocated vector, which may be of any size. There is a second type of heap-allocated vector, that is always sized to be a power of 2. These are provided to support efficient hash tables. There are immediate vectors, which may be of 0, 1, or 2 elements. The 2-element immediate vector can also be used as a hash table. This can reduce search time by half without requiring any heap allocation, at the cost of 1 extra cell allocation.</p>
<p>Bytevectors are also diverse, having heap, external, and immediate variants. Heap bytevectors are allocated, obviously, on the system heap, and the heap space is freed when the bytevector is garbage-collected.</p>
<p>External bytevectors operate on bytes provided externally to LambLisp's memory manager. This space may heve been dynamically allocated from outside LambLisp, or may be located in read-only memory. When a C++ object os injected into <em>LambLisp</em>, it can optionally be provided with a garbage collector callback; in that case the external object can be automatically garbage collected when no it's longer used in the <em>Lisp</em> program.</p>
<p>Immediate bytevectors are contained within a LambLisp <a class="el" href="classCell.html">Cell</a>. The maximum size is limited by the word size of the underlying platform.</p>
<p>Within the <em>LambLisp</em> virtual machine, there are generic functions of the form any_xvec_xxx() that can operate on any xvec (svec or bvec) subtype, as well as type-specific functions of the form xvec_yyy_xxx(), where yyy is a code hint for the cell storage type (heap, immediate, ROM). </p>
</div></td></tr>
<tr class="memitem:a5a5526de496622ea9c87c604c8409cee" id="r_a5a5526de496622ea9c87c604c8409cee"><td class="memItemLeft"><a id="a5a5526de496622ea9c87c604c8409cee" name="a5a5526de496622ea9c87c604c8409cee"></a>
void&#160;</td><td class="memItemRight"><b>any_svec_get_info</b> (Int_t &amp;Nelems, Sexpr_t *&amp;elems)</td></tr>
<tr class="memitem:a529188e3315a5b6704afc0e4cfe25b5a" id="r_a529188e3315a5b6704afc0e4cfe25b5a"><td class="memItemLeft"><a id="a529188e3315a5b6704afc0e4cfe25b5a" name="a529188e3315a5b6704afc0e4cfe25b5a"></a>
Sexpr_t *&#160;</td><td class="memItemRight"><b>any_svec_get_elems</b> ()</td></tr>
<tr class="memitem:a1ce3ddd109644c647280cd8f697ad97b" id="r_a1ce3ddd109644c647280cd8f697ad97b"><td class="memItemLeft"><a id="a1ce3ddd109644c647280cd8f697ad97b" name="a1ce3ddd109644c647280cd8f697ad97b"></a>
Int_t&#160;</td><td class="memItemRight"><b>any_bvec_get_length</b> ()</td></tr>
<tr class="memitem:aed5b94b452d9e156ef96943271811889" id="r_aed5b94b452d9e156ef96943271811889"><td class="memItemLeft"><a id="aed5b94b452d9e156ef96943271811889" name="aed5b94b452d9e156ef96943271811889"></a>
ByteVec_t&#160;</td><td class="memItemRight"><b>any_bvec_get_elems</b> ()</td></tr>
<tr class="memitem:af6ecb21e9d66a69f5eb153fa1988b22e" id="r_af6ecb21e9d66a69f5eb153fa1988b22e"><td class="memItemLeft"><a id="af6ecb21e9d66a69f5eb153fa1988b22e" name="af6ecb21e9d66a69f5eb153fa1988b22e"></a>
void&#160;</td><td class="memItemRight"><b>any_bvec_get_info</b> (Int_t &amp;Nelems, ByteVec_t &amp;elems)</td></tr>
<tr id="pub-methods-9" class="groupHeader"><td colspan="2"><div class="groupHeader">Cell conversions to printable representation</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These functions convert a <a class="el" href="classCell.html">Cell</a> (or parts of a <a class="el" href="classCell.html">Cell</a>) to a printable representation of the S-expression contents of the <a class="el" href="classCell.html">Cell</a>. Because environments are often included in the descendants of the <a class="el" href="classCell.html">Cell</a> being printed, the depth of environment recursiveness is limited. </p>
</div></td></tr>
<tr class="memitem:a29b39708a4fa37c77baaee15653f27e9" id="r_a29b39708a4fa37c77baaee15653f27e9"><td class="memItemLeft">String&#160;</td><td class="memItemRight"><a class="el" href="#a29b39708a4fa37c77baaee15653f27e9">cell_name</a> (void)</td></tr>
<tr class="memitem:a4fe9d8d3ced099a8fe88c812c7ae872f" id="r_a4fe9d8d3ced099a8fe88c812c7ae872f"><td class="memItemLeft">Charst_t&#160;</td><td class="memItemRight"><a class="el" href="#a4fe9d8d3ced099a8fe88c812c7ae872f">type_name</a> (Int_t typ)</td></tr>
<tr class="memitem:a8e63f5e2e20f30c1dae02a2b2b6833e1" id="r_a8e63f5e2e20f30c1dae02a2b2b6833e1"><td class="memItemLeft"><a id="a8e63f5e2e20f30c1dae02a2b2b6833e1" name="a8e63f5e2e20f30c1dae02a2b2b6833e1"></a>
Charst_t&#160;</td><td class="memItemRight"><b>type_name</b> (void)</td></tr>
<tr class="memitem:ae705e68c441fbb2edfb28297412c265e" id="r_ae705e68c441fbb2edfb28297412c265e"><td class="memItemLeft">Charst_t&#160;</td><td class="memItemRight"><a class="el" href="#ae705e68c441fbb2edfb28297412c265e">gcstate_name</a> (void)</td></tr>
<tr class="memitem:ae7c2815a58b1ca3b156e695ff3edb3e5" id="r_ae7c2815a58b1ca3b156e695ff3edb3e5"><td class="memItemLeft">String&#160;</td><td class="memItemRight"><a class="el" href="#ae7c2815a58b1ca3b156e695ff3edb3e5">dump</a> ()</td></tr>
<tr class="memitem:a411a06c2f2ae8cd03d91e0074a8813a2" id="r_a411a06c2f2ae8cd03d91e0074a8813a2"><td class="memItemLeft"><a id="a411a06c2f2ae8cd03d91e0074a8813a2" name="a411a06c2f2ae8cd03d91e0074a8813a2"></a>
String&#160;</td><td class="memItemRight"><b>str</b> (Sexpr_t sx, Bool_t as_write_or_display, Int_t env_depth, Int_t max_depth)</td></tr>
<tr class="memitem:ac9db3337dcf78aa29823cc8c06b8b490" id="r_ac9db3337dcf78aa29823cc8c06b8b490"><td class="memItemLeft"><a id="ac9db3337dcf78aa29823cc8c06b8b490" name="ac9db3337dcf78aa29823cc8c06b8b490"></a>
String&#160;</td><td class="memItemRight"><b>str</b> (Bool_t as_write_or_display, Int_t env_depth, Int_t max_depth)</td></tr>
<tr class="memitem:a1ae5973a3cd3229f96aa933a42b607d1" id="r_a1ae5973a3cd3229f96aa933a42b607d1"><td class="memItemLeft"><a id="a1ae5973a3cd3229f96aa933a42b607d1" name="a1ae5973a3cd3229f96aa933a42b607d1"></a>
String&#160;</td><td class="memItemRight"><b>str</b> (Bool_t as_write_or_display, Int_t env_depth)</td></tr>
<tr class="memitem:ac5182a357be91bcb05657a4252da211a" id="r_ac5182a357be91bcb05657a4252da211a"><td class="memItemLeft"><a id="ac5182a357be91bcb05657a4252da211a" name="ac5182a357be91bcb05657a4252da211a"></a>
String&#160;</td><td class="memItemRight"><b>str</b> (Bool_t as_write_or_display)</td></tr>
<tr class="memitem:a9f0576fcd78276e854e43cefb07a33e9" id="r_a9f0576fcd78276e854e43cefb07a33e9"><td class="memItemLeft"><a id="a9f0576fcd78276e854e43cefb07a33e9" name="a9f0576fcd78276e854e43cefb07a33e9"></a>
String&#160;</td><td class="memItemRight"><b>str</b> (Int_t env_depth)</td></tr>
<tr class="memitem:ae9a1b78302b7c808cd8cca145d62eda3" id="r_ae9a1b78302b7c808cd8cca145d62eda3"><td class="memItemLeft"><a id="ae9a1b78302b7c808cd8cca145d62eda3" name="ae9a1b78302b7c808cd8cca145d62eda3"></a>
String&#160;</td><td class="memItemRight"><b>str</b> (void)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr id="pub-static-attribs-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Cell flags, including gc states for multi-pass incremental gc, tail marker, and spares.</div></td></tr>
<tr class="memitem:a78860a53881062feafa9524b900ab607" id="r_a78860a53881062feafa9524b900ab607"><td class="memItemLeft">static const int&#160;</td><td class="memItemRight"><a class="el" href="#a78860a53881062feafa9524b900ab607">F_GC01</a> = 0x01</td></tr>
<tr class="memitem:a027e3fa2f49761b94c09423a9c89e1b1" id="r_a027e3fa2f49761b94c09423a9c89e1b1"><td class="memItemLeft">static const int&#160;</td><td class="memItemRight"><a class="el" href="#a027e3fa2f49761b94c09423a9c89e1b1">F_GC02</a> = 0x02</td></tr>
<tr class="memitem:a3cd531cc4ef1100b395eeca92a603d72" id="r_a3cd531cc4ef1100b395eeca92a603d72"><td class="memItemLeft">static const int&#160;</td><td class="memItemRight"><a class="el" href="#a3cd531cc4ef1100b395eeca92a603d72">F_GC04</a> = 0x04</td></tr>
<tr class="memitem:aa2b70e77b196c841b8b199c0809bd7c7" id="r_aa2b70e77b196c841b8b199c0809bd7c7"><td class="memItemLeft">static const int&#160;</td><td class="memItemRight"><a class="el" href="#aa2b70e77b196c841b8b199c0809bd7c7">F_TAIL</a> = 0x08</td></tr>
<tr class="memitem:ad199c6c6035e34426c0343962ec255c3" id="r_ad199c6c6035e34426c0343962ec255c3"><td class="memItemLeft">static const int&#160;</td><td class="memItemRight"><a class="el" href="#ad199c6c6035e34426c0343962ec255c3">F_0x10</a> = 0x10</td></tr>
<tr class="memitem:a50e8a9c36343cec6db6a681850e4db3c" id="r_a50e8a9c36343cec6db6a681850e4db3c"><td class="memItemLeft">static const int&#160;</td><td class="memItemRight"><a class="el" href="#a50e8a9c36343cec6db6a681850e4db3c">F_0x20</a> = 0x20</td></tr>
<tr class="memitem:a514b8fb854bf5aaeb7b8e1f5c0496b09" id="r_a514b8fb854bf5aaeb7b8e1f5c0496b09"><td class="memItemLeft">static const int&#160;</td><td class="memItemRight"><a class="el" href="#a514b8fb854bf5aaeb7b8e1f5c0496b09">F_0x40</a> = 0x40</td></tr>
<tr class="memitem:a8726664297b2bfa4229fac1bfa2e8462" id="r_a8726664297b2bfa4229fac1bfa2e8462"><td class="memItemLeft">static const int&#160;</td><td class="memItemRight"><a class="el" href="#a8726664297b2bfa4229fac1bfa2e8462">F_0x80</a> = 0x80</td></tr>
<tr class="memitem:a52c97a089e5a0c7c89a0243bfe5b6a34" id="r_a52c97a089e5a0c7c89a0243bfe5b6a34"><td class="memItemLeft">static const int&#160;</td><td class="memItemRight"><a class="el" href="#a52c97a089e5a0c7c89a0243bfe5b6a34">GC_STATE_MASK</a> = <a class="el" href="#a78860a53881062feafa9524b900ab607">F_GC01</a> | <a class="el" href="#a027e3fa2f49761b94c09423a9c89e1b1">F_GC02</a> | <a class="el" href="#a3cd531cc4ef1100b395eeca92a603d72">F_GC04</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Flag testing &amp; setting for garbage collection and tail recursion.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The garbage collection algorithm is based on the <em>tricolor abstraction</em> described in <em>Dijkstra 1978</em>. The original set of 3 colors was enlarged to 4 with <em>Kung and Song 1977</em>, with their correctness proof of the incremental GC algorithm. In LambLisp, is is useful to have a fifth state, and to think of the state or color as a stage in the <a class="el" href="classCell.html">Cell</a> life cycle. When GC is in progress, Cells may advance in their life cycle, but may also be moved back to an earlier as the result of an assignment. This enumeration allows some tests to be combined in an inequality rather than a sequence of equality tests or s C <span class="tt">switch</span>.</p>
<p>LambLisp* uses a <b>trampoline technique</b> to implement tail recursion. The <b>tail</b> of a series of expressions is the last one evaluated; this is the expression that will return the value of the series.</p>
<p>In the <em>trampoline</em>, instead of evaluating the last expression in the series and returning the value (as in C/C++), the expression is returned unevaluated, with the <b>tail flag</b> set. The evaluator checks every result to see if it is a <em>tail</em> that needs additional evaluation, or is a final result to be returned.</p>
<p>This removes the need for an additional stack frame during recursion. </p>
</td></tr>
<tr class="memitem:ae8f0b9f40f211357cd2bbaaf5787beb9" id="r_ae8f0b9f40f211357cd2bbaaf5787beb9"><td class="memItemLeft"><a id="ae8f0b9f40f211357cd2bbaaf5787beb9" name="ae8f0b9f40f211357cd2bbaaf5787beb9"></a>enum &#160;</td><td class="memItemRight">{ <br />
&#160;&#160;<b>gcst_idle</b>
, <b>gcst_issued</b>
, <b>gcst_stacked</b>
, <b>gcst_marked</b>
, <br />
&#160;&#160;<b>gcst_free</b>
, <b>Ngcstates</b>
<br />
 }</td></tr>
<tr class="memitem:a95ef2701ff15d502f729e128d5bddc82" id="r_a95ef2701ff15d502f729e128d5bddc82"><td class="memItemLeft">Int_t&#160;</td><td class="memItemRight"><a class="el" href="#a95ef2701ff15d502f729e128d5bddc82">gc_state</a> (void)</td></tr>
<tr class="memitem:aa0e98682c9df7e0a1c71e9594509d4ae" id="r_aa0e98682c9df7e0a1c71e9594509d4ae"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#aa0e98682c9df7e0a1c71e9594509d4ae">gc_state</a> (Int_t st)</td></tr>
<tr class="memitem:abd6ff16232e2765d260e26ca4cb3b274" id="r_abd6ff16232e2765d260e26ca4cb3b274"><td class="memItemLeft">Int_t&#160;</td><td class="memItemRight"><a class="el" href="#abd6ff16232e2765d260e26ca4cb3b274">tail_state</a> (void)</td></tr>
<tr class="memitem:a4affea4c0ae33200868f78f1248ed5cc" id="r_a4affea4c0ae33200868f78f1248ed5cc"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#a4affea4c0ae33200868f78f1248ed5cc">tail_state_set</a> (void)</td></tr>
<tr class="memitem:ab967e9b70c0c94116ebb3c76c85bf3d8" id="r_ab967e9b70c0c94116ebb3c76c85bf3d8"><td class="memItemLeft">Sexpr_t&#160;</td><td class="memItemRight"><a class="el" href="#ab967e9b70c0c94116ebb3c76c85bf3d8">tail_state_clr</a> (void)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Cell type testing</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The cell type enumeration has been designed to group together cell types according to their most common operations.</p>
<p>The main groups are those needing special sweep and finalizing during garbage collection, those that are treated as pairs, and simple atoms. There is a subgroup of those needing special sweep, that also need specialised marking during the garbage collection mark phase.</p>
<p>There are some types that have optimized subtypes (such as <b>immediate</b> types), and they differ in their processing at GC time. Type-testing functions below have <span class="tt">is_any_x()</span> predicates that group all subtypes together (e.g., <span class="tt"><a class="el" href="#a1bd97610f104dd6e72a81d7e1bad1d70" title="Return true if the cell is any kind of string.">is_any_str_atom()</a></span> returns <b>true</b> for any type of string (heap, immediate, external). There are also functions further down that will return the contents of complex cells, and throw an error if called with incorrect type. Therefore it is often not necessary to use the predicates before accessing the atom internals with <span class="tt">any_x_get_info()</span>.</p>
<p>Note also: it is sometimes faster to check the types directly, rather than check the cell feature table. Preliminary testing indicates more than 2 type tests should use the table instead. </p>
</td></tr>
<tr class="memitem:"><td class="memItemLeft anon"><a id="ac61217fdbbf7a08ee82d784f78640ad1" name="ac61217fdbbf7a08ee82d784f78640ad1"></a>
typedef struct {&#160;</td><td class="memItemRight"></td></tr>
<tr class="memitem:a0b45b2744d83785cb670ce219d499e3d" id="r_a0b45b2744d83785cb670ce219d499e3d"><td class="memItemLeft anon">
&#160;&#160;&#160;Int_t&#160;&#160;&#160;<b>typ</b>&#160;</td><td class="memItemRight"></td></tr>
<tr class="memitem:ac07b39885c77946a7e96b8b154a67c53" id="r_ac07b39885c77946a7e96b8b154a67c53"><td class="memItemLeft anon">
&#160;&#160;&#160;bool&#160;&#160;&#160;<b>is_any_pair</b>&#160;</td><td class="memItemRight"></td></tr>
<tr class="memitem:acdceb2757bc91544e4d0e6b3136333dc" id="r_acdceb2757bc91544e4d0e6b3136333dc"><td class="memItemLeft anon">
&#160;&#160;&#160;bool&#160;&#160;&#160;<b>is_any_svec</b>&#160;</td><td class="memItemRight"></td></tr>
<tr class="memitem:a284e0bc9eac2acb4da05f249d1d36254" id="r_a284e0bc9eac2acb4da05f249d1d36254"><td class="memItemLeft anon">
&#160;&#160;&#160;bool&#160;&#160;&#160;<b>is_any_svec2n</b>&#160;</td><td class="memItemRight"></td></tr>
<tr class="memitem:a54c940afbc5ad47f1edd8c492f3454c9" id="r_a54c940afbc5ad47f1edd8c492f3454c9"><td class="memItemLeft anon">
&#160;&#160;&#160;bool&#160;&#160;&#160;<b>is_any_str</b>&#160;</td><td class="memItemRight"></td></tr>
<tr class="memitem:a9601333587a52aedab7e5744282bbaed" id="r_a9601333587a52aedab7e5744282bbaed"><td class="memItemLeft anon">
&#160;&#160;&#160;bool&#160;&#160;&#160;<b>is_any_sym</b>&#160;</td><td class="memItemRight"></td></tr>
<tr class="memitem:a7ef79cb1bf5de3fdb9e5a8ab10394110" id="r_a7ef79cb1bf5de3fdb9e5a8ab10394110"><td class="memItemLeft anon">
&#160;&#160;&#160;bool&#160;&#160;&#160;<b>is_any_bvec</b>&#160;</td><td class="memItemRight"></td></tr>
<tr class="memitem:a3bb6b176a0c9529f731e9a110225b336" id="r_a3bb6b176a0c9529f731e9a110225b336"><td class="memItemLeft anon">
&#160;&#160;&#160;const char *&#160;&#160;&#160;<b>type_name</b>&#160;</td><td class="memItemRight"></td></tr>
<tr class="memitem:ac61217fdbbf7a08ee82d784f78640ad1" id="r_ac61217fdbbf7a08ee82d784f78640ad1"><td class="memItemLeft anonEnd">}&#160;</td><td class="memItemRight"><b>CellFeatures</b></td></tr>
<tr class="memitem:a7d19fb85805984e29a6e900c04e98f6f" id="r_a7d19fb85805984e29a6e900c04e98f6f"><td class="memItemLeft"><a id="a7d19fb85805984e29a6e900c04e98f6f" name="a7d19fb85805984e29a6e900c04e98f6f"></a>
static const CellFeatures&#160;</td><td class="memItemRight"><b>features</b> [<a class="el" href="#aa11b65afd71903a81bbc611dcf5b3b8caa222aa22504f258f7550461e9c88b152">Ntypes</a>]</td></tr>
<tr class="memitem:ac01db823c3229f1cfad804068c68d344" id="r_ac01db823c3229f1cfad804068c68d344"><td class="memItemLeft"><a id="ac01db823c3229f1cfad804068c68d344" name="ac01db823c3229f1cfad804068c68d344"></a>
void&#160;</td><td class="memItemRight"><b>init_static_data</b> ()</td></tr>
<tr class="memitem:a63b59ab22aa4372dcce06d2a0f20ba46" id="r_a63b59ab22aa4372dcce06d2a0f20ba46"><td class="memItemLeft">Bool_t&#160;</td><td class="memItemRight"><a class="el" href="#a63b59ab22aa4372dcce06d2a0f20ba46">is_atom</a> (void)</td></tr>
<tr class="memitem:a8af6cbcc5f3057412cc64fd25c668e77" id="r_a8af6cbcc5f3057412cc64fd25c668e77"><td class="memItemLeft">Bool_t&#160;</td><td class="memItemRight"><a class="el" href="#a8af6cbcc5f3057412cc64fd25c668e77">is_pair</a> (void)</td></tr>
<tr class="memitem:a0ace83f0459ee051617d80ba1bcc303a" id="r_a0ace83f0459ee051617d80ba1bcc303a"><td class="memItemLeft">Bool_t&#160;</td><td class="memItemRight"><a class="el" href="#a0ace83f0459ee051617d80ba1bcc303a">is_any_pair</a> (void)</td></tr>
<tr class="memitem:a7df28c99369d118e8f0e7b915b7f873d" id="r_a7df28c99369d118e8f0e7b915b7f873d"><td class="memItemLeft">Bool_t&#160;</td><td class="memItemRight"><a class="el" href="#a7df28c99369d118e8f0e7b915b7f873d">is_any_svec_atom</a> ()</td></tr>
<tr class="memitem:a2633575b3e20f43d469e8b8155d013b8" id="r_a2633575b3e20f43d469e8b8155d013b8"><td class="memItemLeft">Bool_t&#160;</td><td class="memItemRight"><a class="el" href="#a2633575b3e20f43d469e8b8155d013b8">is_any_svec2n_atom</a> ()</td></tr>
<tr class="memitem:a1bd97610f104dd6e72a81d7e1bad1d70" id="r_a1bd97610f104dd6e72a81d7e1bad1d70"><td class="memItemLeft">Bool_t&#160;</td><td class="memItemRight"><a class="el" href="#a1bd97610f104dd6e72a81d7e1bad1d70">is_any_str_atom</a> (void)</td></tr>
<tr class="memitem:ab84341b23ed8d9c566656be04af1da2d" id="r_ab84341b23ed8d9c566656be04af1da2d"><td class="memItemLeft">Bool_t&#160;</td><td class="memItemRight"><a class="el" href="#ab84341b23ed8d9c566656be04af1da2d">is_any_sym_atom</a> (void)</td></tr>
<tr class="memitem:a4c2d9d0a2383caf1fabe82ac11954560" id="r_a4c2d9d0a2383caf1fabe82ac11954560"><td class="memItemLeft">Bool_t&#160;</td><td class="memItemRight"><a class="el" href="#a4c2d9d0a2383caf1fabe82ac11954560">is_any_bvec_atom</a> (void)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classCell.html">Cell</a> class is the foundational class for the LambLisp Virtual Machine.</p>
<p>Nearly all the <a class="el" href="classCell.html">Cell</a> methods are <em>inline</em> for performance. A <a class="el" href="classCell.html">Cell</a> has only getters and setters; there are no other side effects. <a class="el" href="classCell.html">Cell</a> fields are changed only through explicit requests, and not as the result of any other mutations. This means that Cells do not participate in garbage collection, which is managed from outside the <a class="el" href="classCell.html">Cell</a> class. Indeed, there is no concept within the <a class="el" href="classCell.html">Cell</a> that there might be a plurality of them; only the behavior of a single <a class="el" href="classCell.html">Cell</a> is defined.</p>
<p>A <a class="el" href="classCell.html">Cell</a> may be one of several types. Historically, the number of types varied with the variant of Lisp. In LambLisp, there are <a class="el" href="classCell.html">Cell</a> types that correspond directly to the types described in the <em>Scheme RxRS</em> specifications (integers, procedures etc), and there are additional types that implement underlying behavior to support the higher-level language (thunks, dictionaries).</p>
<p>For example, LambLisp supports several types of <em>strings</em> internally, depending on whether the character are stored on the heap, in externally-provided memory, or immediately within the cell (for fast operations on short strings). Each of these <em>string</em> types is compatible with the string type in the <em>Scheme RxRS</em> specifications. Likewise, bytevectors have external and immediate variants.</p>
<p>LambLisp also supports specialized <em>pair</em> types, such as the LambLisp <em>dictionary</em>. These act as <em>Lisp</em> pairs for purposes of allocation and garbage collection, but their specialized operators are executed by the underlying LambLisp virtual machine and therefore operate at C++ speed.</p>
<p>The <a class="el" href="classCell.html">Cell</a> type enumeration is purposefully ordered in such a way as to allow efficient integer comparisons instead of a C switch in most cases, enhancing runtime performance as well as garbage collection.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="classCell.html">Cell</a> enumeration characteristics:  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Cells requiring submarking  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Cells requiring finalizing  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Simple atoms: immediate cell types like bool char int real etc  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">External (non-GC) objects and pointers to native C++ code  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Cells that point to C++-allocated objects, paired with optional GC finalizers.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"well-known singleton atoms" such as NIL, undefined, and void types.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Pair - the <a class="el" href="classCell.html">Cell</a> type that responds to the Lisp <em>pair?</em> predicate.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Other pairs - specialized pair types  </td></tr>
</table>
<p>With this ordering of <a class="el" href="classCell.html">Cell</a> types, the solution to many common cases during expression evaluation can be obtained with an inequality, rather than a C++ <em>switch</em> statement. This provides a significant performance boost, because the most common cases are checked first, and the total number of cases is reduced.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="classCell.html">Cell</a> optimized type tests  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">(Types &lt; "simple atoms") need specialized GC marking and heap reclamation.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(Types &lt;= "cells requiring finalizing") need specialized GC heap reclamation.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">(Types &gt;= T_NIL) are lists.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(Types &gt; T_NIL) are pairs (but not only <em>Lisp</em> pairs, extended pairs too).  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">(Types != T_PAIR) are atoms, including numbers, strings, vectors, and singletons such as NIL.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(Types &gt; T_PAIR) are extended pairs, used for specialized lists known to LambVM, but receiving regular <em>pair</em> GC processing.  </td></tr>
</table>
<p>There are cases where the ordering does not help so much. For example the LambLisp type system allows for several types of strings. Because the type system is ordered according to GC requirements, these are not adjacent in the enumeration and less amenable to inequality tests. For these cases, there is a cell feature matrix available to be queried by type and feature. This allows the determination to be made with an array lookup, which is faster than several sequential tests or a C <em>switch</em>, putting a permanent cap on the cost of a type check. It also allows other details such as <span class="tt">is-immediate?</span> to be implemented inexpensively.</p>
<p>The garbage collector states are ordered for similar reasons. See the garbage collector chapter for details on the <a class="el" href="classCell.html">Cell</a> life cycle. </p>
</div><a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="aa11b65afd71903a81bbc611dcf5b3b8c" name="aa11b65afd71903a81bbc611dcf5b3b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11b65afd71903a81bbc611dcf5b3b8c">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca34c898f666ae7b1cd78e138fe3805896" name="aa11b65afd71903a81bbc611dcf5b3b8ca34c898f666ae7b1cd78e138fe3805896"></a>T_SVEC_HEAP&#160;</td><td class="fielddoc"><p>(Int_t Sexpr_t[]) A vector of Sexprs is a (len Sexpr_t*) pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca419215921b4442d1d11142ba4c63d6dd" name="aa11b65afd71903a81bbc611dcf5b3b8ca419215921b4442d1d11142ba4c63d6dd"></a>T_SVEC2N_HEAP&#160;</td><td class="fielddoc"><p>(Int_t Sexpr_t[]) Same as vector, but length must be a power of 2; useful for hash tables. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8cae3c2432ff84ab3007e9ad3bb3554290d" name="aa11b65afd71903a81bbc611dcf5b3b8cae3c2432ff84ab3007e9ad3bb3554290d"></a>T_ANY_HEAP_SVEC&#160;</td><td class="fielddoc"><p>Any types less than or equal to this are heap-stored vectors of S-expressions. They need specialized marking at GC time. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca8ab19c778062aec94fb9a1a1dcebb644" name="aa11b65afd71903a81bbc611dcf5b3b8ca8ab19c778062aec94fb9a1a1dcebb644"></a>T_SYM_HEAP&#160;</td><td class="fielddoc"><p>(Int_t Charst_t) Symbol is a (hash char*) pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca879397f195a8fed9db3734e90b17a5fc" name="aa11b65afd71903a81bbc611dcf5b3b8ca879397f195a8fed9db3734e90b17a5fc"></a>T_BVEC_HEAP&#160;</td><td class="fielddoc"><p>(Int_t Bytest_t) Bytevector is a (len byte*) pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca88560b011409adab2b1456d5bd498cdf" name="aa11b65afd71903a81bbc611dcf5b3b8ca88560b011409adab2b1456d5bd498cdf"></a>T_STR_HEAP&#160;</td><td class="fielddoc"><p>(reserved Charst_t) The reserved field may be used in future to store the string length (not possible with immediate strings, so some details to be worked). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca7768ac295eae706204b55f6664701aab" name="aa11b65afd71903a81bbc611dcf5b3b8ca7768ac295eae706204b55f6664701aab"></a>T_CPP_HEAP&#160;</td><td class="fielddoc"><p>(ptr-to-cpp-deleter ptr-to-cpp-object) Deleter is a function <span class="tt">void f(void *cpp_obj)</span> of the appropriate type T of the C++ object, and performes <span class="tt">delete (T *) cpp_obj;</span> </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca2e03113f4fa69af6344fda68d2a41bf7" name="aa11b65afd71903a81bbc611dcf5b3b8ca2e03113f4fa69af6344fda68d2a41bf7"></a>T_PORT_HEAP&#160;</td><td class="fielddoc"><p>(reserved Ptr_t) car is unused, cdr is ptr to underlying C++ port instance </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca1aef18ad4c492ee07632b3e80e8fb69a" name="aa11b65afd71903a81bbc611dcf5b3b8ca1aef18ad4c492ee07632b3e80e8fb69a"></a>T_NEEDS_FINALIZING&#160;</td><td class="fielddoc"><p>Any types less than or equal to this have data stored in the heap, and need specialized finalizing at GC time. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca342541e1951e63d9fcdeae16376691d2" name="aa11b65afd71903a81bbc611dcf5b3b8ca342541e1951e63d9fcdeae16376691d2"></a>T_BVEC_EXT&#160;</td><td class="fielddoc"><p>(Int_t Bytest_t) Same as T_BYTEVEC but externally allocated; the byte array is not freed at GC time. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca003bac7c143522cfb88cb7998a88c6e1" name="aa11b65afd71903a81bbc611dcf5b3b8ca003bac7c143522cfb88cb7998a88c6e1"></a>T_STR_EXT&#160;</td><td class="fielddoc"><p>(reserved Charst_t) Same as T_STR but externally allocated; the character array is not freed at GC time. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca2b9c906cd20f95a4b1aca242103dfcc5" name="aa11b65afd71903a81bbc611dcf5b3b8ca2b9c906cd20f95a4b1aca242103dfcc5"></a>T_BVEC_IMM&#160;</td><td class="fielddoc"><p>Special format: type and flag bytes as usual, byte 2 is vector length, remaining bytes are vector elements. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8cafc1ecdcd1708cbc2d16275990de41cf6" name="aa11b65afd71903a81bbc611dcf5b3b8cafc1ecdcd1708cbc2d16275990de41cf6"></a>T_STR_IMM&#160;</td><td class="fielddoc"><p>Special format: type and flag bytes as usual, remaining bytes are 0-terminated string embedded in the cell. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca3eeaf9b8541ed055954a9acf88173c95" name="aa11b65afd71903a81bbc611dcf5b3b8ca3eeaf9b8541ed055954a9acf88173c95"></a>T_GENSYM&#160;</td><td class="fielddoc"><p>Runtime symbol generation with no heap operations. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8cad42fbbdccc92d223e29392cd8ec73a68" name="aa11b65afd71903a81bbc611dcf5b3b8cad42fbbdccc92d223e29392cd8ec73a68"></a>T_BOOL&#160;</td><td class="fielddoc"><p>(Bool_t reserved) Boolean atom </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca08f796237599216e7d2fe5e228a9af6a" name="aa11b65afd71903a81bbc611dcf5b3b8ca08f796237599216e7d2fe5e228a9af6a"></a>T_CHAR&#160;</td><td class="fielddoc"><p>(Char_t reserved) Character atom </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca376763b8c92a0384401f9422bcb72ba3" name="aa11b65afd71903a81bbc611dcf5b3b8ca376763b8c92a0384401f9422bcb72ba3"></a>T_INT&#160;</td><td class="fielddoc"><p>(Int_t reserved) Integer atom </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8cac1b31c80ab486e824e2efb5bd51937f1" name="aa11b65afd71903a81bbc611dcf5b3b8cac1b31c80ab486e824e2efb5bd51937f1"></a>T_REAL&#160;</td><td class="fielddoc"><p>(Special format: Real_t uses double word) Real number atom </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8cafd4fc46b1ef43d0bfe15dd988add143f" name="aa11b65afd71903a81bbc611dcf5b3b8cafd4fc46b1ef43d0bfe15dd988add143f"></a>T_RATIONAL&#160;</td><td class="fielddoc"><p>(Int_t Int_t) The fields are numerator and denominator of a rational number. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8cae7e0fb7d2964e355d3511ce9937ffb7d" name="aa11b65afd71903a81bbc611dcf5b3b8cae7e0fb7d2964e355d3511ce9937ffb7d"></a>T_MOP3_PROC&#160;</td><td class="fielddoc"><p>(reserved *Mop3st_t) pointer to native function - args are evaluated before calling </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8caa0c452a237d17de864a87b55ffc0a1ca" name="aa11b65afd71903a81bbc611dcf5b3b8caa0c452a237d17de864a87b55ffc0a1ca"></a>T_MOP3_NPROC&#160;</td><td class="fielddoc"><p>(reserved *Mop3st_t) pointer to native macro processor - args are not evaluated before calling </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca3621c153246bc6d5edeb45ddf30c2f77" name="aa11b65afd71903a81bbc611dcf5b3b8ca3621c153246bc6d5edeb45ddf30c2f77"></a>T_VOID&#160;</td><td class="fielddoc"><p>(don't care) VOID has its own type and a singleton instance OBJ_VOID </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca526409f000bb42377070662b985b281a" name="aa11b65afd71903a81bbc611dcf5b3b8ca526409f000bb42377070662b985b281a"></a>T_UNDEF&#160;</td><td class="fielddoc"><p>(ERROR ERROR) UNDEF has its own type and a singleton instance OBJ_UNDEF </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca8764542fbfeec3419c75b33dbd5a5261" name="aa11b65afd71903a81bbc611dcf5b3b8ca8764542fbfeec3419c75b33dbd5a5261"></a>T_NIL&#160;</td><td class="fielddoc"><p>(ERROR ERROR) NIL has its own type and a singleton instance. </p>
<ul>
<li><p class="startli">The NIL singleton is both a list and an atom, but not a pair.</p>
</li>
<li><p class="startli">Types &lt;= T_NIL are atoms, types &gt;= T_NIL are lists, types &gt; T_NIL are pairs, but only T_PAIR responds to the Scheme <em>pair?</em> predicate. </p>
</li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca37c9f1f9a1e3f5faa0e1ce8f44032b4f" name="aa11b65afd71903a81bbc611dcf5b3b8ca37c9f1f9a1e3f5faa0e1ce8f44032b4f"></a>T_PAIR&#160;</td><td class="fielddoc"><p>(Sexpr_t Sexpr_t) Normal untyped cons cell. All C++ types &lt; T_PAIR are atoms. </p>
<ul>
<li><p class="startli">Pair types. Types &gt; NIL and types &gt;= T_PAIR are pairs, but only T_PAIR responds to Scheme (pair?).</p>
</li>
<li><p class="startli">All pair types can be garbage collected without type-specific GC marking or finalizing. </p>
</li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8cabfa5235660df11ed7d225d7bf02403fa" name="aa11b65afd71903a81bbc611dcf5b3b8cabfa5235660df11ed7d225d7bf02403fa"></a>T_SVEC_IMM&#160;</td><td class="fielddoc"><p>(Sexpr_t Sexpr_t) Vector of 0, 1 or 2 elements. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8cad01c5c3afca169d5752437aad874a13e" name="aa11b65afd71903a81bbc611dcf5b3b8cad01c5c3afca169d5752437aad874a13e"></a>T_PROC&#160;</td><td class="fielddoc"><p>(Sexpr_t Sexpr_t) Procedure pair; car is lambda (formals + body containing free variables), cdr is environment. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8cae432c7864195cfb23f2cefcb6b4966b0" name="aa11b65afd71903a81bbc611dcf5b3b8cae432c7864195cfb23f2cefcb6b4966b0"></a>T_NPROC&#160;</td><td class="fielddoc"><p>(Sexpr_t Sexpr_t) Non-evaluating procedure pair; car is nlambda (formals + body containing free variables), cdr is environment. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca47360afc9a084831e79a16bf53b37a0c" name="aa11b65afd71903a81bbc611dcf5b3b8ca47360afc9a084831e79a16bf53b37a0c"></a>T_MACRO&#160;</td><td class="fielddoc"><p>(Sexpr_t Sexpr_t) Macro; car is transformer (proc of 1 arg) and cdr is env. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8cad6cd21de81fa6dbffd8e8e5a727b888a" name="aa11b65afd71903a81bbc611dcf5b3b8cad6cd21de81fa6dbffd8e8e5a727b888a"></a>T_DICT&#160;</td><td class="fielddoc"><p>(Sexpr_t Sexpr_t) Dictionary pair; car is local frame, cdr is list of parent frames, used for environments &amp; object instances. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca590421f2b070efbc217c95c8c42b3c37" name="aa11b65afd71903a81bbc611dcf5b3b8ca590421f2b070efbc217c95c8c42b3c37"></a>T_THUNK_SEXPR&#160;</td><td class="fielddoc"><p>(Sexpr_t Sexpr_t) S-expression thunk pair; car is sexpr, cdr is environment with all variable bindings. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca7d1e0fccb360f16b598aefe7f00e2b53" name="aa11b65afd71903a81bbc611dcf5b3b8ca7d1e0fccb360f16b598aefe7f00e2b53"></a>T_THUNK_BODY&#160;</td><td class="fielddoc"><p>(Sexpr_t Sexpr_t) Code body thunk pair; car is body (i.e., list of sexprs), cdr is environment with all variable bindings. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8ca0692d4fb60cb00594a5998ebcf39883b" name="aa11b65afd71903a81bbc611dcf5b3b8ca0692d4fb60cb00594a5998ebcf39883b"></a>T_ERROR&#160;</td><td class="fielddoc"><p>(Sexpr_t Sexpr_t) An error cell; car is a T_STRING, cdr is a pointer to <em>irritants</em>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa11b65afd71903a81bbc611dcf5b3b8caa222aa22504f258f7550461e9c88b152" name="aa11b65afd71903a81bbc611dcf5b3b8caa222aa22504f258f7550461e9c88b152"></a>Ntypes&#160;</td><td class="fielddoc"><p>Number of LambLisp virtual machine types. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a9d3e868f803fc5f83ef0a973fedd3e94" name="a9d3e868f803fc5f83ef0a973fedd3e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3e868f803fc5f83ef0a973fedd3e94">&#9670;&#160;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cell::zero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all cell bits to zero. </p>

</div>
</div>
<a id="a4f27baeb49e15a3591d07288fc6a19ce" name="a4f27baeb49e15a3591d07288fc6a19ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f27baeb49e15a3591d07288fc6a19ce">&#9670;&#160;</a></span>type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Int_t Cell::type </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the type of the cell as a small integer. </p>

</div>
</div>
<a id="aff015cf4a13e61fa2361c383f1fb84ba" name="aff015cf4a13e61fa2361c383f1fb84ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff015cf4a13e61fa2361c383f1fb84ba">&#9670;&#160;</a></span>type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cell::type </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the type of this cell. </p>

</div>
</div>
<a id="ad6c6a46173b370759db1a33ee9e51724" name="ad6c6a46173b370759db1a33ee9e51724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c6a46173b370759db1a33ee9e51724">&#9670;&#160;</a></span>flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Int_t Cell::flags </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the entire set of cell flags. </p>

</div>
</div>
<a id="a0f5da45b73bd704677e0475fdfefe8eb" name="a0f5da45b73bd704677e0475fdfefe8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5da45b73bd704677e0475fdfefe8eb">&#9670;&#160;</a></span>flags_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cell::flags_set </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the selected flags. </p>

</div>
</div>
<a id="a6e5e78964f1560157d4f67ac7aae3d9e" name="a6e5e78964f1560157d4f67ac7aae3d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5e78964f1560157d4f67ac7aae3d9e">&#9670;&#160;</a></span>flags_clr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cell::flags_clr </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the selected flags. </p>

</div>
</div>
<a id="a107d6f43bebb8e34b5d14d2443362d7b" name="a107d6f43bebb8e34b5d14d2443362d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107d6f43bebb8e34b5d14d2443362d7b">&#9670;&#160;</a></span>rplaca()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cell::rplaca </td>
          <td>(</td>
          <td class="paramtype">Word_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the cell car field. Called rplaca for historical reasons, and to distinguish it from set-car!, which must respect the GC flags. </p>

</div>
</div>
<a id="a33fd270edc4c9bbd2766129400349b60" name="a33fd270edc4c9bbd2766129400349b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fd270edc4c9bbd2766129400349b60">&#9670;&#160;</a></span>rplacd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cell::rplacd </td>
          <td>(</td>
          <td class="paramtype">Word_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the cell cdr field. Called rplacd for historical reasons, and to distinguish it from set-cdr!, which must respect the GC flags. </p>

</div>
</div>
<a id="a63b59ab22aa4372dcce06d2a0f20ba46" name="a63b59ab22aa4372dcce06d2a0f20ba46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b59ab22aa4372dcce06d2a0f20ba46">&#9670;&#160;</a></span>is_atom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t Cell::is_atom </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the cell is an atom. </p>

</div>
</div>
<a id="a8af6cbcc5f3057412cc64fd25c668e77" name="a8af6cbcc5f3057412cc64fd25c668e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af6cbcc5f3057412cc64fd25c668e77">&#9670;&#160;</a></span>is_pair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t Cell::is_pair </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the cell is a cons pair. </p>

</div>
</div>
<a id="a0ace83f0459ee051617d80ba1bcc303a" name="a0ace83f0459ee051617d80ba1bcc303a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ace83f0459ee051617d80ba1bcc303a">&#9670;&#160;</a></span>is_any_pair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t Cell::is_any_pair </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the cell is any pair type. </p>

</div>
</div>
<a id="a7df28c99369d118e8f0e7b915b7f873d" name="a7df28c99369d118e8f0e7b915b7f873d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df28c99369d118e8f0e7b915b7f873d">&#9670;&#160;</a></span>is_any_svec_atom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t Cell::is_any_svec_atom </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the cell is any kind of Sexpr_t vector. </p>

</div>
</div>
<a id="a2633575b3e20f43d469e8b8155d013b8" name="a2633575b3e20f43d469e8b8155d013b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2633575b3e20f43d469e8b8155d013b8">&#9670;&#160;</a></span>is_any_svec2n_atom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t Cell::is_any_svec2n_atom </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the cell is Sexpr_t vector of size 2^n. </p>

</div>
</div>
<a id="a1bd97610f104dd6e72a81d7e1bad1d70" name="a1bd97610f104dd6e72a81d7e1bad1d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd97610f104dd6e72a81d7e1bad1d70">&#9670;&#160;</a></span>is_any_str_atom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t Cell::is_any_str_atom </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the cell is any kind of string. </p>

</div>
</div>
<a id="ab84341b23ed8d9c566656be04af1da2d" name="ab84341b23ed8d9c566656be04af1da2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84341b23ed8d9c566656be04af1da2d">&#9670;&#160;</a></span>is_any_sym_atom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t Cell::is_any_sym_atom </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the cell is any kind of symbol. </p>

</div>
</div>
<a id="a4c2d9d0a2383caf1fabe82ac11954560" name="a4c2d9d0a2383caf1fabe82ac11954560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2d9d0a2383caf1fabe82ac11954560">&#9670;&#160;</a></span>is_any_bvec_atom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t Cell::is_any_bvec_atom </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the cell is any kind of bytevector. </p>

</div>
</div>
<a id="a95ef2701ff15d502f729e128d5bddc82" name="a95ef2701ff15d502f729e128d5bddc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ef2701ff15d502f729e128d5bddc82">&#9670;&#160;</a></span>gc_state() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Int_t Cell::gc_state </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the garbage collection stat eof this cell. </p>

</div>
</div>
<a id="aa0e98682c9df7e0a1c71e9594509d4ae" name="aa0e98682c9df7e0a1c71e9594509d4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e98682c9df7e0a1c71e9594509d4ae">&#9670;&#160;</a></span>gc_state() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::gc_state </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>st</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the garbage collection state of this cell, and return the cell. </p>

</div>
</div>
<a id="abd6ff16232e2765d260e26ca4cb3b274" name="abd6ff16232e2765d260e26ca4cb3b274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6ff16232e2765d260e26ca4cb3b274">&#9670;&#160;</a></span>tail_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Int_t Cell::tail_state </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the taill state of this cell. </p>

</div>
</div>
<a id="a4affea4c0ae33200868f78f1248ed5cc" name="a4affea4c0ae33200868f78f1248ed5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4affea4c0ae33200868f78f1248ed5cc">&#9670;&#160;</a></span>tail_state_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::tail_state_set </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the tail state flag on this cell, and return the cell. </p>

</div>
</div>
<a id="ab967e9b70c0c94116ebb3c76c85bf3d8" name="ab967e9b70c0c94116ebb3c76c85bf3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab967e9b70c0c94116ebb3c76c85bf3d8">&#9670;&#160;</a></span>tail_state_clr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::tail_state_clr </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the tail state flag on this cell, and return the cell. </p>

</div>
</div>
<a id="a364b771ac8ee90f164eb4fbab92d9d31" name="a364b771ac8ee90f164eb4fbab92d9d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364b771ac8ee90f164eb4fbab92d9d31">&#9670;&#160;</a></span>get_car_addr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ptr_t Cell::get_car_addr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the address of the cell car. </p>

</div>
</div>
<a id="a322233cd39ef9fc3724573f50fab03ac" name="a322233cd39ef9fc3724573f50fab03ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322233cd39ef9fc3724573f50fab03ac">&#9670;&#160;</a></span>get_car()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word_t Cell::get_car </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the cell car. </p>

</div>
</div>
<a id="a71633104c9a8d4a8601d7fd88f77166f" name="a71633104c9a8d4a8601d7fd88f77166f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71633104c9a8d4a8601d7fd88f77166f">&#9670;&#160;</a></span>get_cdr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word_t Cell::get_cdr </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the cell cdr. </p>

</div>
</div>
<a id="a65758e75669f3026a385a1a166f4a2f6" name="a65758e75669f3026a385a1a166f4a2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65758e75669f3026a385a1a166f4a2f6">&#9670;&#160;</a></span>as_Bool_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t Cell::as_Bool_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as a boolean. </p>

</div>
</div>
<a id="a43cf331a13d2d2f5dcf70f9eea572f2e" name="a43cf331a13d2d2f5dcf70f9eea572f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cf331a13d2d2f5dcf70f9eea572f2e">&#9670;&#160;</a></span>as_Char_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Char_t Cell::as_Char_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as a character. </p>

</div>
</div>
<a id="a5063fe8a7022342b50b15be54c0afe2e" name="a5063fe8a7022342b50b15be54c0afe2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5063fe8a7022342b50b15be54c0afe2e">&#9670;&#160;</a></span>as_Int_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Int_t Cell::as_Int_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as an integer. </p>

</div>
</div>
<a id="a0a07f6ddb36824aca07c03ccf4741c93" name="a0a07f6ddb36824aca07c03ccf4741c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a07f6ddb36824aca07c03ccf4741c93">&#9670;&#160;</a></span>as_Real_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real_t Cell::as_Real_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as a real number. </p>

</div>
</div>
<a id="a5373d587dae40805e94f97d1f7d6ab81" name="a5373d587dae40805e94f97d1f7d6ab81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5373d587dae40805e94f97d1f7d6ab81">&#9670;&#160;</a></span>as_Ptr_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ptr_t Cell::as_Ptr_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as a generic pointer (i.e., void*). </p>

</div>
</div>
<a id="a81f257368a5df0b56255f48826d5fadf" name="a81f257368a5df0b56255f48826d5fadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f257368a5df0b56255f48826d5fadf">&#9670;&#160;</a></span>as_Charst_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Charst_t Cell::as_Charst_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as a pointer to a zero-terminated character array. </p>

</div>
</div>
<a id="aa48a9eecffb0163b4a5884b571d84a66" name="aa48a9eecffb0163b4a5884b571d84a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48a9eecffb0163b4a5884b571d84a66">&#9670;&#160;</a></span>as_Bytest_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bytest_t Cell::as_Bytest_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as a pointer to an array of bytes. </p>

</div>
</div>
<a id="a438d4a6aa534369e19a2cc85e6b48f81" name="a438d4a6aa534369e19a2cc85e6b48f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438d4a6aa534369e19a2cc85e6b48f81">&#9670;&#160;</a></span>as_CharVec_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CharVec_t Cell::as_CharVec_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as a pointer to a zero-terminated character array. </p>

</div>
</div>
<a id="a23f0b4b3e7d4f086a3218eb1c22a3eb0" name="a23f0b4b3e7d4f086a3218eb1c22a3eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f0b4b3e7d4f086a3218eb1c22a3eb0">&#9670;&#160;</a></span>as_ByteVec_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ByteVec_t Cell::as_ByteVec_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as a pointer to an array of bytes. </p>

</div>
</div>
<a id="ac5b69357e77184493db61f8572bfe0ae" name="ac5b69357e77184493db61f8572bfe0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b69357e77184493db61f8572bfe0ae">&#9670;&#160;</a></span>as_Portst_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Portst_t Cell::as_Portst_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as a pointer to an instance of the system underlying "port" implementation. </p>

</div>
</div>
<a id="a6a152074d19914ceabe424ba418898e8" name="a6a152074d19914ceabe424ba418898e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a152074d19914ceabe424ba418898e8">&#9670;&#160;</a></span>as_numerator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Int_t Cell::as_numerator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as the numerator of a rational number. </p>

</div>
</div>
<a id="af212b8574301560ba04938c7deb68f3c" name="af212b8574301560ba04938c7deb68f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af212b8574301560ba04938c7deb68f3c">&#9670;&#160;</a></span>as_denominator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Int_t Cell::as_denominator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as the denominator of a rational number. </p>

</div>
</div>
<a id="a9e8b0e506738768655a3fc877fadbaf1" name="a9e8b0e506738768655a3fc877fadbaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8b0e506738768655a3fc877fadbaf1">&#9670;&#160;</a></span>hash_sexpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int_t Cell::hash_sexpr </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For symbols, the hash of its characters; for numbers, the hash of the number; otherwise the hash of the S-expression itself (i.e., the address of a cell). </p>

</div>
</div>
<a id="ad4678ca82413e46e827c53ccb228c531" name="ad4678ca82413e46e827c53ccb228c531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4678ca82413e46e827c53ccb228c531">&#9670;&#160;</a></span>hash_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int_t Cell::hash_contents </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For symbols, the hash of its characters; for numbers, strings, vectors, and bytevectors, the hash of the contents; otherwise the hash of the S-expression itself. </p>

</div>
</div>
<a id="ac64d511f91458fa7072a1325f1a652e6" name="ac64d511f91458fa7072a1325f1a652e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64d511f91458fa7072a1325f1a652e6">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Int_t Cell::hash </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hash value of this cell. </p>

</div>
</div>
<a id="aa3890dc292814a07257b7955dfefa6fc" name="aa3890dc292814a07257b7955dfefa6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3890dc292814a07257b7955dfefa6fc">&#9670;&#160;</a></span>set() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::set </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>typ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word_t</td>          <td class="paramname"><span class="paramname"><em>w1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word_t</td>          <td class="paramname"><span class="paramname"><em>w2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the lowest-level generic "set" function. </p>

</div>
</div>
<a id="abca5d1ff979dca624397e3e7e4d28451" name="abca5d1ff979dca624397e3e7e4d28451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca5d1ff979dca624397e3e7e4d28451">&#9670;&#160;</a></span>set() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::set </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>typ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a convenience function for common cases. </p>

</div>
</div>
<a id="aad5c6bb9fcd77ef2c51df69fa4e046e5" name="aad5c6bb9fcd77ef2c51df69fa4e046e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5c6bb9fcd77ef2c51df69fa4e046e5">&#9670;&#160;</a></span>set() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::set </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>typ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a convenience function for common cases. </p>

</div>
</div>
<a id="a04b15a010dd6946a700250c57bd7c0a9" name="a04b15a010dd6946a700250c57bd7c0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b15a010dd6946a700250c57bd7c0a9">&#9670;&#160;</a></span>set() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::set </td>
          <td>(</td>
          <td class="paramtype">Bool_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set cell as boolean. </p>

</div>
</div>
<a id="ad27d4b1daa039bfd2fb925c1ce33fe21" name="ad27d4b1daa039bfd2fb925c1ce33fe21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27d4b1daa039bfd2fb925c1ce33fe21">&#9670;&#160;</a></span>set() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::set </td>
          <td>(</td>
          <td class="paramtype">Char_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set cell as character. </p>

</div>
</div>
<a id="a2ea142f8dd9b34e535a145e1bc0ffcc5" name="a2ea142f8dd9b34e535a145e1bc0ffcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea142f8dd9b34e535a145e1bc0ffcc5">&#9670;&#160;</a></span>set() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::set </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set cell as integer. </p>

</div>
</div>
<a id="a4dd11aac5af3b679e10083b90d87fd78" name="a4dd11aac5af3b679e10083b90d87fd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd11aac5af3b679e10083b90d87fd78">&#9670;&#160;</a></span>set() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::set </td>
          <td>(</td>
          <td class="paramtype">Real_t</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set cell as real. </p>

</div>
</div>
<a id="ae44f742c2fd4cc7734474c24f5e88059" name="ae44f742c2fd4cc7734474c24f5e88059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44f742c2fd4cc7734474c24f5e88059">&#9670;&#160;</a></span>set() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::set </td>
          <td>(</td>
          <td class="paramtype">Port_t &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set cell as port. </p>

</div>
</div>
<a id="a6b54c4fe1d55befc316de78dd9a5fb86" name="a6b54c4fe1d55befc316de78dd9a5fb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b54c4fe1d55befc316de78dd9a5fb86">&#9670;&#160;</a></span>set() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::set </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>typ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Charst_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set cell as a immutable string. </p>

</div>
</div>
<a id="a00e86fd8c56ae7ac484dcf8cb0f6b236" name="a00e86fd8c56ae7ac484dcf8cb0f6b236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e86fd8c56ae7ac484dcf8cb0f6b236">&#9670;&#160;</a></span>set() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::set </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>typ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bytest_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set cell as a immutable bytevector. </p>

</div>
</div>
<a id="a0d8191bee104e35cdd63a003933bbdcc" name="a0d8191bee104e35cdd63a003933bbdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8191bee104e35cdd63a003933bbdcc">&#9670;&#160;</a></span>set() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::set </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>typ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharVec_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set cell as a mutable string. </p>

</div>
</div>
<a id="a1a5d375340f4da8978b5cf79c003deb7" name="a1a5d375340f4da8978b5cf79c003deb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5d375340f4da8978b5cf79c003deb7">&#9670;&#160;</a></span>set() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::set </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>typ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteVec_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set cell as a mutable bytevector. </p>

</div>
</div>
<a id="ac3904b29bfd9688456754f2f99c8005e" name="ac3904b29bfd9688456754f2f99c8005e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3904b29bfd9688456754f2f99c8005e">&#9670;&#160;</a></span>mk_error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::mk_error </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills and returns the single Cell-level T_ERROR object. </p>

</div>
</div>
<a id="a68bd39dbebac4d554b9d7088f38bc899" name="a68bd39dbebac4d554b9d7088f38bc899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bd39dbebac4d554b9d7088f38bc899">&#9670;&#160;</a></span>mk_error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::mk_error </td>
          <td>(</td>
          <td class="paramtype">Sexpr_t</td>          <td class="paramname"><span class="paramname"><em>irritants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills and returns the single Cell-level T_ERROR object. </p>

</div>
</div>
<a id="af2597eb1793b008a65782296f7ef027d" name="af2597eb1793b008a65782296f7ef027d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2597eb1793b008a65782296f7ef027d">&#9670;&#160;</a></span>prechecked_str_heap_get_chars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CharVec_t Cell::prechecked_str_heap_get_chars </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the character array in the heap. </p>

</div>
</div>
<a id="a1fd585692aefb1d73653ffda48b4a443" name="a1fd585692aefb1d73653ffda48b4a443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd585692aefb1d73653ffda48b4a443">&#9670;&#160;</a></span>prechecked_str_ext_get_chars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CharVec_t Cell::prechecked_str_ext_get_chars </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the character array located outside the heap. </p>

</div>
</div>
<a id="a9cf08a22d5fc8ef04d540bc20353fc43" name="a9cf08a22d5fc8ef04d540bc20353fc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf08a22d5fc8ef04d540bc20353fc43">&#9670;&#160;</a></span>prechecked_str_imm_get_chars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CharVec_t Cell::prechecked_str_imm_get_chars </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the character array embedded in this cell. </p>

</div>
</div>
<a id="ac1e4b2d3caad7e7a941c2d585c2a929c" name="ac1e4b2d3caad7e7a941c2d585c2a929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e4b2d3caad7e7a941c2d585c2a929c">&#9670;&#160;</a></span>mustbe_Bool_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bool_t Cell::mustbe_Bool_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as a boolean. </p>

</div>
</div>
<a id="a44220de7d2f21182e625ec4911296563" name="a44220de7d2f21182e625ec4911296563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44220de7d2f21182e625ec4911296563">&#9670;&#160;</a></span>mustbe_Char_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Char_t Cell::mustbe_Char_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as a character. </p>

</div>
</div>
<a id="ad652ff1276570beb205c7805ee647b4f" name="ad652ff1276570beb205c7805ee647b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad652ff1276570beb205c7805ee647b4f">&#9670;&#160;</a></span>mustbe_Int_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Int_t Cell::mustbe_Int_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as an integer. </p>

</div>
</div>
<a id="a3d01c0b8436bdb2a7ce314575940d2f7" name="a3d01c0b8436bdb2a7ce314575940d2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d01c0b8436bdb2a7ce314575940d2f7">&#9670;&#160;</a></span>mustbe_Real_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real_t Cell::mustbe_Real_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of this cell as a real number. </p>

</div>
</div>
<a id="a6c6c1cbc18b59808234273cb1a8765e6" name="a6c6c1cbc18b59808234273cb1a8765e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6c1cbc18b59808234273cb1a8765e6">&#9670;&#160;</a></span>mustbe_any_str_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::mustbe_any_str_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this cell if it is a string. </p>

</div>
</div>
<a id="a109ae6cbbb6a3a3a51c12fa032b9e5fa" name="a109ae6cbbb6a3a3a51c12fa032b9e5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109ae6cbbb6a3a3a51c12fa032b9e5fa">&#9670;&#160;</a></span>mustbe_cppobj_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sexpr_t Cell::mustbe_cppobj_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this cell if it is a CPP object. </p>

</div>
</div>
<a id="ac7bb3c494eb42f3f7ced79a5b12174fe" name="ac7bb3c494eb42f3f7ced79a5b12174fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7bb3c494eb42f3f7ced79a5b12174fe">&#9670;&#160;</a></span>prechecked_cppobj_get_deleter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CPPDeleterPtr Cell::prechecked_cppobj_get_deleter </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the function to be called at garbage collection time to recycle the C++ object. </p>

</div>
</div>
<a id="aaec0ece3c1dc827b408a30fccd61ba8f" name="aaec0ece3c1dc827b408a30fccd61ba8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec0ece3c1dc827b408a30fccd61ba8f">&#9670;&#160;</a></span>prechecked_cppobj_get_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ptr_t Cell::prechecked_cppobj_get_ptr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to a C++ object obtained earlier. </p>

</div>
</div>
<a id="a0dcf7b0134d26f24e32ab61aabffe202" name="a0dcf7b0134d26f24e32ab61aabffe202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcf7b0134d26f24e32ab61aabffe202">&#9670;&#160;</a></span>any_str_get_chars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CharVec_t Cell::any_str_get_chars </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the cell is any kind of string, return a pointer to the zero-terminated character array. </p>

</div>
</div>
<a id="a29b39708a4fa37c77baaee15653f27e9" name="a29b39708a4fa37c77baaee15653f27e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b39708a4fa37c77baaee15653f27e9">&#9670;&#160;</a></span>cell_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String Cell::cell_name </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience feature to produce a string name for cells which are "well known" like NIL. Otherwise the name is the hex representation of the cell address. </p>

</div>
</div>
<a id="a4fe9d8d3ced099a8fe88c812c7ae872f" name="a4fe9d8d3ced099a8fe88c812c7ae872f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe9d8d3ced099a8fe88c812c7ae872f">&#9670;&#160;</a></span>type_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Charst_t Cell::type_name </td>
          <td>(</td>
          <td class="paramtype">Int_t</td>          <td class="paramname"><span class="paramname"><em>typ</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the C string corresponding to the cell type. </p>

</div>
</div>
<a id="ae705e68c441fbb2edfb28297412c265e" name="ae705e68c441fbb2edfb28297412c265e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae705e68c441fbb2edfb28297412c265e">&#9670;&#160;</a></span>gcstate_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Charst_t Cell::gcstate_name </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a C string corresponding to the given GC state. </p>

</div>
</div>
<a id="ae7c2815a58b1ca3b156e695ff3edb3e5" name="ae7c2815a58b1ca3b156e695ff3edb3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c2815a58b1ca3b156e695ff3edb3e5">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String Cell::dump </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a printable representation of the <a class="el" href="classCell.html">Cell</a> internals. </p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a78860a53881062feafa9524b900ab607" name="a78860a53881062feafa9524b900ab607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78860a53881062feafa9524b900ab607">&#9670;&#160;</a></span>F_GC01</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int Cell::F_GC01 = 0x01</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gc flag </p>

</div>
</div>
<a id="a027e3fa2f49761b94c09423a9c89e1b1" name="a027e3fa2f49761b94c09423a9c89e1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027e3fa2f49761b94c09423a9c89e1b1">&#9670;&#160;</a></span>F_GC02</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int Cell::F_GC02 = 0x02</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gc flag </p>

</div>
</div>
<a id="a3cd531cc4ef1100b395eeca92a603d72" name="a3cd531cc4ef1100b395eeca92a603d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd531cc4ef1100b395eeca92a603d72">&#9670;&#160;</a></span>F_GC04</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int Cell::F_GC04 = 0x04</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gc flag </p>

</div>
</div>
<a id="aa2b70e77b196c841b8b199c0809bd7c7" name="aa2b70e77b196c841b8b199c0809bd7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b70e77b196c841b8b199c0809bd7c7">&#9670;&#160;</a></span>F_TAIL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int Cell::F_TAIL = 0x08</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>trampoline tail marker </p>

</div>
</div>
<a id="ad199c6c6035e34426c0343962ec255c3" name="ad199c6c6035e34426c0343962ec255c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad199c6c6035e34426c0343962ec255c3">&#9670;&#160;</a></span>F_0x10</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int Cell::F_0x10 = 0x10</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>spare </p>

</div>
</div>
<a id="a50e8a9c36343cec6db6a681850e4db3c" name="a50e8a9c36343cec6db6a681850e4db3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e8a9c36343cec6db6a681850e4db3c">&#9670;&#160;</a></span>F_0x20</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int Cell::F_0x20 = 0x20</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>spare </p>

</div>
</div>
<a id="a514b8fb854bf5aaeb7b8e1f5c0496b09" name="a514b8fb854bf5aaeb7b8e1f5c0496b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514b8fb854bf5aaeb7b8e1f5c0496b09">&#9670;&#160;</a></span>F_0x40</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int Cell::F_0x40 = 0x40</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>spare </p>

</div>
</div>
<a id="a8726664297b2bfa4229fac1bfa2e8462" name="a8726664297b2bfa4229fac1bfa2e8462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8726664297b2bfa4229fac1bfa2e8462">&#9670;&#160;</a></span>F_0x80</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int Cell::F_0x80 = 0x80</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>spare </p>

</div>
</div>
<a id="a52c97a089e5a0c7c89a0243bfe5b6a34" name="a52c97a089e5a0c7c89a0243bfe5b6a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c97a089e5a0c7c89a0243bfe5b6a34">&#9670;&#160;</a></span>GC_STATE_MASK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int Cell::GC_STATE_MASK = <a class="el" href="#a78860a53881062feafa9524b900ab607">F_GC01</a> | <a class="el" href="#a027e3fa2f49761b94c09423a9c89e1b1">F_GC02</a> | <a class="el" href="#a3cd531cc4ef1100b395eeca92a603d72">F_GC04</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask for obtaining garbage collection state bits from <a class="el" href="classCell.html">Cell</a> flag byte. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.16.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="classCell.html">Cell</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.0 </li>
  </ul>
</div>
</body>
</html>
